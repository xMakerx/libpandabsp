/*
 * This file was generated by:
 * C:\Users\maver\Documents\OpenCIO\opencio-panda3d\built_x64\bin\interrogate -fnames -string -refcount -assert -python-native -SC:\Users\maver\Documents\OpenCIO\opencio-panda3d\built_x64/include/parser-inc/ -SC:\Users\maver\Documents\OpenCIO\opencio-panda3d\built_x64/include/ -I./ -srcdir ./ -oc libpandabsp_igate.cpp -od libpandabsp.in -module libpandabsp -library libpandabsp -Dvolatile= -D_PYTHON_VERSION -DINTERROGATE -DCPPPARSER -DCIO -D__STDC__=1 -D__cplusplus=201103L -D__inline -D_X86_ -DWIN32_VC -DWIN32 -D_WIN32 -D_MSC_VER=1600 -DWIN64_VC -DWIN64 -D_WIN64 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall config_bsp.h bsploader.h entity.h bsp_render.h shader_generator.h shader_spec.h bsp_material.h TexturePacker.h shader_vertexlitgeneric.h shader_lightmappedgeneric.h shader_unlitgeneric.h shader_unlitnomat.h shader_csmrender.h raytrace.h shader_skybox.h ambient_boost_effect.h audio_3d_manager.h ciolib.h bounding_kdop.h shader_decalmodulate.h glow_node.h postprocess/postprocess.h postprocess/hdr.h postprocess/bloom.h lighting_origin_effect.h planar_reflections.h postprocess/fxaa.h bloom_attrib.h physics_character_controller.h py_bsploader.h interpolatedvar.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "TexturePacker.h"
#include <aa_luse.h>
#include "ambient_boost_effect.h"
#include "ambient_probes.h"
#include <audioManager.h>
#include <audioSound.h>
#include "audio_3d_manager.h"
#include "bloom_attrib.h"
#include <boundingBox.h>
#include "bounding_kdop.h"
#include "bsp_material.h"
#include "bsp_render.h"
#include "bsp_trace.h"
#include "bspfile.h"
#include "bsploader.h"
#include <bulletCapsuleShape.h>
#include <bulletRigidBodyNode.h>
#include <bulletWorld.h>
#include <callbackObject.h>
#include <camera.h>
#include "ciolib.h"
#include <clockObject.h>
#include <configVariableBool.h>
#include <configVariableDouble.h>
#include "config_bsp.h"
#include "cubemaps.h"
#include <cullTraverser.h>
#include <cullableObject.h>
#include <dconfig.h>
#include "decals.h"
#include "entity.h"
#include <filename.h>
#include <frameBufferProperties.h>
#include <genericAsyncTask.h>
#include <geom.h>
#include <geomNode.h>
#include "glow_node.h"
#include <graphicsBuffer.h>
#include <graphicsStateGuardian.h>
#include <graphicsWindow.h>
#include "interpolatedvar.h"
#include <lightReMutex.h>
#include "lighting_origin_effect.h"
#include "lightmap_palettes.h"
#include <lvector3.h>
#include "mathlib.h"
#include <modelNode.h>
#include <modelRoot.h>
#include <mouseWatcher.h>
#include <namable.h>
#include <nodePath.h>
#include <nodePathCollection.h>
#include <occlusionQueryContext.h>
#include <pandaNode.h>
#include <pandabase.h>
#include "physics_character_controller.h"
#include "planar_reflections.h"
#include <pnmImage.h>
#include <pointerTo.h>
#include "postprocess/bloom.h"
#include "postprocess/fxaa.h"
#include "postprocess/hdr.h"
#include "postprocess/postprocess.h"
#include "postprocess/postprocess_effect.h"
#include "postprocess/postprocess_pass.h"
#include "postprocess/postprocess_scene_pass.h"
#include <pta_float.h>
#include "py_bsploader.h"
#include <py_panda.h>
#include "raytrace.h"
#include <referenceCount.h>
#include <renderAttrib.h>
#include <renderEffect.h>
#include <renderState.h>
#include "shader_csmrender.h"
#include "shader_decalmodulate.h"
#include "shader_features.h"
#include "shader_generator.h"
#include "shader_lightmappedgeneric.h"
#include "shader_skybox.h"
#include "shader_spec.h"
#include "shader_unlitgeneric.h"
#include "shader_unlitnomat.h"
#include "shader_vertexlitgeneric.h"
#include <simpleHashMap.h>
#include <texture.h>
#include <typedReferenceCount.h>
#include <weakNodePath.h>
#include <weakPointerCallback.h>

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class TextureStages
 */
typedef TextureStages TextureStages_localtype;
Define_Module_Class(libpandabsp, TextureStages, TextureStages_localtype, TextureStages);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureStages = &Dtool_TextureStages;
static void Dtool_PyModuleClassInit_TextureStages(PyObject *module);

/**
 * Forward declarations for top-level class BSPMaterial
 */
typedef BSPMaterial BSPMaterial_localtype;
Define_Module_ClassRef(libpandabsp, BSPMaterial, BSPMaterial_localtype, BSPMaterial);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPMaterial = &Dtool_BSPMaterial;
static void Dtool_PyModuleClassInit_BSPMaterial(PyObject *module);

/**
 * Forward declarations for top-level class BSPMaterialAttrib
 */
typedef BSPMaterialAttrib BSPMaterialAttrib_localtype;
Define_Module_ClassRef(libpandabsp, BSPMaterialAttrib, BSPMaterialAttrib_localtype, BSPMaterialAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPMaterialAttrib = &Dtool_BSPMaterialAttrib;
static void Dtool_PyModuleClassInit_BSPMaterialAttrib(PyObject *module);
bool Dtool_ConstCoerce_BSPMaterialAttrib(PyObject *args, CPT(BSPMaterialAttrib) &coerced);

/**
 * Forward declarations for top-level class PackResult
 */
typedef PackResult PackResult_localtype;
Define_Module_Class(libpandabsp, PackResult, PackResult_localtype, PackResult);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PackResult = &Dtool_PackResult;
static void Dtool_PyModuleClassInit_PackResult(PyObject *module);

/**
 * Forward declarations for top-level class TextureLocation
 */
typedef TextureLocation TextureLocation_localtype;
Define_Module_Class(libpandabsp, TextureLocation, TextureLocation_localtype, TextureLocation);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureLocation = &Dtool_TextureLocation;
static void Dtool_PyModuleClassInit_TextureLocation(PyObject *module);

/**
 * Forward declarations for top-level class TexturePacker
 */
typedef TexturePacker TexturePacker_localtype;
Define_Module_Class(libpandabsp, TexturePacker, TexturePacker_localtype, TexturePacker);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TexturePacker = &Dtool_TexturePacker;
static void Dtool_PyModuleClassInit_TexturePacker(PyObject *module);

/**
 * Forward declarations for top-level class RayTrace
 */
typedef RayTrace RayTrace_localtype;
Define_Module_Class(libpandabsp, RayTrace, RayTrace_localtype, RayTrace);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RayTrace = &Dtool_RayTrace;
static void Dtool_PyModuleClassInit_RayTrace(PyObject *module);

/**
 * Forward declarations for top-level class RayTraceHitResult
 */
typedef RayTraceHitResult RayTraceHitResult_localtype;
Define_Module_Class(libpandabsp, RayTraceHitResult, RayTraceHitResult_localtype, RayTraceHitResult);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RayTraceHitResult = &Dtool_RayTraceHitResult;
static void Dtool_PyModuleClassInit_RayTraceHitResult(PyObject *module);

/**
 * Forward declarations for top-level class RayTraceScene
 */
typedef RayTraceScene RayTraceScene_localtype;
Define_Module_ClassRef(libpandabsp, RayTraceScene, RayTraceScene_localtype, RayTraceScene);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RayTraceScene = &Dtool_RayTraceScene;
static void Dtool_PyModuleClassInit_RayTraceScene(PyObject *module);

/**
 * Forward declarations for top-level class RayTraceGeometry
 */
typedef RayTraceGeometry RayTraceGeometry_localtype;
Define_Module_ClassRef(libpandabsp, RayTraceGeometry, RayTraceGeometry_localtype, RayTraceGeometry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RayTraceGeometry = &Dtool_RayTraceGeometry;
static void Dtool_PyModuleClassInit_RayTraceGeometry(PyObject *module);
bool Dtool_ConstCoerce_RayTraceGeometry(PyObject *args, CPT(RayTraceGeometry) &coerced);
bool Dtool_Coerce_RayTraceGeometry(PyObject *args, PT(RayTraceGeometry) &coerced);

/**
 * Forward declarations for top-level class RayTraceTriangleMesh
 */
typedef RayTraceTriangleMesh RayTraceTriangleMesh_localtype;
Define_Module_ClassRef(libpandabsp, RayTraceTriangleMesh, RayTraceTriangleMesh_localtype, RayTraceTriangleMesh);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RayTraceTriangleMesh = &Dtool_RayTraceTriangleMesh;
static void Dtool_PyModuleClassInit_RayTraceTriangleMesh(PyObject *module);
bool Dtool_ConstCoerce_RayTraceTriangleMesh(PyObject *args, CPT(RayTraceTriangleMesh) &coerced);
bool Dtool_Coerce_RayTraceTriangleMesh(PyObject *args, PT(RayTraceTriangleMesh) &coerced);

/**
 * Forward declarations for top-level class BSPFaceAttrib
 */
typedef BSPFaceAttrib BSPFaceAttrib_localtype;
Define_Module_ClassRef(libpandabsp, BSPFaceAttrib, BSPFaceAttrib_localtype, BSPFaceAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPFaceAttrib = &Dtool_BSPFaceAttrib;
static void Dtool_PyModuleClassInit_BSPFaceAttrib(PyObject *module);
bool Dtool_ConstCoerce_BSPFaceAttrib(PyObject *args, CPT(BSPFaceAttrib) &coerced);

/**
 * Forward declarations for top-level class BSPLoader
 */
typedef BSPLoader BSPLoader_localtype;
Define_Module_Class(libpandabsp, BSPLoader, BSPLoader_localtype, BSPLoader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPLoader = &Dtool_BSPLoader;
static void Dtool_PyModuleClassInit_BSPLoader(PyObject *module);

/**
 * Forward declarations for top-level class BoundingKDOP
 */
typedef BoundingKDOP BoundingKDOP_localtype;
Define_Module_ClassRef(libpandabsp, BoundingKDOP, BoundingKDOP_localtype, BoundingKDOP);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingKDOP = &Dtool_BoundingKDOP;
static void Dtool_PyModuleClassInit_BoundingKDOP(PyObject *module);

/**
 * Forward declarations for top-level class CBaseEntity
 */
typedef CBaseEntity CBaseEntity_localtype;
Define_Module_ClassRef(libpandabsp, CBaseEntity, CBaseEntity_localtype, CBaseEntity);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CBaseEntity = &Dtool_CBaseEntity;
static void Dtool_PyModuleClassInit_CBaseEntity(PyObject *module);

/**
 * Forward declarations for top-level class CPointEntity
 */
typedef CPointEntity CPointEntity_localtype;
Define_Module_ClassRef(libpandabsp, CPointEntity, CPointEntity_localtype, CPointEntity);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CPointEntity = &Dtool_CPointEntity;
static void Dtool_PyModuleClassInit_CPointEntity(PyObject *module);

/**
 * Forward declarations for top-level class CBoundsEntity
 */
typedef CBoundsEntity CBoundsEntity_localtype;
Define_Module_ClassRef(libpandabsp, CBoundsEntity, CBoundsEntity_localtype, CBoundsEntity);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CBoundsEntity = &Dtool_CBoundsEntity;
static void Dtool_PyModuleClassInit_CBoundsEntity(PyObject *module);

/**
 * Forward declarations for top-level class CBrushEntity
 */
typedef CBrushEntity CBrushEntity_localtype;
Define_Module_ClassRef(libpandabsp, CBrushEntity, CBrushEntity_localtype, CBrushEntity);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CBrushEntity = &Dtool_CBrushEntity;
static void Dtool_PyModuleClassInit_CBrushEntity(PyObject *module);

/**
 * Forward declarations for top-level class ShaderPermutations
 */
typedef ShaderPermutations ShaderPermutations_localtype;
Define_Module_ClassRef(libpandabsp, ShaderPermutations, ShaderPermutations_localtype, ShaderPermutations);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderPermutations = &Dtool_ShaderPermutations;
static void Dtool_PyModuleClassInit_ShaderPermutations(PyObject *module);

/**
 * Forward declarations for top-level class ShaderSpec
 */
typedef ShaderSpec ShaderSpec_localtype;
Define_Module_ClassRef(libpandabsp, ShaderSpec, ShaderSpec_localtype, ShaderSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderSpec = &Dtool_ShaderSpec;
static void Dtool_PyModuleClassInit_ShaderSpec(PyObject *module);
bool Dtool_ConstCoerce_ShaderSpec(PyObject *args, CPT(ShaderSpec) &coerced);
bool Dtool_Coerce_ShaderSpec(PyObject *args, PT(ShaderSpec) &coerced);

/**
 * Forward declarations for top-level class PlanarReflections
 */
typedef PlanarReflections PlanarReflections_localtype;
Define_Module_ClassRef(libpandabsp, PlanarReflections, PlanarReflections_localtype, PlanarReflections);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PlanarReflections = &Dtool_PlanarReflections;
static void Dtool_PyModuleClassInit_PlanarReflections(PyObject *module);

/**
 * Forward declarations for top-level class BSPShaderGenerator
 */
typedef BSPShaderGenerator BSPShaderGenerator_localtype;
Define_Module_ClassRef(libpandabsp, BSPShaderGenerator, BSPShaderGenerator_localtype, BSPShaderGenerator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPShaderGenerator = &Dtool_BSPShaderGenerator;
static void Dtool_PyModuleClassInit_BSPShaderGenerator(PyObject *module);
bool Dtool_ConstCoerce_BSPShaderGenerator(PyObject *args, CPT(BSPShaderGenerator) &coerced);
bool Dtool_Coerce_BSPShaderGenerator(PyObject *args, PT(BSPShaderGenerator) &coerced);

/**
 * Forward declarations for top-level class BSPCullTraverser
 */
typedef BSPCullTraverser BSPCullTraverser_localtype;
Define_Module_ClassRef(libpandabsp, BSPCullTraverser, BSPCullTraverser_localtype, BSPCullTraverser);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPCullTraverser = &Dtool_BSPCullTraverser;
static void Dtool_PyModuleClassInit_BSPCullTraverser(PyObject *module);
bool Dtool_ConstCoerce_BSPCullTraverser(PyObject *args, CPT(BSPCullTraverser) &coerced);
bool Dtool_Coerce_BSPCullTraverser(PyObject *args, PT(BSPCullTraverser) &coerced);

/**
 * Forward declarations for top-level class BSPRender
 */
typedef BSPRender BSPRender_localtype;
Define_Module_ClassRef(libpandabsp, BSPRender, BSPRender_localtype, BSPRender);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPRender = &Dtool_BSPRender;
static void Dtool_PyModuleClassInit_BSPRender(PyObject *module);
bool Dtool_ConstCoerce_BSPRender(PyObject *args, CPT(BSPRender) &coerced);
bool Dtool_Coerce_BSPRender(PyObject *args, PT(BSPRender) &coerced);

/**
 * Forward declarations for top-level class BSPRoot
 */
typedef BSPRoot BSPRoot_localtype;
Define_Module_ClassRef(libpandabsp, BSPRoot, BSPRoot_localtype, BSPRoot);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPRoot = &Dtool_BSPRoot;
static void Dtool_PyModuleClassInit_BSPRoot(PyObject *module);
bool Dtool_ConstCoerce_BSPRoot(PyObject *args, CPT(BSPRoot) &coerced);
bool Dtool_Coerce_BSPRoot(PyObject *args, PT(BSPRoot) &coerced);

/**
 * Forward declarations for top-level class BSPProp
 */
typedef BSPProp BSPProp_localtype;
Define_Module_ClassRef(libpandabsp, BSPProp, BSPProp_localtype, BSPProp);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPProp = &Dtool_BSPProp;
static void Dtool_PyModuleClassInit_BSPProp(PyObject *module);
bool Dtool_ConstCoerce_BSPProp(PyObject *args, CPT(BSPProp) &coerced);
bool Dtool_Coerce_BSPProp(PyObject *args, PT(BSPProp) &coerced);

/**
 * Forward declarations for top-level class BSPModel
 */
typedef BSPModel BSPModel_localtype;
Define_Module_ClassRef(libpandabsp, BSPModel, BSPModel_localtype, BSPModel);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPModel = &Dtool_BSPModel;
static void Dtool_PyModuleClassInit_BSPModel(PyObject *module);
bool Dtool_ConstCoerce_BSPModel(PyObject *args, CPT(BSPModel) &coerced);
bool Dtool_Coerce_BSPModel(PyObject *args, PT(BSPModel) &coerced);

/**
 * Forward declarations for top-level class VertexLitGenericSpec
 */
typedef VertexLitGenericSpec VertexLitGenericSpec_localtype;
Define_Module_ClassRef(libpandabsp, VertexLitGenericSpec, VertexLitGenericSpec_localtype, VertexLitGenericSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VertexLitGenericSpec = &Dtool_VertexLitGenericSpec;
static void Dtool_PyModuleClassInit_VertexLitGenericSpec(PyObject *module);

/**
 * Forward declarations for top-level class LightmappedGenericSpec
 */
typedef LightmappedGenericSpec LightmappedGenericSpec_localtype;
Define_Module_ClassRef(libpandabsp, LightmappedGenericSpec, LightmappedGenericSpec_localtype, LightmappedGenericSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightmappedGenericSpec = &Dtool_LightmappedGenericSpec;
static void Dtool_PyModuleClassInit_LightmappedGenericSpec(PyObject *module);

/**
 * Forward declarations for top-level class UnlitGenericSpec
 */
typedef UnlitGenericSpec UnlitGenericSpec_localtype;
Define_Module_ClassRef(libpandabsp, UnlitGenericSpec, UnlitGenericSpec_localtype, UnlitGenericSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnlitGenericSpec = &Dtool_UnlitGenericSpec;
static void Dtool_PyModuleClassInit_UnlitGenericSpec(PyObject *module);

/**
 * Forward declarations for top-level class UnlitNoMatSpec
 */
typedef UnlitNoMatSpec UnlitNoMatSpec_localtype;
Define_Module_ClassRef(libpandabsp, UnlitNoMatSpec, UnlitNoMatSpec_localtype, UnlitNoMatSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnlitNoMatSpec = &Dtool_UnlitNoMatSpec;
static void Dtool_PyModuleClassInit_UnlitNoMatSpec(PyObject *module);

/**
 * Forward declarations for top-level class CSMRenderSpec
 */
typedef CSMRenderSpec CSMRenderSpec_localtype;
Define_Module_ClassRef(libpandabsp, CSMRenderSpec, CSMRenderSpec_localtype, CSMRenderSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CSMRenderSpec = &Dtool_CSMRenderSpec;
static void Dtool_PyModuleClassInit_CSMRenderSpec(PyObject *module);

/**
 * Forward declarations for top-level class SkyBoxSpec
 */
typedef SkyBoxSpec SkyBoxSpec_localtype;
Define_Module_ClassRef(libpandabsp, SkyBoxSpec, SkyBoxSpec_localtype, SkyBoxSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SkyBoxSpec = &Dtool_SkyBoxSpec;
static void Dtool_PyModuleClassInit_SkyBoxSpec(PyObject *module);

/**
 * Forward declarations for top-level class AmbientBoostEffect
 */
typedef AmbientBoostEffect AmbientBoostEffect_localtype;
Define_Module_ClassRef(libpandabsp, AmbientBoostEffect, AmbientBoostEffect_localtype, AmbientBoostEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AmbientBoostEffect = &Dtool_AmbientBoostEffect;
static void Dtool_PyModuleClassInit_AmbientBoostEffect(PyObject *module);

/**
 * Forward declarations for top-level class Audio3DManager
 */
typedef Audio3DManager Audio3DManager_localtype;
Define_Module_ClassRef(libpandabsp, Audio3DManager, Audio3DManager_localtype, Audio3DManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Audio3DManager = &Dtool_Audio3DManager;
static void Dtool_PyModuleClassInit_Audio3DManager(PyObject *module);
bool Dtool_ConstCoerce_Audio3DManager(PyObject *args, CPT(Audio3DManager) &coerced);
bool Dtool_Coerce_Audio3DManager(PyObject *args, PT(Audio3DManager) &coerced);

/**
 * Forward declarations for top-level class CIOLib
 */
typedef CIOLib CIOLib_localtype;
Define_Module_Class(libpandabsp, CIOLib, CIOLib_localtype, CIOLib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CIOLib = &Dtool_CIOLib;
static void Dtool_PyModuleClassInit_CIOLib(PyObject *module);

/**
 * Forward declarations for top-level class DecalModulateSpec
 */
typedef DecalModulateSpec DecalModulateSpec_localtype;
Define_Module_ClassRef(libpandabsp, DecalModulateSpec, DecalModulateSpec_localtype, DecalModulateSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DecalModulateSpec = &Dtool_DecalModulateSpec;
static void Dtool_PyModuleClassInit_DecalModulateSpec(PyObject *module);

/**
 * Forward declarations for top-level class GlowNode
 */
typedef GlowNode GlowNode_localtype;
Define_Module_ClassRef(libpandabsp, GlowNode, GlowNode_localtype, GlowNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GlowNode = &Dtool_GlowNode;
static void Dtool_PyModuleClassInit_GlowNode(PyObject *module);
bool Dtool_ConstCoerce_GlowNode(PyObject *args, CPT(GlowNode) &coerced);
bool Dtool_Coerce_GlowNode(PyObject *args, PT(GlowNode) &coerced);

/**
 * Forward declarations for top-level class PostProcessEffect
 */
typedef PostProcessEffect PostProcessEffect_localtype;
Define_Module_ClassRef(libpandabsp, PostProcessEffect, PostProcessEffect_localtype, PostProcessEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PostProcessEffect = &Dtool_PostProcessEffect;
static void Dtool_PyModuleClassInit_PostProcessEffect(PyObject *module);
bool Dtool_ConstCoerce_PostProcessEffect(PyObject *args, CPT(PostProcessEffect) &coerced);
bool Dtool_Coerce_PostProcessEffect(PyObject *args, PT(PostProcessEffect) &coerced);

/**
 * Forward declarations for top-level class PostProcessPass
 */
typedef PostProcessPass PostProcessPass_localtype;
Define_Module_ClassRef(libpandabsp, PostProcessPass, PostProcessPass_localtype, PostProcessPass);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PostProcessPass = &Dtool_PostProcessPass;
static void Dtool_PyModuleClassInit_PostProcessPass(PyObject *module);
bool Dtool_ConstCoerce_PostProcessPass(PyObject *args, CPT(PostProcessPass) &coerced);
bool Dtool_Coerce_PostProcessPass(PyObject *args, PT(PostProcessPass) &coerced);

/**
 * Forward declarations for top-level class PostProcessScenePass
 */
typedef PostProcessScenePass PostProcessScenePass_localtype;
Define_Module_ClassRef(libpandabsp, PostProcessScenePass, PostProcessScenePass_localtype, PostProcessScenePass);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PostProcessScenePass = &Dtool_PostProcessScenePass;
static void Dtool_PyModuleClassInit_PostProcessScenePass(PyObject *module);
bool Dtool_ConstCoerce_PostProcessScenePass(PyObject *args, CPT(PostProcessScenePass) &coerced);
bool Dtool_Coerce_PostProcessScenePass(PyObject *args, PT(PostProcessScenePass) &coerced);

/**
 * Forward declarations for top-level class PostProcess
 */
typedef PostProcess PostProcess_localtype;
Define_Module_ClassRef(libpandabsp, PostProcess, PostProcess_localtype, PostProcess);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PostProcess = &Dtool_PostProcess;
static void Dtool_PyModuleClassInit_PostProcess(PyObject *module);

/**
 * Forward declarations for top-level class HDRPass
 */
typedef HDRPass HDRPass_localtype;
Define_Module_ClassRef(libpandabsp, HDRPass, HDRPass_localtype, HDRPass);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HDRPass = &Dtool_HDRPass;
static void Dtool_PyModuleClassInit_HDRPass(PyObject *module);
bool Dtool_ConstCoerce_HDRPass(PyObject *args, CPT(HDRPass) &coerced);
bool Dtool_Coerce_HDRPass(PyObject *args, PT(HDRPass) &coerced);

/**
 * Forward declarations for top-level class HDREffect
 */
typedef HDREffect HDREffect_localtype;
Define_Module_ClassRef(libpandabsp, HDREffect, HDREffect_localtype, HDREffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HDREffect = &Dtool_HDREffect;
static void Dtool_PyModuleClassInit_HDREffect(PyObject *module);
bool Dtool_ConstCoerce_HDREffect(PyObject *args, CPT(HDREffect) &coerced);
bool Dtool_Coerce_HDREffect(PyObject *args, PT(HDREffect) &coerced);

/**
 * Forward declarations for top-level class BloomEffect
 */
typedef BloomEffect BloomEffect_localtype;
Define_Module_ClassRef(libpandabsp, BloomEffect, BloomEffect_localtype, BloomEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BloomEffect = &Dtool_BloomEffect;
static void Dtool_PyModuleClassInit_BloomEffect(PyObject *module);
bool Dtool_ConstCoerce_BloomEffect(PyObject *args, CPT(BloomEffect) &coerced);
bool Dtool_Coerce_BloomEffect(PyObject *args, PT(BloomEffect) &coerced);

/**
 * Forward declarations for top-level class LightingOriginEffect
 */
typedef LightingOriginEffect LightingOriginEffect_localtype;
Define_Module_ClassRef(libpandabsp, LightingOriginEffect, LightingOriginEffect_localtype, LightingOriginEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightingOriginEffect = &Dtool_LightingOriginEffect;
static void Dtool_PyModuleClassInit_LightingOriginEffect(PyObject *module);
bool Dtool_ConstCoerce_LightingOriginEffect(PyObject *args, CPT(LightingOriginEffect) &coerced);

/**
 * Forward declarations for top-level class FXAA_Effect
 */
typedef FXAA_Effect FXAA_Effect_localtype;
Define_Module_ClassRef(libpandabsp, FXAA_Effect, FXAA_Effect_localtype, FXAA_Effect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FXAA_Effect = &Dtool_FXAA_Effect;
static void Dtool_PyModuleClassInit_FXAA_Effect(PyObject *module);
bool Dtool_ConstCoerce_FXAA_Effect(PyObject *args, CPT(FXAA_Effect) &coerced);
bool Dtool_Coerce_FXAA_Effect(PyObject *args, PT(FXAA_Effect) &coerced);

/**
 * Forward declarations for top-level class BloomAttrib
 */
typedef BloomAttrib BloomAttrib_localtype;
Define_Module_ClassRef(libpandabsp, BloomAttrib, BloomAttrib_localtype, BloomAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BloomAttrib = &Dtool_BloomAttrib;
static void Dtool_PyModuleClassInit_BloomAttrib(PyObject *module);
bool Dtool_ConstCoerce_BloomAttrib(PyObject *args, CPT(BloomAttrib) &coerced);

/**
 * Forward declarations for top-level class PhysicsCharacterController
 */
typedef PhysicsCharacterController PhysicsCharacterController_localtype;
Define_Module_ClassRef(libpandabsp, PhysicsCharacterController, PhysicsCharacterController_localtype, PhysicsCharacterController);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PhysicsCharacterController = &Dtool_PhysicsCharacterController;
static void Dtool_PyModuleClassInit_PhysicsCharacterController(PyObject *module);
bool Dtool_ConstCoerce_PhysicsCharacterController(PyObject *args, CPT(PhysicsCharacterController) &coerced);
bool Dtool_Coerce_PhysicsCharacterController(PyObject *args, PT(PhysicsCharacterController) &coerced);

/**
 * Forward declarations for top-level class Py_BSPLoader
 */
typedef Py_BSPLoader Py_BSPLoader_localtype;
Define_Module_Class(libpandabsp, Py_BSPLoader, Py_BSPLoader_localtype, Py_BSPLoader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Py_BSPLoader = &Dtool_Py_BSPLoader;
static void Dtool_PyModuleClassInit_Py_BSPLoader(PyObject *module);

/**
 * Forward declarations for top-level class Py_CL_BSPLoader
 */
typedef Py_CL_BSPLoader Py_CL_BSPLoader_localtype;
Define_Module_Class(libpandabsp, Py_CL_BSPLoader, Py_CL_BSPLoader_localtype, Py_CL_BSPLoader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Py_CL_BSPLoader = &Dtool_Py_CL_BSPLoader;
static void Dtool_PyModuleClassInit_Py_CL_BSPLoader(PyObject *module);

/**
 * Forward declarations for top-level class Py_AI_BSPLoader
 */
typedef Py_AI_BSPLoader Py_AI_BSPLoader_localtype;
Define_Module_Class(libpandabsp, Py_AI_BSPLoader, Py_AI_BSPLoader_localtype, Py_AI_BSPLoader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Py_AI_BSPLoader = &Dtool_Py_AI_BSPLoader;
static void Dtool_PyModuleClassInit_Py_AI_BSPLoader(PyObject *module);

/**
 * Forward declarations for top-level class CInterpolationContext
 */
typedef CInterpolationContext CInterpolationContext_localtype;
Define_Module_Class(libpandabsp, CInterpolationContext, CInterpolationContext_localtype, CInterpolationContext);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CInterpolationContext = &Dtool_CInterpolationContext;
static void Dtool_PyModuleClassInit_CInterpolationContext(PyObject *module);

/**
 * Forward declarations for top-level class IInterpolatedVar
 */
typedef IInterpolatedVar IInterpolatedVar_localtype;
Define_Module_Class(libpandabsp, IInterpolatedVar, IInterpolatedVar_localtype, IInterpolatedVar);
static struct Dtool_PyTypedObject *const Dtool_Ptr_IInterpolatedVar = &Dtool_IInterpolatedVar;
static void Dtool_PyModuleClassInit_IInterpolatedVar(PyObject *module);

/**
 * Forward declarations for top-level class CInterpolatedVar_LVector2f
 */
typedef CInterpolatedVar< LVector2f > CInterpolatedVar_LVector2f_localtype;
Define_Module_Class(libpandabsp, CInterpolatedVar_LVector2f, CInterpolatedVar_LVector2f_localtype, CInterpolatedVar_LVector2f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CInterpolatedVar_LVector2f = &Dtool_CInterpolatedVar_LVector2f;
static void Dtool_PyModuleClassInit_CInterpolatedVar_LVector2f(PyObject *module);
CInterpolatedVar< LVector2f > *Dtool_Coerce_CInterpolatedVar_LVector2f(PyObject *args, CInterpolatedVar< LVector2f > &coerced);

/**
 * Forward declarations for top-level class CInterpolatedVarArrayBase_LVector2f_false
 */
typedef CInterpolatedVarArrayBase< LVector2f, false > CInterpolatedVarArrayBase_LVector2f_false_localtype;
Define_Module_Class(libpandabsp, CInterpolatedVarArrayBase_LVector2f_false, CInterpolatedVarArrayBase_LVector2f_false_localtype, CInterpolatedVarArrayBase_LVector2f_false);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CInterpolatedVarArrayBase_LVector2f_false = &Dtool_CInterpolatedVarArrayBase_LVector2f_false;
static void Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector2f_false(PyObject *module);
CInterpolatedVarArrayBase< LVector2f, false > *Dtool_Coerce_CInterpolatedVarArrayBase_LVector2f_false(PyObject *args, CInterpolatedVarArrayBase< LVector2f, false > &coerced);

/**
 * Forward declarations for top-level class CInterpolatedVar_LVector3f
 */
typedef CInterpolatedVar< LVector3f > CInterpolatedVar_LVector3f_localtype;
Define_Module_Class(libpandabsp, CInterpolatedVar_LVector3f, CInterpolatedVar_LVector3f_localtype, CInterpolatedVar_LVector3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CInterpolatedVar_LVector3f = &Dtool_CInterpolatedVar_LVector3f;
static void Dtool_PyModuleClassInit_CInterpolatedVar_LVector3f(PyObject *module);
CInterpolatedVar< LVector3f > *Dtool_Coerce_CInterpolatedVar_LVector3f(PyObject *args, CInterpolatedVar< LVector3f > &coerced);

/**
 * Forward declarations for top-level class CInterpolatedVarArrayBase_LVector3f_false
 */
typedef CInterpolatedVarArrayBase< LVector3f, false > CInterpolatedVarArrayBase_LVector3f_false_localtype;
Define_Module_Class(libpandabsp, CInterpolatedVarArrayBase_LVector3f_false, CInterpolatedVarArrayBase_LVector3f_false_localtype, CInterpolatedVarArrayBase_LVector3f_false);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CInterpolatedVarArrayBase_LVector3f_false = &Dtool_CInterpolatedVarArrayBase_LVector3f_false;
static void Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector3f_false(PyObject *module);
CInterpolatedVarArrayBase< LVector3f, false > *Dtool_Coerce_CInterpolatedVarArrayBase_LVector3f_false(PyObject *args, CInterpolatedVarArrayBase< LVector3f, false > &coerced);

/**
 * Forward declarations for top-level class CInterpolatedVar_LVector4f
 */
typedef CInterpolatedVar< LVector4f > CInterpolatedVar_LVector4f_localtype;
Define_Module_Class(libpandabsp, CInterpolatedVar_LVector4f, CInterpolatedVar_LVector4f_localtype, CInterpolatedVar_LVector4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CInterpolatedVar_LVector4f = &Dtool_CInterpolatedVar_LVector4f;
static void Dtool_PyModuleClassInit_CInterpolatedVar_LVector4f(PyObject *module);
CInterpolatedVar< LVector4f > *Dtool_Coerce_CInterpolatedVar_LVector4f(PyObject *args, CInterpolatedVar< LVector4f > &coerced);

/**
 * Forward declarations for top-level class CInterpolatedVarArrayBase_LVector4f_false
 */
typedef CInterpolatedVarArrayBase< LVector4f, false > CInterpolatedVarArrayBase_LVector4f_false_localtype;
Define_Module_Class(libpandabsp, CInterpolatedVarArrayBase_LVector4f_false, CInterpolatedVarArrayBase_LVector4f_false_localtype, CInterpolatedVarArrayBase_LVector4f_false);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CInterpolatedVarArrayBase_LVector4f_false = &Dtool_CInterpolatedVarArrayBase_LVector4f_false;
static void Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector4f_false(PyObject *module);
CInterpolatedVarArrayBase< LVector4f, false > *Dtool_Coerce_CInterpolatedVarArrayBase_LVector4f_false(PyObject *args, CInterpolatedVarArrayBase< LVector4f, false > &coerced);

/**
 * Forward declarations for top-level class CInterpolatedVar_float
 */
typedef CInterpolatedVar< float > CInterpolatedVar_float_localtype;
Define_Module_Class(libpandabsp, CInterpolatedVar_float, CInterpolatedVar_float_localtype, CInterpolatedVar_float);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CInterpolatedVar_float = &Dtool_CInterpolatedVar_float;
static void Dtool_PyModuleClassInit_CInterpolatedVar_float(PyObject *module);
CInterpolatedVar< float > *Dtool_Coerce_CInterpolatedVar_float(PyObject *args, CInterpolatedVar< float > &coerced);

/**
 * Forward declarations for top-level class CInterpolatedVarArrayBase_float_false
 */
typedef CInterpolatedVarArrayBase< float, false > CInterpolatedVarArrayBase_float_false_localtype;
Define_Module_Class(libpandabsp, CInterpolatedVarArrayBase_float_false, CInterpolatedVarArrayBase_float_false_localtype, CInterpolatedVarArrayBase_float_false);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CInterpolatedVarArrayBase_float_false = &Dtool_CInterpolatedVarArrayBase_float_false;
static void Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_float_false(PyObject *module);
CInterpolatedVarArrayBase< float, false > *Dtool_Coerce_CInterpolatedVarArrayBase_float_false(PyObject *args, CInterpolatedVarArrayBase< float, false > &coerced);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"TextureStages", &Dtool_TextureStages},
  {"BSPMaterial", &Dtool_BSPMaterial},
  {"BSPMaterialAttrib", &Dtool_BSPMaterialAttrib},
  {"PackResult", &Dtool_PackResult},
  {"TextureLocation", &Dtool_TextureLocation},
  {"TexturePacker", &Dtool_TexturePacker},
  {"RayTrace", &Dtool_RayTrace},
  {"RayTraceHitResult", &Dtool_RayTraceHitResult},
  {"RayTraceScene", &Dtool_RayTraceScene},
  {"RayTraceGeometry", &Dtool_RayTraceGeometry},
  {"RayTraceTriangleMesh", &Dtool_RayTraceTriangleMesh},
  {"BSPFaceAttrib", &Dtool_BSPFaceAttrib},
  {"BSPLoader", &Dtool_BSPLoader},
  {"BoundingKDOP", &Dtool_BoundingKDOP},
  {"CBaseEntity", &Dtool_CBaseEntity},
  {"CPointEntity", &Dtool_CPointEntity},
  {"CBoundsEntity", &Dtool_CBoundsEntity},
  {"CBrushEntity", &Dtool_CBrushEntity},
  {"ShaderPermutations", &Dtool_ShaderPermutations},
  {"ShaderSpec", &Dtool_ShaderSpec},
  {"PlanarReflections", &Dtool_PlanarReflections},
  {"BSPShaderGenerator", &Dtool_BSPShaderGenerator},
  {"BSPCullTraverser", &Dtool_BSPCullTraverser},
  {"BSPRender", &Dtool_BSPRender},
  {"BSPRoot", &Dtool_BSPRoot},
  {"BSPProp", &Dtool_BSPProp},
  {"BSPModel", &Dtool_BSPModel},
  {"VertexLitGenericSpec", &Dtool_VertexLitGenericSpec},
  {"LightmappedGenericSpec", &Dtool_LightmappedGenericSpec},
  {"UnlitGenericSpec", &Dtool_UnlitGenericSpec},
  {"UnlitNoMatSpec", &Dtool_UnlitNoMatSpec},
  {"CSMRenderSpec", &Dtool_CSMRenderSpec},
  {"SkyBoxSpec", &Dtool_SkyBoxSpec},
  {"AmbientBoostEffect", &Dtool_AmbientBoostEffect},
  {"Audio3DManager", &Dtool_Audio3DManager},
  {"CIOLib", &Dtool_CIOLib},
  {"DecalModulateSpec", &Dtool_DecalModulateSpec},
  {"GlowNode", &Dtool_GlowNode},
  {"PostProcessEffect", &Dtool_PostProcessEffect},
  {"PostProcessPass", &Dtool_PostProcessPass},
  {"PostProcessScenePass", &Dtool_PostProcessScenePass},
  {"PostProcess", &Dtool_PostProcess},
  {"HDRPass", &Dtool_HDRPass},
  {"HDREffect", &Dtool_HDREffect},
  {"BloomEffect", &Dtool_BloomEffect},
  {"LightingOriginEffect", &Dtool_LightingOriginEffect},
  {"FXAA_Effect", &Dtool_FXAA_Effect},
  {"BloomAttrib", &Dtool_BloomAttrib},
  {"PhysicsCharacterController", &Dtool_PhysicsCharacterController},
  {"Py_BSPLoader", &Dtool_Py_BSPLoader},
  {"Py_CL_BSPLoader", &Dtool_Py_CL_BSPLoader},
  {"Py_AI_BSPLoader", &Dtool_Py_AI_BSPLoader},
  {"CInterpolationContext", &Dtool_CInterpolationContext},
  {"IInterpolatedVar", &Dtool_IInterpolatedVar},
  {"CInterpolatedVar< LVector2f >", &Dtool_CInterpolatedVar_LVector2f},
  {"CInterpolatedVarArrayBase< LVector2f, false >", &Dtool_CInterpolatedVarArrayBase_LVector2f_false},
  {"CInterpolatedVar< LVector3f >", &Dtool_CInterpolatedVar_LVector3f},
  {"CInterpolatedVarArrayBase< LVector3f, false >", &Dtool_CInterpolatedVarArrayBase_LVector3f_false},
  {"CInterpolatedVar< LVector4f >", &Dtool_CInterpolatedVar_LVector4f},
  {"CInterpolatedVarArrayBase< LVector4f, false >", &Dtool_CInterpolatedVarArrayBase_LVector4f_false},
  {"CInterpolatedVar< float >", &Dtool_CInterpolatedVar_float},
  {"CInterpolatedVarArrayBase< float, false >", &Dtool_CInterpolatedVarArrayBase_float_false},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[0].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[1].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[2].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[3].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[4].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[5].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[6].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[7].type)
  {"BitMask< uint32_t, 32 >", nullptr},
#define Dtool_Ptr_BitMask_uint32_t_32 (imports[8].type)
  {"RenderAttrib", nullptr},
#define Dtool_Ptr_RenderAttrib (imports[9].type)
  {"LVector3f", nullptr},
#define Dtool_Ptr_LVector3f (imports[10].type)
  {"LVector2f", nullptr},
#define Dtool_Ptr_LVector2f (imports[11].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[12].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[13].type)
  {"LVector4f", nullptr},
#define Dtool_Ptr_LVector4f (imports[14].type)
  {"LVector2i", nullptr},
#define Dtool_Ptr_LVector2i (imports[15].type)
  {"LPoint2f", nullptr},
#define Dtool_Ptr_LPoint2f (imports[16].type)
  {"FiniteBoundingVolume", nullptr},
#define Dtool_Ptr_FiniteBoundingVolume (imports[17].type)
  {"BoundingVolume", nullptr},
#define Dtool_Ptr_BoundingVolume (imports[18].type)
  {"GeometricBoundingVolume", nullptr},
#define Dtool_Ptr_GeometricBoundingVolume (imports[19].type)
  {"LPlanef", nullptr},
#define Dtool_Ptr_LPlanef (imports[20].type)
  {"Texture", nullptr},
#define Dtool_Ptr_Texture (imports[21].type)
  {"PointerToArray< float >", nullptr},
#define Dtool_Ptr_PointerToArray_float (imports[22].type)
  {"PointerToArray< UnalignedLVecBase4f >", nullptr},
#define Dtool_Ptr_PointerToArray_UnalignedLVecBase4f (imports[23].type)
  {"TextureStage", nullptr},
#define Dtool_Ptr_TextureStage (imports[24].type)
  {"ShaderInput", nullptr},
#define Dtool_Ptr_ShaderInput (imports[25].type)
  {"Shader", nullptr},
#define Dtool_Ptr_Shader (imports[26].type)
  {"Geom", nullptr},
#define Dtool_Ptr_Geom (imports[27].type)
  {"TransformState", nullptr},
#define Dtool_Ptr_TransformState (imports[28].type)
  {"RenderState", nullptr},
#define Dtool_Ptr_RenderState (imports[29].type)
  {"RenderEffect", nullptr},
#define Dtool_Ptr_RenderEffect (imports[30].type)
  {"PandaNode", nullptr},
#define Dtool_Ptr_PandaNode (imports[31].type)
  {"NodePath", nullptr},
#define Dtool_Ptr_NodePath (imports[32].type)
  {"FrameBufferProperties", nullptr},
#define Dtool_Ptr_FrameBufferProperties (imports[33].type)
  {"DrawableRegion", nullptr},
#define Dtool_Ptr_DrawableRegion (imports[34].type)
  {"GeomNode", nullptr},
#define Dtool_Ptr_GeomNode (imports[35].type)
  {"Fog", nullptr},
#define Dtool_Ptr_Fog (imports[36].type)
  {"CullTraverser", nullptr},
#define Dtool_Ptr_CullTraverser (imports[37].type)
  {"DisplayRegion", nullptr},
#define Dtool_Ptr_DisplayRegion (imports[38].type)
  {"ShaderGenerator", nullptr},
#define Dtool_Ptr_ShaderGenerator (imports[39].type)
  {"GraphicsStateGuardian", nullptr},
#define Dtool_Ptr_GraphicsStateGuardian (imports[40].type)
  {"GraphicsOutput", nullptr},
#define Dtool_Ptr_GraphicsOutput (imports[41].type)
  {"GraphicsWindow", nullptr},
#define Dtool_Ptr_GraphicsWindow (imports[42].type)
  {"BulletRigidBodyNode", nullptr},
#define Dtool_Ptr_BulletRigidBodyNode (imports[43].type)
  {"BulletWorld", nullptr},
#define Dtool_Ptr_BulletWorld (imports[44].type)
  {"ModelNode", nullptr},
#define Dtool_Ptr_ModelNode (imports[45].type)
  {"ModelRoot", nullptr},
#define Dtool_Ptr_ModelRoot (imports[46].type)
  {"AudioSound", nullptr},
#define Dtool_Ptr_AudioSound (imports[47].type)
  {"AudioManager", nullptr},
#define Dtool_Ptr_AudioManager (imports[48].type)
  {nullptr, nullptr},
};
#endif

// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// BitMask< uint32_t, 32 >
#ifndef LINK_ALL_STATIC
inline static BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced) {
  nassertr(Dtool_Ptr_BitMask_uint32_t_32 != nullptr, nullptr);
  nassertr(Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce != nullptr, nullptr);
  return ((BitMask< uint32_t, 32 > *(*)(PyObject *, BitMask< uint32_t, 32 > &))Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitMask_uint32_t_32;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint32_t_32 = &Dtool_BitMask_uint32_t_32;
extern BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced);
#endif
// RenderAttrib
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_RenderAttrib;
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderAttrib = &Dtool_RenderAttrib;
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LVector2f
#ifndef LINK_ALL_STATIC
inline static LVector2f *Dtool_Coerce_LVector2f(PyObject *args, LVector2f &coerced) {
  nassertr(Dtool_Ptr_LVector2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector2f *(*)(PyObject *, LVector2f &))Dtool_Ptr_LVector2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector2f = &Dtool_LVector2f;
extern LVector2f *Dtool_Coerce_LVector2f(PyObject *args, LVector2f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LVector4f
#ifndef LINK_ALL_STATIC
inline static LVector4f *Dtool_Coerce_LVector4f(PyObject *args, LVector4f &coerced) {
  nassertr(Dtool_Ptr_LVector4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector4f *(*)(PyObject *, LVector4f &))Dtool_Ptr_LVector4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector4f = &Dtool_LVector4f;
extern LVector4f *Dtool_Coerce_LVector4f(PyObject *args, LVector4f &coerced);
#endif
// LVector2i
#ifndef LINK_ALL_STATIC
inline static LVector2i *Dtool_Coerce_LVector2i(PyObject *args, LVector2i &coerced) {
  nassertr(Dtool_Ptr_LVector2i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector2i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector2i *(*)(PyObject *, LVector2i &))Dtool_Ptr_LVector2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector2i = &Dtool_LVector2i;
extern LVector2i *Dtool_Coerce_LVector2i(PyObject *args, LVector2i &coerced);
#endif
// LPoint2f
#ifndef LINK_ALL_STATIC
inline static LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced) {
  nassertr(Dtool_Ptr_LPoint2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint2f *(*)(PyObject *, LPoint2f &))Dtool_Ptr_LPoint2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2f = &Dtool_LPoint2f;
extern LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced);
#endif
// FiniteBoundingVolume
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_FiniteBoundingVolume;
static struct Dtool_PyTypedObject *const Dtool_Ptr_FiniteBoundingVolume = &Dtool_FiniteBoundingVolume;
#endif
// BoundingVolume
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_BoundingVolume;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingVolume = &Dtool_BoundingVolume;
#endif
// GeometricBoundingVolume
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GeometricBoundingVolume;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeometricBoundingVolume = &Dtool_GeometricBoundingVolume;
#endif
// LPlanef
#ifndef LINK_ALL_STATIC
inline static LPlanef *Dtool_Coerce_LPlanef(PyObject *args, LPlanef &coerced) {
  nassertr(Dtool_Ptr_LPlanef != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPlanef->_Dtool_Coerce != nullptr, nullptr);
  return ((LPlanef *(*)(PyObject *, LPlanef &))Dtool_Ptr_LPlanef->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPlanef;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPlanef = &Dtool_LPlanef;
extern LPlanef *Dtool_Coerce_LPlanef(PyObject *args, LPlanef &coerced);
#endif
// Texture
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// PointerToArray< float >
#ifndef LINK_ALL_STATIC
inline static PointerToArray< float > *Dtool_Coerce_PointerToArray_float(PyObject *args, PointerToArray< float > &coerced) {
  nassertr(Dtool_Ptr_PointerToArray_float != nullptr, nullptr);
  nassertr(Dtool_Ptr_PointerToArray_float->_Dtool_Coerce != nullptr, nullptr);
  return ((PointerToArray< float > *(*)(PyObject *, PointerToArray< float > &))Dtool_Ptr_PointerToArray_float->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PointerToArray_float;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_float = &Dtool_PointerToArray_float;
extern PointerToArray< float > *Dtool_Coerce_PointerToArray_float(PyObject *args, PointerToArray< float > &coerced);
#endif
// PointerToArray< UnalignedLVecBase4f >
#ifndef LINK_ALL_STATIC
inline static PointerToArray< UnalignedLVecBase4f > *Dtool_Coerce_PointerToArray_UnalignedLVecBase4f(PyObject *args, PointerToArray< UnalignedLVecBase4f > &coerced) {
  nassertr(Dtool_Ptr_PointerToArray_UnalignedLVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_PointerToArray_UnalignedLVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((PointerToArray< UnalignedLVecBase4f > *(*)(PyObject *, PointerToArray< UnalignedLVecBase4f > &))Dtool_Ptr_PointerToArray_UnalignedLVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PointerToArray_UnalignedLVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_UnalignedLVecBase4f = &Dtool_PointerToArray_UnalignedLVecBase4f;
extern PointerToArray< UnalignedLVecBase4f > *Dtool_Coerce_PointerToArray_UnalignedLVecBase4f(PyObject *args, PointerToArray< UnalignedLVecBase4f > &coerced);
#endif
// TextureStage
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TextureStage;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureStage = &Dtool_TextureStage;
#endif
// ShaderInput
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ShaderInput;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderInput = &Dtool_ShaderInput;
#endif
// Shader
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_Shader(PyObject *args, CPT(Shader) &coerced) {
  nassertr(Dtool_Ptr_Shader != nullptr, false);
  nassertr(Dtool_Ptr_Shader->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(Shader) &))Dtool_Ptr_Shader->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_Shader(PyObject *args, PT(Shader) &coerced) {
  nassertr(Dtool_Ptr_Shader != nullptr, false);
  nassertr(Dtool_Ptr_Shader->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(Shader) &))Dtool_Ptr_Shader->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Shader;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Shader = &Dtool_Shader;
extern bool Dtool_ConstCoerce_Shader(PyObject *args, CPT(Shader) &coerced);
extern bool Dtool_Coerce_Shader(PyObject *args, PT(Shader) &coerced);
#endif
// Geom
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Geom;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Geom = &Dtool_Geom;
#endif
// TransformState
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TransformState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TransformState = &Dtool_TransformState;
#endif
// RenderState
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_RenderState(PyObject *args, CPT(RenderState) &coerced) {
  nassertr(Dtool_Ptr_RenderState != nullptr, false);
  nassertr(Dtool_Ptr_RenderState->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(RenderState) &))Dtool_Ptr_RenderState->_Dtool_ConstCoerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_RenderState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderState = &Dtool_RenderState;
extern bool Dtool_ConstCoerce_RenderState(PyObject *args, CPT(RenderState) &coerced);
#endif
// RenderEffect
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_RenderEffect;
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderEffect = &Dtool_RenderEffect;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// FrameBufferProperties
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_FrameBufferProperties;
static struct Dtool_PyTypedObject *const Dtool_Ptr_FrameBufferProperties = &Dtool_FrameBufferProperties;
#endif
// DrawableRegion
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DrawableRegion;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DrawableRegion = &Dtool_DrawableRegion;
#endif
// GeomNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GeomNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomNode = &Dtool_GeomNode;
#endif
// Fog
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Fog;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Fog = &Dtool_Fog;
#endif
// CullTraverser
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CullTraverser;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullTraverser = &Dtool_CullTraverser;
#endif
// DisplayRegion
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DisplayRegion;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DisplayRegion = &Dtool_DisplayRegion;
#endif
// ShaderGenerator
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_ShaderGenerator(PyObject *args, CPT(ShaderGenerator) &coerced) {
  nassertr(Dtool_Ptr_ShaderGenerator != nullptr, false);
  nassertr(Dtool_Ptr_ShaderGenerator->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(ShaderGenerator) &))Dtool_Ptr_ShaderGenerator->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_ShaderGenerator(PyObject *args, PT(ShaderGenerator) &coerced) {
  nassertr(Dtool_Ptr_ShaderGenerator != nullptr, false);
  nassertr(Dtool_Ptr_ShaderGenerator->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(ShaderGenerator) &))Dtool_Ptr_ShaderGenerator->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ShaderGenerator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderGenerator = &Dtool_ShaderGenerator;
extern bool Dtool_ConstCoerce_ShaderGenerator(PyObject *args, CPT(ShaderGenerator) &coerced);
extern bool Dtool_Coerce_ShaderGenerator(PyObject *args, PT(ShaderGenerator) &coerced);
#endif
// GraphicsStateGuardian
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsStateGuardian;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsStateGuardian = &Dtool_GraphicsStateGuardian;
#endif
// GraphicsOutput
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsOutput;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsOutput = &Dtool_GraphicsOutput;
#endif
// GraphicsWindow
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsWindow;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsWindow = &Dtool_GraphicsWindow;
#endif
// BulletRigidBodyNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_BulletRigidBodyNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BulletRigidBodyNode = &Dtool_BulletRigidBodyNode;
#endif
// BulletWorld
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_BulletWorld;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BulletWorld = &Dtool_BulletWorld;
#endif
// ModelNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ModelNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModelNode = &Dtool_ModelNode;
#endif
// ModelRoot
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ModelRoot;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModelRoot = &Dtool_ModelRoot;
#endif
// AudioSound
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AudioSound;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AudioSound = &Dtool_AudioSound;
#endif
// AudioManager
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AudioManager;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AudioManager = &Dtool_AudioManager;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class TextureStages
 */
/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get(std::string const &name)
 * static TextureStage *TextureStages::get(std::string const &name, std::string const &uv_name)
 */
static PyObject *Dtool_TextureStages_get_2(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
        // 1-static TextureStage *TextureStages::get(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
        param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
          param0_str = nullptr;
        }
#endif
        if (param0_str != nullptr) {
          TextureStage *return_value = (TextureStages::get)(std::string(param0_str, param0_len));
          if (return_value != nullptr) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != nullptr) {
              unref_delete(return_value);
            }
            return nullptr;
          }
          if (return_value == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 2:
    {
      // 1-static TextureStage *TextureStages::get(std::string const &name, std::string const &uv_name)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"name", "uv_name", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:get", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
        TextureStage *return_value = (TextureStages::get)(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != nullptr) {
            unref_delete(return_value);
          }
          return nullptr;
        }
        if (return_value == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get(str name)\n"
      "get(str name, str uv_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_2_comment =
  "C++ Interface:\n"
  "get(str name)\n"
  "get(str name, str uv_name)\n";
#else
static const char *Dtool_TextureStages_get_2_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_basetexture(void)
 */
static PyObject *Dtool_TextureStages_get_basetexture_3(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_basetexture(void)
  TextureStage *return_value = (TextureStages::get_basetexture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_basetexture_3_comment =
  "C++ Interface:\n"
  "get_basetexture()\n";
#else
static const char *Dtool_TextureStages_get_basetexture_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_lightmap(void)
 */
static PyObject *Dtool_TextureStages_get_lightmap_4(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_lightmap(void)
  TextureStage *return_value = (TextureStages::get_lightmap)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_lightmap_4_comment =
  "C++ Interface:\n"
  "get_lightmap()\n";
#else
static const char *Dtool_TextureStages_get_lightmap_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_bumped_lightmap(void)
 */
static PyObject *Dtool_TextureStages_get_bumped_lightmap_5(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_bumped_lightmap(void)
  TextureStage *return_value = (TextureStages::get_bumped_lightmap)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_bumped_lightmap_5_comment =
  "C++ Interface:\n"
  "get_bumped_lightmap()\n";
#else
static const char *Dtool_TextureStages_get_bumped_lightmap_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_spheremap(void)
 */
static PyObject *Dtool_TextureStages_get_spheremap_6(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_spheremap(void)
  TextureStage *return_value = (TextureStages::get_spheremap)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_spheremap_6_comment =
  "C++ Interface:\n"
  "get_spheremap()\n";
#else
static const char *Dtool_TextureStages_get_spheremap_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_cubemap(void)
 */
static PyObject *Dtool_TextureStages_get_cubemap_7(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_cubemap(void)
  TextureStage *return_value = (TextureStages::get_cubemap)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_cubemap_7_comment =
  "C++ Interface:\n"
  "get_cubemap()\n";
#else
static const char *Dtool_TextureStages_get_cubemap_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_normalmap(void)
 */
static PyObject *Dtool_TextureStages_get_normalmap_8(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_normalmap(void)
  TextureStage *return_value = (TextureStages::get_normalmap)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_normalmap_8_comment =
  "C++ Interface:\n"
  "get_normalmap()\n";
#else
static const char *Dtool_TextureStages_get_normalmap_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_heightmap(void)
 */
static PyObject *Dtool_TextureStages_get_heightmap_9(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_heightmap(void)
  TextureStage *return_value = (TextureStages::get_heightmap)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_heightmap_9_comment =
  "C++ Interface:\n"
  "get_heightmap()\n";
#else
static const char *Dtool_TextureStages_get_heightmap_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_glossmap(void)
 */
static PyObject *Dtool_TextureStages_get_glossmap_10(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_glossmap(void)
  TextureStage *return_value = (TextureStages::get_glossmap)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_glossmap_10_comment =
  "C++ Interface:\n"
  "get_glossmap()\n";
#else
static const char *Dtool_TextureStages_get_glossmap_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_glowmap(void)
 */
static PyObject *Dtool_TextureStages_get_glowmap_11(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_glowmap(void)
  TextureStage *return_value = (TextureStages::get_glowmap)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_glowmap_11_comment =
  "C++ Interface:\n"
  "get_glowmap()\n";
#else
static const char *Dtool_TextureStages_get_glowmap_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStages::TextureStages(void) = default
 * inline TextureStages::TextureStages(TextureStages const &) = default
 */
static int Dtool_Init_TextureStages(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("TextureStages() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline TextureStages::TextureStages(void) = default
      TextureStages *return_value = new TextureStages();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureStages, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline TextureStages::TextureStages(TextureStages const &) = default
      TextureStages const *arg_this = (TextureStages *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStages, 0, "TextureStages.TextureStages", true, true);
      if (arg_this != nullptr) {
        TextureStages *return_value = new TextureStages(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureStages, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TextureStages() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextureStages()\n"
      "TextureStages(const TextureStages param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TextureStages(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextureStages) {
    printf("TextureStages ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextureStages *local_this = (TextureStages *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextureStages) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextureStages(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextureStages) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPMaterial
 */
/**
 * Python function wrapper for:
 * inline void BSPMaterial::operator =(BSPMaterial const &copy)
 */
static PyObject *Dtool_BSPMaterial_operator_17(PyObject *self, PyObject *arg) {
  BSPMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPMaterial, (void **)&local_this, "BSPMaterial.assign")) {
    return nullptr;
  }
  // 1-inline void BSPMaterial::operator =(BSPMaterial const &copy)
  BSPMaterial const *arg_this = (BSPMaterial *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BSPMaterial, 1, "BSPMaterial.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    BSPMaterial *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BSPMaterial, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const BSPMaterial self, const BSPMaterial copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_operator_17_comment =
  "C++ Interface:\n"
  "assign(const BSPMaterial self, const BSPMaterial copy)\n";
#else
static const char *Dtool_BSPMaterial_operator_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BSPMaterial::set_keyvalue(std::string const &key, std::string const &value)
 */
static PyObject *Dtool_BSPMaterial_set_keyvalue_18(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPMaterial, (void **)&local_this, "BSPMaterial.set_keyvalue")) {
    return nullptr;
  }
  // 1-inline void BSPMaterial::set_keyvalue(std::string const &key, std::string const &value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"key", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:set_keyvalue", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    ((*local_this).set_keyvalue)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_keyvalue(const BSPMaterial self, str key, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_set_keyvalue_18_comment =
  "C++ Interface:\n"
  "set_keyvalue(const BSPMaterial self, str key, str value)\n";
#else
static const char *Dtool_BSPMaterial_set_keyvalue_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string BSPMaterial::get_keyvalue(std::string const &key) const
 */
static PyObject *Dtool_BSPMaterial_get_keyvalue_19(PyObject *self, PyObject *arg) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline std::string BSPMaterial::get_keyvalue(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    std::string return_value = ((*(const BSPMaterial*)local_this).get_keyvalue)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_keyvalue(BSPMaterial self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_keyvalue_19_comment =
  "C++ Interface:\n"
  "get_keyvalue(BSPMaterial self, str key)\n";
#else
static const char *Dtool_BSPMaterial_get_keyvalue_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t BSPMaterial::get_num_keyvalues(void) const
 */
static PyObject *Dtool_BSPMaterial_get_num_keyvalues_20(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline std::size_t BSPMaterial::get_num_keyvalues(void) const
  std::size_t return_value = ((*(const BSPMaterial*)local_this).get_num_keyvalues)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_num_keyvalues_20_comment =
  "C++ Interface:\n"
  "get_num_keyvalues(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_get_num_keyvalues_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &BSPMaterial::get_key(std::size_t i) const
 */
static PyObject *Dtool_BSPMaterial_get_key_21(PyObject *self, PyObject *arg) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline std::string const &BSPMaterial::get_key(std::size_t i) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string const &return_value = ((*(const BSPMaterial*)local_this).get_key)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_key(BSPMaterial self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_key_21_comment =
  "C++ Interface:\n"
  "get_key(BSPMaterial self, int i)\n";
#else
static const char *Dtool_BSPMaterial_get_key_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &BSPMaterial::get_value(std::size_t i) const
 */
static PyObject *Dtool_BSPMaterial_get_value_22(PyObject *self, PyObject *arg) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline std::string const &BSPMaterial::get_value(std::size_t i) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string const &return_value = ((*(const BSPMaterial*)local_this).get_value)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_value(BSPMaterial self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_value_22_comment =
  "C++ Interface:\n"
  "get_value(BSPMaterial self, int i)\n";
#else
static const char *Dtool_BSPMaterial_get_value_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BSPMaterial::get_keyvalue_int(std::string const &key) const
 */
static PyObject *Dtool_BSPMaterial_get_keyvalue_int_23(PyObject *self, PyObject *arg) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline int BSPMaterial::get_keyvalue_int(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    int return_value = ((*(const BSPMaterial*)local_this).get_keyvalue_int)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_keyvalue_int(BSPMaterial self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_keyvalue_int_23_comment =
  "C++ Interface:\n"
  "get_keyvalue_int(BSPMaterial self, str key)\n";
#else
static const char *Dtool_BSPMaterial_get_keyvalue_int_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float BSPMaterial::get_keyvalue_float(std::string const &key) const
 */
static PyObject *Dtool_BSPMaterial_get_keyvalue_float_24(PyObject *self, PyObject *arg) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline float BSPMaterial::get_keyvalue_float(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    float return_value = ((*(const BSPMaterial*)local_this).get_keyvalue_float)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_keyvalue_float(BSPMaterial self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_keyvalue_float_24_comment =
  "C++ Interface:\n"
  "get_keyvalue_float(BSPMaterial self, str key)\n";
#else
static const char *Dtool_BSPMaterial_get_keyvalue_float_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BSPMaterial::set_shader(std::string const &shader_name)
 */
static PyObject *Dtool_BSPMaterial_set_shader_25(PyObject *self, PyObject *arg) {
  BSPMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPMaterial, (void **)&local_this, "BSPMaterial.set_shader")) {
    return nullptr;
  }
  // 1-inline void BSPMaterial::set_shader(std::string const &shader_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_shader)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shader(const BSPMaterial self, str shader_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_set_shader_25_comment =
  "C++ Interface:\n"
  "set_shader(const BSPMaterial self, str shader_name)\n";
#else
static const char *Dtool_BSPMaterial_set_shader_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string BSPMaterial::get_shader(void) const
 */
static PyObject *Dtool_BSPMaterial_get_shader_26(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline std::string BSPMaterial::get_shader(void) const
  std::string return_value = ((*(const BSPMaterial*)local_this).get_shader)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_shader_26_comment =
  "C++ Interface:\n"
  "get_shader(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_get_shader_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename BSPMaterial::get_file(void) const
 */
static PyObject *Dtool_BSPMaterial_get_file_27(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline Filename BSPMaterial::get_file(void) const
  Filename *return_value = new Filename(((*(const BSPMaterial*)local_this).get_file)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_file_27_comment =
  "C++ Interface:\n"
  "get_file(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_get_file_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPMaterial::has_keyvalue(std::string const &key) const
 */
static PyObject *Dtool_BSPMaterial_has_keyvalue_28(PyObject *self, PyObject *arg) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline bool BSPMaterial::has_keyvalue(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const BSPMaterial*)local_this).has_keyvalue)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_keyvalue(BSPMaterial self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_has_keyvalue_28_comment =
  "C++ Interface:\n"
  "has_keyvalue(BSPMaterial self, str key)\n";
#else
static const char *Dtool_BSPMaterial_has_keyvalue_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPMaterial::has_env_cubemap(void) const
 */
static PyObject *Dtool_BSPMaterial_has_env_cubemap_29(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline bool BSPMaterial::has_env_cubemap(void) const
  bool return_value = ((*(const BSPMaterial*)local_this).has_env_cubemap)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_has_env_cubemap_29_comment =
  "C++ Interface:\n"
  "has_env_cubemap(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_has_env_cubemap_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPMaterial::has_transparency(void) const
 */
static PyObject *Dtool_BSPMaterial_has_transparency_30(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline bool BSPMaterial::has_transparency(void) const
  bool return_value = ((*(const BSPMaterial*)local_this).has_transparency)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_has_transparency_30_comment =
  "C++ Interface:\n"
  "has_transparency(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_has_transparency_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string BSPMaterial::get_surface_prop(void) const
 */
static PyObject *Dtool_BSPMaterial_get_surface_prop_31(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline std::string BSPMaterial::get_surface_prop(void) const
  std::string return_value = ((*(const BSPMaterial*)local_this).get_surface_prop)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_surface_prop_31_comment =
  "C++ Interface:\n"
  "get_surface_prop(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_get_surface_prop_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string BSPMaterial::get_contents(void) const
 */
static PyObject *Dtool_BSPMaterial_get_contents_32(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline std::string BSPMaterial::get_contents(void) const
  std::string return_value = ((*(const BSPMaterial*)local_this).get_contents)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_contents_32_comment =
  "C++ Interface:\n"
  "get_contents(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_get_contents_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPMaterial::is_lightmapped(void) const
 */
static PyObject *Dtool_BSPMaterial_is_lightmapped_33(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline bool BSPMaterial::is_lightmapped(void) const
  bool return_value = ((*(const BSPMaterial*)local_this).is_lightmapped)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_is_lightmapped_33_comment =
  "C++ Interface:\n"
  "is_lightmapped(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_is_lightmapped_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPMaterial::is_skybox(void) const
 */
static PyObject *Dtool_BSPMaterial_is_skybox_34(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline bool BSPMaterial::is_skybox(void) const
  bool return_value = ((*(const BSPMaterial*)local_this).is_skybox)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_is_skybox_34_comment =
  "C++ Interface:\n"
  "is_skybox(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_is_skybox_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPMaterial::has_bumpmap(void) const
 */
static PyObject *Dtool_BSPMaterial_has_bumpmap_35(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline bool BSPMaterial::has_bumpmap(void) const
  bool return_value = ((*(const BSPMaterial*)local_this).has_bumpmap)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_has_bumpmap_35_comment =
  "C++ Interface:\n"
  "has_bumpmap(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_has_bumpmap_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static BSPMaterial const *BSPMaterial::get_from_file(Filename const &file)
 */
static PyObject *Dtool_BSPMaterial_get_from_file_36(PyObject *, PyObject *arg) {
  // 1-static BSPMaterial const *BSPMaterial::get_from_file(Filename const &file)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "BSPMaterial.get_from_file", "Filename");
  }
  BSPMaterial const *return_value = (BSPMaterial::get_from_file)(*arg_this);
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BSPMaterial, true, true, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_from_file(const Filename file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_from_file_36_comment =
  "C++ Interface:\n"
  "get_from_file(const Filename file)\n";
#else
static const char *Dtool_BSPMaterial_get_from_file_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BSPMaterial::get_class_type(void)
 */
static PyObject *Dtool_BSPMaterial_get_class_type_37(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPMaterial::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BSPMaterial::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_class_type_37_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPMaterial_get_class_type_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPMaterial::BSPMaterial(BSPMaterial const &copy)
 * inline explicit BSPMaterial::BSPMaterial(std::string const &name = "UnlitNoMat")
 */
static int Dtool_Init_BSPMaterial(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit BSPMaterial::BSPMaterial(std::string const &name)
      BSPMaterial *return_value = new BSPMaterial();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPMaterial, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline BSPMaterial::BSPMaterial(BSPMaterial const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          BSPMaterial const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BSPMaterial);
          if (param0_this != nullptr) {
            BSPMaterial *return_value = new BSPMaterial(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPMaterial, true, false);
          }
        }
      }

      {
        // -2 inline explicit BSPMaterial::BSPMaterial(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:BSPMaterial", (char **)keyword_list, &param0_str, &param0_len)) {
          BSPMaterial *return_value = new BSPMaterial(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPMaterial, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline BSPMaterial::BSPMaterial(BSPMaterial const &copy)
      // No coercion possible: inline explicit BSPMaterial::BSPMaterial(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BSPMaterial() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPMaterial()\n"
      "BSPMaterial(const BSPMaterial copy)\n"
      "BSPMaterial(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BSPMaterial(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPMaterial) {
    printf("BSPMaterial ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPMaterial *local_this = (BSPMaterial *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPMaterial) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPMaterial(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPMaterial) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BSPMaterial*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPMaterialAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > BSPMaterialAttrib::make(BSPMaterial const *mat)
 */
static PyObject *Dtool_BSPMaterialAttrib_make_41(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > BSPMaterialAttrib::make(BSPMaterial const *mat)
  BSPMaterial const *arg_this = (BSPMaterial *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BSPMaterial, 0, "BSPMaterialAttrib.make", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = (BSPMaterialAttrib::make)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(const BSPMaterial mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterialAttrib_make_41_comment =
  "C++ Interface:\n"
  "make(const BSPMaterial mat)\n";
#else
static const char *Dtool_BSPMaterialAttrib_make_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > BSPMaterialAttrib::make_override_shader(BSPMaterial const *mat)
 */
static PyObject *Dtool_BSPMaterialAttrib_make_override_shader_42(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > BSPMaterialAttrib::make_override_shader(BSPMaterial const *mat)
  BSPMaterial const *arg_this = (BSPMaterial *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BSPMaterial, 0, "BSPMaterialAttrib.make_override_shader", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = (BSPMaterialAttrib::make_override_shader)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_override_shader(const BSPMaterial mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterialAttrib_make_override_shader_42_comment =
  "C++ Interface:\n"
  "make_override_shader(const BSPMaterial mat)\n";
#else
static const char *Dtool_BSPMaterialAttrib_make_override_shader_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > BSPMaterialAttrib::make_default(void)
 */
static PyObject *Dtool_BSPMaterialAttrib_make_default_43(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > BSPMaterialAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (BSPMaterialAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterialAttrib_make_default_43_comment =
  "C++ Interface:\n"
  "make_default()\n";
#else
static const char *Dtool_BSPMaterialAttrib_make_default_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string BSPMaterialAttrib::get_override_shader(void) const
 */
static PyObject *Dtool_BSPMaterialAttrib_get_override_shader_44(PyObject *self, PyObject *) {
  BSPMaterialAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterialAttrib)) {
    return nullptr;
  }
  // 1-inline std::string BSPMaterialAttrib::get_override_shader(void) const
  std::string return_value = ((*(const BSPMaterialAttrib*)local_this).get_override_shader)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterialAttrib_get_override_shader_44_comment =
  "C++ Interface:\n"
  "get_override_shader(BSPMaterialAttrib self)\n";
#else
static const char *Dtool_BSPMaterialAttrib_get_override_shader_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPMaterialAttrib::has_override_shader(void) const
 */
static PyObject *Dtool_BSPMaterialAttrib_has_override_shader_45(PyObject *self, PyObject *) {
  BSPMaterialAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterialAttrib)) {
    return nullptr;
  }
  // 1-inline bool BSPMaterialAttrib::has_override_shader(void) const
  bool return_value = ((*(const BSPMaterialAttrib*)local_this).has_override_shader)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterialAttrib_has_override_shader_45_comment =
  "C++ Interface:\n"
  "has_override_shader(BSPMaterialAttrib self)\n";
#else
static const char *Dtool_BSPMaterialAttrib_has_override_shader_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPMaterial const *BSPMaterialAttrib::get_material(void) const
 */
static PyObject *Dtool_BSPMaterialAttrib_get_material_46(PyObject *self, PyObject *) {
  BSPMaterialAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterialAttrib)) {
    return nullptr;
  }
  // 1-inline BSPMaterial const *BSPMaterialAttrib::get_material(void) const
  BSPMaterial const *return_value = ((*(const BSPMaterialAttrib*)local_this).get_material)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BSPMaterial, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterialAttrib_get_material_46_comment =
  "C++ Interface:\n"
  "get_material(BSPMaterialAttrib self)\n";
#else
static const char *Dtool_BSPMaterialAttrib_get_material_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int BSPMaterialAttrib::get_class_slot(void)
 */
static PyObject *Dtool_BSPMaterialAttrib_get_class_slot_47(PyObject *, PyObject *) {
  // 1-static int BSPMaterialAttrib::get_class_slot(void)
  int return_value = (BSPMaterialAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterialAttrib_get_class_slot_47_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_BSPMaterialAttrib_get_class_slot_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BSPMaterialAttrib::get_class_type(void)
 */
static PyObject *Dtool_BSPMaterialAttrib_get_class_type_50(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPMaterialAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BSPMaterialAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterialAttrib_get_class_type_50_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPMaterialAttrib_get_class_type_50_comment = nullptr;
#endif

static PyObject *Dtool_BSPMaterialAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int BSPMaterialAttrib::get_class_slot(void)
  int return_value = (BSPMaterialAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_BSPMaterialAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_BSPMaterialAttrib(PyObject *args, CPT(BSPMaterialAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPMaterialAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > BSPMaterialAttrib::make(BSPMaterial const *mat)
    BSPMaterial const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_BSPMaterial);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = (BSPMaterialAttrib::make)(arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((BSPMaterialAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_BSPMaterialAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPMaterialAttrib) {
    printf("BSPMaterialAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPMaterialAttrib *local_this = (BSPMaterialAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPMaterialAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPMaterialAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPMaterialAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPMaterialAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (BSPMaterialAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPMaterialAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BSPMaterialAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BSPMaterialAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PackResult
 */
/**
 * Python function wrapper for:
 * inline int PackResult::get_width(void) const
 */
static PyObject *Dtool_PackResult_get_width_53(PyObject *self, PyObject *) {
  PackResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PackResult)) {
    return nullptr;
  }
  // 1-inline int PackResult::get_width(void) const
  int return_value = ((*(const PackResult*)local_this).get_width)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PackResult_get_width_53_comment =
  "C++ Interface:\n"
  "get_width(PackResult self)\n";
#else
static const char *Dtool_PackResult_get_width_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PackResult::get_height(void) const
 */
static PyObject *Dtool_PackResult_get_height_54(PyObject *self, PyObject *) {
  PackResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PackResult)) {
    return nullptr;
  }
  // 1-inline int PackResult::get_height(void) const
  int return_value = ((*(const PackResult*)local_this).get_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PackResult_get_height_54_comment =
  "C++ Interface:\n"
  "get_height(PackResult self)\n";
#else
static const char *Dtool_PackResult_get_height_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PackResult::get_unused_area(void) const
 */
static PyObject *Dtool_PackResult_get_unused_area_55(PyObject *self, PyObject *) {
  PackResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PackResult)) {
    return nullptr;
  }
  // 1-inline int PackResult::get_unused_area(void) const
  int return_value = ((*(const PackResult*)local_this).get_unused_area)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PackResult_get_unused_area_55_comment =
  "C++ Interface:\n"
  "get_unused_area(PackResult self)\n";
#else
static const char *Dtool_PackResult_get_unused_area_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PackResult::PackResult(PackResult const &) = default
 */
static int Dtool_Init_PackResult(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("PackResult() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline PackResult::PackResult(PackResult const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    PackResult const *param0_this = (PackResult *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PackResult, 0, "PackResult.PackResult", true, true);
    if (param0_this != nullptr) {
      PackResult *return_value = new PackResult(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PackResult, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PackResult(const PackResult param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PackResult(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PackResult) {
    printf("PackResult ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PackResult *local_this = (PackResult *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PackResult) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PackResult(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PackResult) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextureLocation
 */
/**
 * Python function wrapper for:
 * inline int TextureLocation::get_x(void) const
 */
static PyObject *Dtool_TextureLocation_get_x_59(PyObject *self, PyObject *) {
  TextureLocation *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureLocation)) {
    return nullptr;
  }
  // 1-inline int TextureLocation::get_x(void) const
  int return_value = ((*(const TextureLocation*)local_this).get_x)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureLocation_get_x_59_comment =
  "C++ Interface:\n"
  "get_x(TextureLocation self)\n";
#else
static const char *Dtool_TextureLocation_get_x_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureLocation::get_y(void) const
 */
static PyObject *Dtool_TextureLocation_get_y_60(PyObject *self, PyObject *) {
  TextureLocation *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureLocation)) {
    return nullptr;
  }
  // 1-inline int TextureLocation::get_y(void) const
  int return_value = ((*(const TextureLocation*)local_this).get_y)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureLocation_get_y_60_comment =
  "C++ Interface:\n"
  "get_y(TextureLocation self)\n";
#else
static const char *Dtool_TextureLocation_get_y_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureLocation::get_width(void) const
 */
static PyObject *Dtool_TextureLocation_get_width_61(PyObject *self, PyObject *) {
  TextureLocation *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureLocation)) {
    return nullptr;
  }
  // 1-inline int TextureLocation::get_width(void) const
  int return_value = ((*(const TextureLocation*)local_this).get_width)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureLocation_get_width_61_comment =
  "C++ Interface:\n"
  "get_width(TextureLocation self)\n";
#else
static const char *Dtool_TextureLocation_get_width_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureLocation::get_height(void) const
 */
static PyObject *Dtool_TextureLocation_get_height_62(PyObject *self, PyObject *) {
  TextureLocation *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureLocation)) {
    return nullptr;
  }
  // 1-inline int TextureLocation::get_height(void) const
  int return_value = ((*(const TextureLocation*)local_this).get_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureLocation_get_height_62_comment =
  "C++ Interface:\n"
  "get_height(TextureLocation self)\n";
#else
static const char *Dtool_TextureLocation_get_height_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureLocation::get_rotated(void) const
 */
static PyObject *Dtool_TextureLocation_get_rotated_63(PyObject *self, PyObject *) {
  TextureLocation *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureLocation)) {
    return nullptr;
  }
  // 1-inline bool TextureLocation::get_rotated(void) const
  bool return_value = ((*(const TextureLocation*)local_this).get_rotated)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureLocation_get_rotated_63_comment =
  "C++ Interface:\n"
  "get_rotated(TextureLocation self)\n";
#else
static const char *Dtool_TextureLocation_get_rotated_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureLocation::TextureLocation(TextureLocation const &) = default
 */
static int Dtool_Init_TextureLocation(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("TextureLocation() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline TextureLocation::TextureLocation(TextureLocation const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    TextureLocation const *param0_this = (TextureLocation *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_TextureLocation, 0, "TextureLocation.TextureLocation", true, true);
    if (param0_this != nullptr) {
      TextureLocation *return_value = new TextureLocation(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureLocation, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextureLocation(const TextureLocation param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TextureLocation(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextureLocation) {
    printf("TextureLocation ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextureLocation *local_this = (TextureLocation *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextureLocation) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextureLocation(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextureLocation) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TexturePacker
 */
/**
 * Python function wrapper for:
 * virtual int TexturePacker::getTextureCount(void) = 0
 */
static PyObject *Dtool_TexturePacker_getTextureCount_67(PyObject *self, PyObject *) {
  TexturePacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TexturePacker, (void **)&local_this, "TexturePacker.getTextureCount")) {
    return nullptr;
  }
  // 1-virtual int TexturePacker::getTextureCount(void) = 0
  int return_value = ((*local_this).getTextureCount)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_getTextureCount_67_comment =
  "C++ Interface:\n"
  "getTextureCount(const TexturePacker self)\n";
#else
static const char *Dtool_TexturePacker_getTextureCount_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void TexturePacker::setTextureCount(int tcount) = 0
 */
static PyObject *Dtool_TexturePacker_setTextureCount_68(PyObject *self, PyObject *arg) {
  TexturePacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TexturePacker, (void **)&local_this, "TexturePacker.setTextureCount")) {
    return nullptr;
  }
  // 1-virtual void TexturePacker::setTextureCount(int tcount) = 0
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).setTextureCount)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setTextureCount(const TexturePacker self, int tcount)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_setTextureCount_68_comment =
  "C++ Interface:\n"
  "setTextureCount(const TexturePacker self, int tcount)\n"
  "\n"
  "// number of textures to consider..";
#else
static const char *Dtool_TexturePacker_setTextureCount_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void TexturePacker::addTexture(int wid, int hit) = 0
 */
static PyObject *Dtool_TexturePacker_addTexture_69(PyObject *self, PyObject *args, PyObject *kwds) {
  TexturePacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TexturePacker, (void **)&local_this, "TexturePacker.addTexture")) {
    return nullptr;
  }
  // 1-virtual void TexturePacker::addTexture(int wid, int hit) = 0
  int param1;
  int param2;
  static const char *keyword_list[] = {"wid", "hit", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:addTexture", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).addTexture)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "addTexture(const TexturePacker self, int wid, int hit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_addTexture_69_comment =
  "C++ Interface:\n"
  "addTexture(const TexturePacker self, int wid, int hit)\n"
  "\n"
  "// add textures 0 - n";
#else
static const char *Dtool_TexturePacker_addTexture_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool TexturePacker::wouldTextureFit(int wid, int hit, bool forcePowerOfTwo, bool onePixelBorder, int max_wid, int max_hit) = 0
 */
static PyObject *Dtool_TexturePacker_wouldTextureFit_70(PyObject *self, PyObject *args, PyObject *kwds) {
  TexturePacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TexturePacker, (void **)&local_this, "TexturePacker.wouldTextureFit")) {
    return nullptr;
  }
  // 1-virtual bool TexturePacker::wouldTextureFit(int wid, int hit, bool forcePowerOfTwo, bool onePixelBorder, int max_wid, int max_hit) = 0
  int param1;
  int param2;
  PyObject *param3;
  PyObject *param4;
  int param5;
  int param6;
  static const char *keyword_list[] = {"wid", "hit", "forcePowerOfTwo", "onePixelBorder", "max_wid", "max_hit", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiOOii:wouldTextureFit", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
    bool return_value = ((*local_this).wouldTextureFit)((int)param1, (int)param2, (PyObject_IsTrue(param3) != 0), (PyObject_IsTrue(param4) != 0), (int)param5, (int)param6);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "wouldTextureFit(const TexturePacker self, int wid, int hit, bool forcePowerOfTwo, bool onePixelBorder, int max_wid, int max_hit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_wouldTextureFit_70_comment =
  "C++ Interface:\n"
  "wouldTextureFit(const TexturePacker self, int wid, int hit, bool forcePowerOfTwo, bool onePixelBorder, int max_wid, int max_hit)\n";
#else
static const char *Dtool_TexturePacker_wouldTextureFit_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void TexturePacker::addNewTexture(int wid, int hit) = 0
 */
static PyObject *Dtool_TexturePacker_addNewTexture_71(PyObject *self, PyObject *args, PyObject *kwds) {
  TexturePacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TexturePacker, (void **)&local_this, "TexturePacker.addNewTexture")) {
    return nullptr;
  }
  // 1-virtual void TexturePacker::addNewTexture(int wid, int hit) = 0
  int param1;
  int param2;
  static const char *keyword_list[] = {"wid", "hit", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:addNewTexture", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).addNewTexture)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "addNewTexture(const TexturePacker self, int wid, int hit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_addNewTexture_71_comment =
  "C++ Interface:\n"
  "addNewTexture(const TexturePacker self, int wid, int hit)\n";
#else
static const char *Dtool_TexturePacker_addNewTexture_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PackResult TexturePacker::packTextures(bool forcePowerOfTwo, bool onePixelBorder) = 0
 */
static PyObject *Dtool_TexturePacker_packTextures_72(PyObject *self, PyObject *args, PyObject *kwds) {
  TexturePacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TexturePacker, (void **)&local_this, "TexturePacker.packTextures")) {
    return nullptr;
  }
  // 1-virtual PackResult TexturePacker::packTextures(bool forcePowerOfTwo, bool onePixelBorder) = 0
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"forcePowerOfTwo", "onePixelBorder", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:packTextures", (char **)keyword_list, &param1, &param2)) {
    PackResult *return_value = new PackResult(((*local_this).packTextures)((PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PackResult, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "packTextures(const TexturePacker self, bool forcePowerOfTwo, bool onePixelBorder)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_packTextures_72_comment =
  "C++ Interface:\n"
  "packTextures(const TexturePacker self, bool forcePowerOfTwo, bool onePixelBorder)\n"
  "\n"
  "// pack the textures, the return code is the amount of wasted/unused area.";
#else
static const char *Dtool_TexturePacker_packTextures_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual TextureLocation TexturePacker::getTextureLocation(int index) = 0
 */
static PyObject *Dtool_TexturePacker_getTextureLocation_73(PyObject *self, PyObject *arg) {
  TexturePacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TexturePacker, (void **)&local_this, "TexturePacker.getTextureLocation")) {
    return nullptr;
  }
  // 1-virtual TextureLocation TexturePacker::getTextureLocation(int index) = 0
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TextureLocation *return_value = new TextureLocation(((*local_this).getTextureLocation)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextureLocation, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "getTextureLocation(const TexturePacker self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_getTextureLocation_73_comment =
  "C++ Interface:\n"
  "getTextureLocation(const TexturePacker self, int index)\n"
  "\n"
  "// returns true if the texture has been rotated 90 degrees";
#else
static const char *Dtool_TexturePacker_getTextureLocation_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TexturePacker *TexturePacker::createTexturePacker(void)
 */
static PyObject *Dtool_TexturePacker_createTexturePacker_74(PyObject *, PyObject *) {
  // 1-static TexturePacker *TexturePacker::createTexturePacker(void)
  TexturePacker *return_value = (TexturePacker::createTexturePacker)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TexturePacker, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_createTexturePacker_74_comment =
  "C++ Interface:\n"
  "createTexturePacker()\n";
#else
static const char *Dtool_TexturePacker_createTexturePacker_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void TexturePacker::releaseTexturePacker(TexturePacker *tp)
 */
static PyObject *Dtool_TexturePacker_releaseTexturePacker_75(PyObject *, PyObject *arg) {
  // 1-static void TexturePacker::releaseTexturePacker(TexturePacker *tp)
  TexturePacker *arg_this = (TexturePacker *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TexturePacker, 0, "TexturePacker.releaseTexturePacker", false, true);
  if (arg_this != nullptr) {
    (TexturePacker::releaseTexturePacker)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "releaseTexturePacker(TexturePacker tp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_releaseTexturePacker_75_comment =
  "C++ Interface:\n"
  "releaseTexturePacker(TexturePacker tp)\n";
#else
static const char *Dtool_TexturePacker_releaseTexturePacker_75_comment = nullptr;
#endif

static int Dtool_Init_TexturePacker(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TexturePacker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TexturePacker) {
    printf("TexturePacker ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TexturePacker *local_this = (TexturePacker *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TexturePacker) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TexturePacker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TexturePacker) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RayTrace
 */
/**
 * Python function wrapper for:
 * static void RayTrace::initialize(void)
 */
static PyObject *Dtool_RayTrace_initialize_78(PyObject *, PyObject *) {
  // 1-static void RayTrace::initialize(void)
  (RayTrace::initialize)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RayTrace_initialize_78_comment =
  "C++ Interface:\n"
  "initialize()\n";
#else
static const char *Dtool_RayTrace_initialize_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void RayTrace::destruct(void)
 */
static PyObject *Dtool_RayTrace_destruct_79(PyObject *, PyObject *) {
  // 1-static void RayTrace::destruct(void)
  (RayTrace::destruct)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RayTrace_destruct_79_comment =
  "C++ Interface:\n"
  "destruct()\n";
#else
static const char *Dtool_RayTrace_destruct_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RayTrace::RayTrace(void) = default
 * inline RayTrace::RayTrace(RayTrace const &) = default
 */
static int Dtool_Init_RayTrace(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("RayTrace() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline RayTrace::RayTrace(void) = default
      RayTrace *return_value = new RayTrace();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RayTrace, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline RayTrace::RayTrace(RayTrace const &) = default
      RayTrace const *arg_this = (RayTrace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RayTrace, 0, "RayTrace.RayTrace", true, true);
      if (arg_this != nullptr) {
        RayTrace *return_value = new RayTrace(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RayTrace, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "RayTrace() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RayTrace()\n"
      "RayTrace(const RayTrace param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RayTrace(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RayTrace) {
    printf("RayTrace ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RayTrace *local_this = (RayTrace *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RayTrace) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RayTrace(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RayTrace) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RayTraceHitResult
 */
/**
 * Python function wrapper for:
 * inline bool RayTraceHitResult::has_hit(void) const
 */
static PyObject *Dtool_RayTraceHitResult_has_hit_84(PyObject *self, PyObject *) {
  RayTraceHitResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RayTraceHitResult)) {
    return nullptr;
  }
  // 1-inline bool RayTraceHitResult::has_hit(void) const
  bool return_value = ((*(const RayTraceHitResult*)local_this).has_hit)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RayTraceHitResult_has_hit_84_comment =
  "C++ Interface:\n"
  "has_hit(RayTraceHitResult self)\n";
#else
static const char *Dtool_RayTraceHitResult_has_hit_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 RayTraceHitResult::get_hit_normal(void) const
 */
static PyObject *Dtool_RayTraceHitResult_get_hit_normal_85(PyObject *self, PyObject *) {
  RayTraceHitResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RayTraceHitResult)) {
    return nullptr;
  }
  // 1-inline LVector3 RayTraceHitResult::get_hit_normal(void) const
  LVector3 *return_value = new LVector3(((*(const RayTraceHitResult*)local_this).get_hit_normal)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RayTraceHitResult_get_hit_normal_85_comment =
  "C++ Interface:\n"
  "get_hit_normal(RayTraceHitResult self)\n";
#else
static const char *Dtool_RayTraceHitResult_get_hit_normal_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector2 RayTraceHitResult::get_uv(void) const
 */
static PyObject *Dtool_RayTraceHitResult_get_uv_86(PyObject *self, PyObject *) {
  RayTraceHitResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RayTraceHitResult)) {
    return nullptr;
  }
  // 1-inline LVector2 RayTraceHitResult::get_uv(void) const
  LVector2 *return_value = new LVector2(((*(const RayTraceHitResult*)local_this).get_uv)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RayTraceHitResult_get_uv_86_comment =
  "C++ Interface:\n"
  "get_uv(RayTraceHitResult self)\n";
#else
static const char *Dtool_RayTraceHitResult_get_uv_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int RayTraceHitResult::get_prim_id(void) const
 */
static PyObject *Dtool_RayTraceHitResult_get_prim_id_87(PyObject *self, PyObject *) {
  RayTraceHitResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RayTraceHitResult)) {
    return nullptr;
  }
  // 1-inline unsigned int RayTraceHitResult::get_prim_id(void) const
  unsigned int return_value = ((*(const RayTraceHitResult*)local_this).get_prim_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RayTraceHitResult_get_prim_id_87_comment =
  "C++ Interface:\n"
  "get_prim_id(RayTraceHitResult self)\n";
#else
static const char *Dtool_RayTraceHitResult_get_prim_id_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int RayTraceHitResult::get_geom_id(void) const
 */
static PyObject *Dtool_RayTraceHitResult_get_geom_id_88(PyObject *self, PyObject *) {
  RayTraceHitResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RayTraceHitResult)) {
    return nullptr;
  }
  // 1-inline unsigned int RayTraceHitResult::get_geom_id(void) const
  unsigned int return_value = ((*(const RayTraceHitResult*)local_this).get_geom_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RayTraceHitResult_get_geom_id_88_comment =
  "C++ Interface:\n"
  "get_geom_id(RayTraceHitResult self)\n";
#else
static const char *Dtool_RayTraceHitResult_get_geom_id_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float RayTraceHitResult::get_hit_fraction(void) const
 */
static PyObject *Dtool_RayTraceHitResult_get_hit_fraction_89(PyObject *self, PyObject *) {
  RayTraceHitResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RayTraceHitResult)) {
    return nullptr;
  }
  // 1-inline float RayTraceHitResult::get_hit_fraction(void) const
  float return_value = ((*(const RayTraceHitResult*)local_this).get_hit_fraction)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RayTraceHitResult_get_hit_fraction_89_comment =
  "C++ Interface:\n"
  "get_hit_fraction(RayTraceHitResult self)\n";
#else
static const char *Dtool_RayTraceHitResult_get_hit_fraction_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RayTraceHitResult::RayTraceHitResult(void)
 * inline RayTraceHitResult::RayTraceHitResult(RayTraceHitResult const &) = default
 */
static int Dtool_Init_RayTraceHitResult(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("RayTraceHitResult() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline RayTraceHitResult::RayTraceHitResult(void)
      RayTraceHitResult *return_value = new RayTraceHitResult();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RayTraceHitResult, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline RayTraceHitResult::RayTraceHitResult(RayTraceHitResult const &) = default
      RayTraceHitResult const *arg_this = (RayTraceHitResult *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RayTraceHitResult, 0, "RayTraceHitResult.RayTraceHitResult", true, true);
      if (arg_this != nullptr) {
        RayTraceHitResult *return_value = new RayTraceHitResult(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RayTraceHitResult, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "RayTraceHitResult() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RayTraceHitResult()\n"
      "RayTraceHitResult(const RayTraceHitResult param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RayTraceHitResult(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RayTraceHitResult) {
    printf("RayTraceHitResult ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RayTraceHitResult *local_this = (RayTraceHitResult *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RayTraceHitResult) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RayTraceHitResult(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RayTraceHitResult) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RayTraceScene
 */
/**
 * Python function wrapper for:
 * void RayTraceScene::add_geometry(RayTraceGeometry *geom)
 */
static PyObject *Dtool_RayTraceScene_add_geometry_94(PyObject *self, PyObject *arg) {
  RayTraceScene *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RayTraceScene, (void **)&local_this, "RayTraceScene.add_geometry")) {
    return nullptr;
  }
  // 1-void RayTraceScene::add_geometry(RayTraceGeometry *geom)
  PT(RayTraceGeometry) arg_this;
  if (!Dtool_Coerce_RayTraceGeometry(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RayTraceScene.add_geometry", "RayTraceGeometry");
  }
  ((*local_this).add_geometry)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_geometry(const RayTraceScene self, RayTraceGeometry geom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RayTraceScene_add_geometry_94_comment =
  "C++ Interface:\n"
  "add_geometry(const RayTraceScene self, RayTraceGeometry geom)\n";
#else
static const char *Dtool_RayTraceScene_add_geometry_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RayTraceScene::remove_geometry(RayTraceGeometry *geom)
 */
static PyObject *Dtool_RayTraceScene_remove_geometry_95(PyObject *self, PyObject *arg) {
  RayTraceScene *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RayTraceScene, (void **)&local_this, "RayTraceScene.remove_geometry")) {
    return nullptr;
  }
  // 1-void RayTraceScene::remove_geometry(RayTraceGeometry *geom)
  PT(RayTraceGeometry) arg_this;
  if (!Dtool_Coerce_RayTraceGeometry(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RayTraceScene.remove_geometry", "RayTraceGeometry");
  }
  ((*local_this).remove_geometry)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_geometry(const RayTraceScene self, RayTraceGeometry geom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RayTraceScene_remove_geometry_95_comment =
  "C++ Interface:\n"
  "remove_geometry(const RayTraceScene self, RayTraceGeometry geom)\n";
#else
static const char *Dtool_RayTraceScene_remove_geometry_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RayTraceScene::remove_all(void)
 */
static PyObject *Dtool_RayTraceScene_remove_all_96(PyObject *self, PyObject *) {
  RayTraceScene *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RayTraceScene, (void **)&local_this, "RayTraceScene.remove_all")) {
    return nullptr;
  }
  // 1-void RayTraceScene::remove_all(void)
  ((*local_this).remove_all)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RayTraceScene_remove_all_96_comment =
  "C++ Interface:\n"
  "remove_all(const RayTraceScene self)\n";
#else
static const char *Dtool_RayTraceScene_remove_all_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RayTraceHitResult RayTraceScene::trace_line(LPoint3 const &start, LPoint3 const &end, BitMask32 const &mask)
 */
static PyObject *Dtool_RayTraceScene_trace_line_98(PyObject *self, PyObject *args, PyObject *kwds) {
  RayTraceScene *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RayTraceScene, (void **)&local_this, "RayTraceScene.trace_line")) {
    return nullptr;
  }
  // 1-inline RayTraceHitResult RayTraceScene::trace_line(LPoint3 const &start, LPoint3 const &end, BitMask32 const &mask)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"start", "end", "mask", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:trace_line", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "RayTraceScene.trace_line", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "RayTraceScene.trace_line", "LPoint3f");
    }
    BitMask< uint32_t, 32 > param3_local;
    BitMask32 const *param3_this = Dtool_Coerce_BitMask_uint32_t_32(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "RayTraceScene.trace_line", "BitMask");
    }
    RayTraceHitResult *return_value = new RayTraceHitResult(((*local_this).trace_line)(*param1_this, *param2_this, *param3_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_RayTraceHitResult, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "trace_line(const RayTraceScene self, const LPoint3f start, const LPoint3f end, const BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RayTraceScene_trace_line_98_comment =
  "C++ Interface:\n"
  "trace_line(const RayTraceScene self, const LPoint3f start, const LPoint3f end, const BitMask mask)\n";
#else
static const char *Dtool_RayTraceScene_trace_line_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * RayTraceHitResult RayTraceScene::trace_ray(LPoint3 const &origin, LVector3 const &direction, float distance, BitMask32 const &mask)
 */
static PyObject *Dtool_RayTraceScene_trace_ray_99(PyObject *self, PyObject *args, PyObject *kwds) {
  RayTraceScene *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RayTraceScene, (void **)&local_this, "RayTraceScene.trace_ray")) {
    return nullptr;
  }
  // 1-RayTraceHitResult RayTraceScene::trace_ray(LPoint3 const &origin, LVector3 const &direction, float distance, BitMask32 const &mask)
  PyObject *param1;
  PyObject *param2;
  float param3;
  PyObject *param4;
  static const char *keyword_list[] = {"origin", "direction", "distance", "mask", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOfO:trace_ray", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "RayTraceScene.trace_ray", "LPoint3f");
    }
    LVector3f param2_local;
    LVector3 const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "RayTraceScene.trace_ray", "LVector3f");
    }
    BitMask< uint32_t, 32 > param4_local;
    BitMask32 const *param4_this = Dtool_Coerce_BitMask_uint32_t_32(param4, param4_local);
    if (!(param4_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "RayTraceScene.trace_ray", "BitMask");
    }
    RayTraceHitResult *return_value = new RayTraceHitResult(((*local_this).trace_ray)(*param1_this, *param2_this, (float)param3, *param4_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_RayTraceHitResult, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "trace_ray(const RayTraceScene self, const LPoint3f origin, const LVector3f direction, float distance, const BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RayTraceScene_trace_ray_99_comment =
  "C++ Interface:\n"
  "trace_ray(const RayTraceScene self, const LPoint3f origin, const LVector3f direction, float distance, const BitMask mask)\n";
#else
static const char *Dtool_RayTraceScene_trace_ray_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RayTraceScene::set_build_quality(int quality)
 */
static PyObject *Dtool_RayTraceScene_set_build_quality_100(PyObject *self, PyObject *arg) {
  RayTraceScene *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RayTraceScene, (void **)&local_this, "RayTraceScene.set_build_quality")) {
    return nullptr;
  }
  // 1-void RayTraceScene::set_build_quality(int quality)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_build_quality)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_build_quality(const RayTraceScene self, int quality)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RayTraceScene_set_build_quality_100_comment =
  "C++ Interface:\n"
  "set_build_quality(const RayTraceScene self, int quality)\n";
#else
static const char *Dtool_RayTraceScene_set_build_quality_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RayTraceScene::update(void)
 */
static PyObject *Dtool_RayTraceScene_update_101(PyObject *self, PyObject *) {
  RayTraceScene *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RayTraceScene, (void **)&local_this, "RayTraceScene.update")) {
    return nullptr;
  }
  // 1-void RayTraceScene::update(void)
  ((*local_this).update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RayTraceScene_update_101_comment =
  "C++ Interface:\n"
  "update(const RayTraceScene self)\n";
#else
static const char *Dtool_RayTraceScene_update_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RayTraceGeometry *RayTraceScene::get_geometry(unsigned int geom_id)
 */
static PyObject *Dtool_RayTraceScene_get_geometry_102(PyObject *self, PyObject *arg) {
  RayTraceScene *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RayTraceScene, (void **)&local_this, "RayTraceScene.get_geometry")) {
    return nullptr;
  }
  // 1-inline RayTraceGeometry *RayTraceScene::get_geometry(unsigned int geom_id)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    RayTraceGeometry *return_value = ((*local_this).get_geometry)((unsigned int)param1);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_RayTraceGeometry, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_geometry(const RayTraceScene self, int geom_id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RayTraceScene_get_geometry_102_comment =
  "C++ Interface:\n"
  "get_geometry(const RayTraceScene self, int geom_id)\n";
#else
static const char *Dtool_RayTraceScene_get_geometry_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * RayTraceScene::RayTraceScene(void)
 * inline RayTraceScene::RayTraceScene(RayTraceScene const &) = default
 */
static int Dtool_Init_RayTraceScene(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("RayTraceScene() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-RayTraceScene::RayTraceScene(void)
      RayTraceScene *return_value = new RayTraceScene();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RayTraceScene, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline RayTraceScene::RayTraceScene(RayTraceScene const &) = default
      RayTraceScene const *arg_this = (RayTraceScene *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RayTraceScene, 0, "RayTraceScene.RayTraceScene", true, true);
      if (arg_this != nullptr) {
        RayTraceScene *return_value = new RayTraceScene(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RayTraceScene, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "RayTraceScene() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RayTraceScene()\n"
      "RayTraceScene(const RayTraceScene param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RayTraceScene(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RayTraceScene) {
    printf("RayTraceScene ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RayTraceScene *local_this = (RayTraceScene *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RayTraceScene) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RayTraceScene(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RayTraceScene) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RayTraceScene*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RayTraceGeometry
 */
/**
 * Python function wrapper for:
 * static TypeHandle RayTraceGeometry::get_class_type(void)
 */
static PyObject *Dtool_RayTraceGeometry_get_class_type_105(PyObject *, PyObject *) {
  // 1-static TypeHandle RayTraceGeometry::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((RayTraceGeometry::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RayTraceGeometry_get_class_type_105_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RayTraceGeometry_get_class_type_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RayTraceGeometry::set_mask(BitMask32 const &mask)
 * void RayTraceGeometry::set_mask(unsigned int mask)
 */
static PyObject *Dtool_RayTraceGeometry_set_mask_106(PyObject *self, PyObject *arg) {
  RayTraceGeometry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RayTraceGeometry, (void **)&local_this, "RayTraceGeometry.set_mask")) {
    return nullptr;
  }
  {
    // -2 inline void RayTraceGeometry::set_mask(BitMask32 const &mask)
    BitMask32 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_BitMask_uint32_t_32);
    if (arg_this != nullptr) {
      ((*local_this).set_mask)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void RayTraceGeometry::set_mask(unsigned int mask)
    if (PyLongOrInt_Check(arg)) {
      unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (param1 > UINT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %lu out of range for unsigned integer",
                            param1);
      }
#endif
      ((*local_this).set_mask)((unsigned int)param1);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void RayTraceGeometry::set_mask(BitMask32 const &mask)
    BitMask< uint32_t, 32 > arg_local;
    BitMask32 const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_mask)(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void RayTraceGeometry::set_mask(unsigned int mask)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mask(const RayTraceGeometry self, const BitMask mask)\n"
      "set_mask(const RayTraceGeometry self, int mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RayTraceGeometry_set_mask_106_comment =
  "C++ Interface:\n"
  "set_mask(const RayTraceGeometry self, const BitMask mask)\n"
  "set_mask(const RayTraceGeometry self, int mask)\n";
#else
static const char *Dtool_RayTraceGeometry_set_mask_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask32 RayTraceGeometry::get_mask(void) const
 */
static PyObject *Dtool_RayTraceGeometry_get_mask_107(PyObject *self, PyObject *) {
  RayTraceGeometry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RayTraceGeometry)) {
    return nullptr;
  }
  // 1-inline BitMask32 RayTraceGeometry::get_mask(void) const
  BitMask32 *return_value = new BitMask32(((*(const RayTraceGeometry*)local_this).get_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RayTraceGeometry_get_mask_107_comment =
  "C++ Interface:\n"
  "get_mask(RayTraceGeometry self)\n";
#else
static const char *Dtool_RayTraceGeometry_get_mask_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int RayTraceGeometry::get_geom_id(void) const
 */
static PyObject *Dtool_RayTraceGeometry_get_geom_id_108(PyObject *self, PyObject *) {
  RayTraceGeometry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RayTraceGeometry)) {
    return nullptr;
  }
  // 1-inline unsigned int RayTraceGeometry::get_geom_id(void) const
  unsigned int return_value = ((*(const RayTraceGeometry*)local_this).get_geom_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RayTraceGeometry_get_geom_id_108_comment =
  "C++ Interface:\n"
  "get_geom_id(RayTraceGeometry self)\n";
#else
static const char *Dtool_RayTraceGeometry_get_geom_id_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RayTraceGeometry::set_build_quality(int quality)
 */
static PyObject *Dtool_RayTraceGeometry_set_build_quality_109(PyObject *self, PyObject *arg) {
  RayTraceGeometry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RayTraceGeometry, (void **)&local_this, "RayTraceGeometry.set_build_quality")) {
    return nullptr;
  }
  // 1-void RayTraceGeometry::set_build_quality(int quality)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_build_quality)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_build_quality(const RayTraceGeometry self, int quality)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RayTraceGeometry_set_build_quality_109_comment =
  "C++ Interface:\n"
  "set_build_quality(const RayTraceGeometry self, int quality)\n";
#else
static const char *Dtool_RayTraceGeometry_set_build_quality_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void RayTraceGeometry::build(void) = 0
 */
static PyObject *Dtool_RayTraceGeometry_build_110(PyObject *self, PyObject *) {
  RayTraceGeometry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RayTraceGeometry, (void **)&local_this, "RayTraceGeometry.build")) {
    return nullptr;
  }
  // 1-virtual void RayTraceGeometry::build(void) = 0
  ((*local_this).build)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RayTraceGeometry_build_110_comment =
  "C++ Interface:\n"
  "build(const RayTraceGeometry self)\n";
#else
static const char *Dtool_RayTraceGeometry_build_110_comment = nullptr;
#endif

static int Dtool_Init_RayTraceGeometry(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_RayTraceGeometry(PyObject *args, CPT(RayTraceGeometry) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_RayTraceGeometry)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_RayTraceGeometry(PyObject *args, PT(RayTraceGeometry) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_RayTraceGeometry)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_RayTraceGeometry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RayTraceGeometry) {
    printf("RayTraceGeometry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RayTraceGeometry *local_this = (RayTraceGeometry *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RayTraceGeometry) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RayTraceGeometry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RayTraceGeometry) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (RayTraceGeometry*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (RayTraceGeometry*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RayTraceGeometry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (RayTraceGeometry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (RayTraceGeometry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (RayTraceGeometry*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RayTraceTriangleMesh
 */
/**
 * Python function wrapper for:
 * static TypeHandle RayTraceTriangleMesh::get_class_type(void)
 */
static PyObject *Dtool_RayTraceTriangleMesh_get_class_type_112(PyObject *, PyObject *) {
  // 1-static TypeHandle RayTraceTriangleMesh::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((RayTraceTriangleMesh::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RayTraceTriangleMesh_get_class_type_112_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RayTraceTriangleMesh_get_class_type_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RayTraceTriangleMesh::add_triangle(LPoint3 const &p1, LPoint3 const &p2, LPoint3 const &p3)
 */
static PyObject *Dtool_RayTraceTriangleMesh_add_triangle_114(PyObject *self, PyObject *args, PyObject *kwds) {
  RayTraceTriangleMesh *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RayTraceTriangleMesh, (void **)&local_this, "RayTraceTriangleMesh.add_triangle")) {
    return nullptr;
  }
  // 1-void RayTraceTriangleMesh::add_triangle(LPoint3 const &p1, LPoint3 const &p2, LPoint3 const &p3)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"p1", "p2", "p3", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:add_triangle", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "RayTraceTriangleMesh.add_triangle", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "RayTraceTriangleMesh.add_triangle", "LPoint3f");
    }
    LPoint3f param3_local;
    LPoint3 const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "RayTraceTriangleMesh.add_triangle", "LPoint3f");
    }
    ((*local_this).add_triangle)(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_triangle(const RayTraceTriangleMesh self, const LPoint3f p1, const LPoint3f p2, const LPoint3f p3)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RayTraceTriangleMesh_add_triangle_114_comment =
  "C++ Interface:\n"
  "add_triangle(const RayTraceTriangleMesh self, const LPoint3f p1, const LPoint3f p2, const LPoint3f p3)\n";
#else
static const char *Dtool_RayTraceTriangleMesh_add_triangle_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RayTraceTriangleMesh::add_triangles_from_geom(Geom const *geom, TransformState const *ts = nullptr)
 */
static PyObject *Dtool_RayTraceTriangleMesh_add_triangles_from_geom_115(PyObject *self, PyObject *args, PyObject *kwds) {
  RayTraceTriangleMesh *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RayTraceTriangleMesh, (void **)&local_this, "RayTraceTriangleMesh.add_triangles_from_geom")) {
    return nullptr;
  }
  // 1-void RayTraceTriangleMesh::add_triangles_from_geom(Geom const *geom, TransformState const *ts = nullptr)
  PyObject *param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"geom", "ts", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:add_triangles_from_geom", (char **)keyword_list, &param1, &param2)) {
    Geom const *param1_this = (Geom *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Geom, 1, "RayTraceTriangleMesh.add_triangles_from_geom", true, true);
    TransformState const *param2_this = nullptr;
    if (param2 != nullptr && param2 != Py_None) {
      param2_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TransformState, 2, "RayTraceTriangleMesh.add_triangles_from_geom", true, true);
    }
    if (param1_this != nullptr && (param2 == nullptr || param2 == Py_None || param2_this != nullptr)) {
      ((*local_this).add_triangles_from_geom)(param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_triangles_from_geom(const RayTraceTriangleMesh self, const Geom geom, const TransformState ts)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RayTraceTriangleMesh_add_triangles_from_geom_115_comment =
  "C++ Interface:\n"
  "add_triangles_from_geom(const RayTraceTriangleMesh self, const Geom geom, const TransformState ts)\n";
#else
static const char *Dtool_RayTraceTriangleMesh_add_triangles_from_geom_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * RayTraceTriangleMesh::RayTraceTriangleMesh(std::string const &name = "")
 */
static int Dtool_Init_RayTraceTriangleMesh(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-RayTraceTriangleMesh::RayTraceTriangleMesh(std::string const &name = "")
  const char *param0_str = "";
  Py_ssize_t param0_len = 0;
  static const char *keyword_list[] = {"name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:RayTraceTriangleMesh", (char **)keyword_list, &param0_str, &param0_len)) {
    RayTraceTriangleMesh *return_value = new RayTraceTriangleMesh(std::string(param0_str, param0_len));
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RayTraceTriangleMesh, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RayTraceTriangleMesh(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_RayTraceTriangleMesh(PyObject *args, CPT(RayTraceTriangleMesh) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_RayTraceTriangleMesh)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-RayTraceTriangleMesh::RayTraceTriangleMesh(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      RayTraceTriangleMesh *return_value = new RayTraceTriangleMesh(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_RayTraceTriangleMesh(PyObject *args, PT(RayTraceTriangleMesh) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_RayTraceTriangleMesh)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-RayTraceTriangleMesh::RayTraceTriangleMesh(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      RayTraceTriangleMesh *return_value = new RayTraceTriangleMesh(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_RayTraceTriangleMesh(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RayTraceTriangleMesh) {
    printf("RayTraceTriangleMesh ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RayTraceTriangleMesh *local_this = (RayTraceTriangleMesh *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RayTraceTriangleMesh) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(RayTraceGeometry *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(RayTraceGeometry *) local_this;
  }
  if (requested_type == Dtool_Ptr_RayTraceGeometry) {
    return (RayTraceGeometry *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(RayTraceGeometry *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(RayTraceGeometry *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(RayTraceGeometry *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(RayTraceGeometry *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RayTraceTriangleMesh(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RayTraceTriangleMesh) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (RayTraceTriangleMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (RayTraceTriangleMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_RayTraceGeometry) {
    RayTraceGeometry* other_this = (RayTraceGeometry*)from_this;
    return (RayTraceTriangleMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RayTraceTriangleMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (RayTraceTriangleMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (RayTraceTriangleMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (RayTraceTriangleMesh*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPFaceAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make(std::string const &face_material, int face_type)
 */
static PyObject *Dtool_BSPFaceAttrib_make_119(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make(std::string const &face_material, int face_type)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  int param1;
  static const char *keyword_list[] = {"face_material", "face_type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:make", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    ConstPointerTo< RenderAttrib > return_value = (BSPFaceAttrib::make)(std::string(param0_str, param0_len), (int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(str face_material, int face_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_make_119_comment =
  "C++ Interface:\n"
  "make(str face_material, int face_type)\n";
#else
static const char *Dtool_BSPFaceAttrib_make_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make_default(void)
 */
static PyObject *Dtool_BSPFaceAttrib_make_default_120(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = (BSPFaceAttrib::make_default)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_make_default_120_comment =
  "C++ Interface:\n"
  "make_default()\n";
#else
static const char *Dtool_BSPFaceAttrib_make_default_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make_ignore_pvs(void)
 */
static PyObject *Dtool_BSPFaceAttrib_make_ignore_pvs_121(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make_ignore_pvs(void)
  ConstPointerTo< RenderAttrib > return_value = (BSPFaceAttrib::make_ignore_pvs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_make_ignore_pvs_121_comment =
  "C++ Interface:\n"
  "make_ignore_pvs()\n";
#else
static const char *Dtool_BSPFaceAttrib_make_ignore_pvs_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string BSPFaceAttrib::get_material(void) const
 */
static PyObject *Dtool_BSPFaceAttrib_get_material_122(PyObject *self, PyObject *) {
  BSPFaceAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPFaceAttrib)) {
    return nullptr;
  }
  // 1-inline std::string BSPFaceAttrib::get_material(void) const
  std::string return_value = ((*(const BSPFaceAttrib*)local_this).get_material)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_get_material_122_comment =
  "C++ Interface:\n"
  "get_material(BSPFaceAttrib self)\n";
#else
static const char *Dtool_BSPFaceAttrib_get_material_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BSPFaceAttrib::get_face_type(void) const
 */
static PyObject *Dtool_BSPFaceAttrib_get_face_type_123(PyObject *self, PyObject *) {
  BSPFaceAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPFaceAttrib)) {
    return nullptr;
  }
  // 1-inline int BSPFaceAttrib::get_face_type(void) const
  int return_value = ((*(const BSPFaceAttrib*)local_this).get_face_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_get_face_type_123_comment =
  "C++ Interface:\n"
  "get_face_type(BSPFaceAttrib self)\n";
#else
static const char *Dtool_BSPFaceAttrib_get_face_type_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPFaceAttrib::get_ignore_pvs(void) const
 */
static PyObject *Dtool_BSPFaceAttrib_get_ignore_pvs_124(PyObject *self, PyObject *) {
  BSPFaceAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPFaceAttrib)) {
    return nullptr;
  }
  // 1-inline bool BSPFaceAttrib::get_ignore_pvs(void) const
  bool return_value = ((*(const BSPFaceAttrib*)local_this).get_ignore_pvs)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_get_ignore_pvs_124_comment =
  "C++ Interface:\n"
  "get_ignore_pvs(BSPFaceAttrib self)\n";
#else
static const char *Dtool_BSPFaceAttrib_get_ignore_pvs_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int BSPFaceAttrib::get_class_slot(void)
 */
static PyObject *Dtool_BSPFaceAttrib_get_class_slot_125(PyObject *, PyObject *) {
  // 1-static int BSPFaceAttrib::get_class_slot(void)
  int return_value = (BSPFaceAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_get_class_slot_125_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_BSPFaceAttrib_get_class_slot_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BSPFaceAttrib::get_class_type(void)
 */
static PyObject *Dtool_BSPFaceAttrib_get_class_type_127(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPFaceAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BSPFaceAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_get_class_type_127_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPFaceAttrib_get_class_type_127_comment = nullptr;
#endif

static PyObject *Dtool_BSPFaceAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int BSPFaceAttrib::get_class_slot(void)
  int return_value = (BSPFaceAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_BSPFaceAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_BSPFaceAttrib(PyObject *args, CPT(BSPFaceAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPFaceAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make(std::string const &face_material, int face_type)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      int param1;
      if (PyArg_ParseTuple(args, "s#i:make", &param0_str, &param0_len, &param1)) {
        ConstPointerTo< RenderAttrib > return_value = (BSPFaceAttrib::make)(std::string(param0_str, param0_len), (int)param1);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move((BSPFaceAttrib const *) return_value.p());
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_BSPFaceAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPFaceAttrib) {
    printf("BSPFaceAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPFaceAttrib *local_this = (BSPFaceAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPFaceAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPFaceAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPFaceAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPLoader
 */
/**
 * Python function wrapper for:
 * void BSPLoader::remove_physics(NodePath const &root)
 */
static PyObject *Dtool_BSPLoader_remove_physics_130(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.remove_physics")) {
    return nullptr;
  }
  // 1-void BSPLoader::remove_physics(NodePath const &root)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "BSPLoader.remove_physics", true, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_physics)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_physics(const BSPLoader self, const NodePath root)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_remove_physics_130_comment =
  "C++ Interface:\n"
  "remove_physics(const BSPLoader self, const NodePath root)\n";
#else
static const char *Dtool_BSPLoader_remove_physics_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_physics_world(BulletWorld *world)
 */
static PyObject *Dtool_BSPLoader_set_physics_world_131(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_physics_world")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_physics_world(BulletWorld *world)
  BulletWorld *arg_this = (BulletWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BulletWorld, 1, "BSPLoader.set_physics_world", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_physics_world)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_physics_world(const BSPLoader self, BulletWorld world)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_physics_world_131_comment =
  "C++ Interface:\n"
  "set_physics_world(const BSPLoader self, BulletWorld world)\n";
#else
static const char *Dtool_BSPLoader_set_physics_world_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BulletWorld *BSPLoader::get_physics_world(void) const
 */
static PyObject *Dtool_BSPLoader_get_physics_world_132(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline BulletWorld *BSPLoader::get_physics_world(void) const
  BulletWorld *return_value = ((*(const BSPLoader*)local_this).get_physics_world)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BulletWorld, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_physics_world_132_comment =
  "C++ Interface:\n"
  "get_physics_world(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_physics_world_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPLoader::has_brush_collision_node(BulletRigidBodyNode *rbnode) const
 */
static PyObject *Dtool_BSPLoader_has_brush_collision_node_133(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline bool BSPLoader::has_brush_collision_node(BulletRigidBodyNode *rbnode) const
  BulletRigidBodyNode *arg_this = (BulletRigidBodyNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BulletRigidBodyNode, 1, "BSPLoader.has_brush_collision_node", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const BSPLoader*)local_this).has_brush_collision_node)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_brush_collision_node(BSPLoader self, BulletRigidBodyNode rbnode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_has_brush_collision_node_133_comment =
  "C++ Interface:\n"
  "has_brush_collision_node(BSPLoader self, BulletRigidBodyNode rbnode)\n";
#else
static const char *Dtool_BSPLoader_has_brush_collision_node_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPLoader::has_brush_collision_triangle(BulletRigidBodyNode *rbnode, int triangle_idx)
 */
static PyObject *Dtool_BSPLoader_has_brush_collision_triangle_134(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.has_brush_collision_triangle")) {
    return nullptr;
  }
  // 1-inline bool BSPLoader::has_brush_collision_triangle(BulletRigidBodyNode *rbnode, int triangle_idx)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"rbnode", "triangle_idx", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:has_brush_collision_triangle", (char **)keyword_list, &param1, &param2)) {
    BulletRigidBodyNode *param1_this = (BulletRigidBodyNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BulletRigidBodyNode, 1, "BSPLoader.has_brush_collision_triangle", false, true);
    if (param1_this != nullptr) {
      bool return_value = ((*local_this).has_brush_collision_triangle)(param1_this, (int)param2);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_brush_collision_triangle(const BSPLoader self, BulletRigidBodyNode rbnode, int triangle_idx)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_has_brush_collision_triangle_134_comment =
  "C++ Interface:\n"
  "has_brush_collision_triangle(const BSPLoader self, BulletRigidBodyNode rbnode, int triangle_idx)\n";
#else
static const char *Dtool_BSPLoader_has_brush_collision_triangle_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string BSPLoader::get_brush_triangle_material(BulletRigidBodyNode *rbnode, int triangle_idx)
 */
static PyObject *Dtool_BSPLoader_get_brush_triangle_material_135(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.get_brush_triangle_material")) {
    return nullptr;
  }
  // 1-inline std::string BSPLoader::get_brush_triangle_material(BulletRigidBodyNode *rbnode, int triangle_idx)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"rbnode", "triangle_idx", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_brush_triangle_material", (char **)keyword_list, &param1, &param2)) {
    BulletRigidBodyNode *param1_this = (BulletRigidBodyNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BulletRigidBodyNode, 1, "BSPLoader.get_brush_triangle_material", false, true);
    if (param1_this != nullptr) {
      std::string return_value = ((*local_this).get_brush_triangle_material)(param1_this, (int)param2);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_brush_triangle_material(const BSPLoader self, BulletRigidBodyNode rbnode, int triangle_idx)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_brush_triangle_material_135_comment =
  "C++ Interface:\n"
  "get_brush_triangle_material(const BSPLoader self, BulletRigidBodyNode rbnode, int triangle_idx)\n";
#else
static const char *Dtool_BSPLoader_get_brush_triangle_material_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BSPLoader::get_brush_triangle_model(BulletRigidBodyNode *rbnode, int triangle_idx)
 */
static PyObject *Dtool_BSPLoader_get_brush_triangle_model_136(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.get_brush_triangle_model")) {
    return nullptr;
  }
  // 1-inline int BSPLoader::get_brush_triangle_model(BulletRigidBodyNode *rbnode, int triangle_idx)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"rbnode", "triangle_idx", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_brush_triangle_model", (char **)keyword_list, &param1, &param2)) {
    BulletRigidBodyNode *param1_this = (BulletRigidBodyNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BulletRigidBodyNode, 1, "BSPLoader.get_brush_triangle_model", false, true);
    if (param1_this != nullptr) {
      int return_value = ((*local_this).get_brush_triangle_model)(param1_this, (int)param2);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_brush_triangle_model(const BSPLoader self, BulletRigidBodyNode rbnode, int triangle_idx)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_brush_triangle_model_136_comment =
  "C++ Interface:\n"
  "get_brush_triangle_model(const BSPLoader self, BulletRigidBodyNode rbnode, int triangle_idx)\n";
#else
static const char *Dtool_BSPLoader_get_brush_triangle_model_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BSPLoader::get_brush_triangle_model_fast(BulletRigidBodyNode *rbnode, int triangle_idx)
 */
static PyObject *Dtool_BSPLoader_get_brush_triangle_model_fast_137(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.get_brush_triangle_model_fast")) {
    return nullptr;
  }
  // 1-int BSPLoader::get_brush_triangle_model_fast(BulletRigidBodyNode *rbnode, int triangle_idx)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"rbnode", "triangle_idx", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_brush_triangle_model_fast", (char **)keyword_list, &param1, &param2)) {
    BulletRigidBodyNode *param1_this = (BulletRigidBodyNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BulletRigidBodyNode, 1, "BSPLoader.get_brush_triangle_model_fast", false, true);
    if (param1_this != nullptr) {
      int return_value = ((*local_this).get_brush_triangle_model_fast)(param1_this, (int)param2);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_brush_triangle_model_fast(const BSPLoader self, BulletRigidBodyNode rbnode, int triangle_idx)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_brush_triangle_model_fast_137_comment =
  "C++ Interface:\n"
  "get_brush_triangle_model_fast(const BSPLoader self, BulletRigidBodyNode rbnode, int triangle_idx)\n";
#else
static const char *Dtool_BSPLoader_get_brush_triangle_model_fast_137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 BSPLoader::get_model_origin(int modelnum)
 */
static PyObject *Dtool_BSPLoader_get_model_origin_138(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.get_model_origin")) {
    return nullptr;
  }
  // 1-inline LPoint3 BSPLoader::get_model_origin(int modelnum)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 *return_value = new LPoint3(((*local_this).get_model_origin)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_model_origin(const BSPLoader self, int modelnum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_model_origin_138_comment =
  "C++ Interface:\n"
  "get_model_origin(const BSPLoader self, int modelnum)\n";
#else
static const char *Dtool_BSPLoader_get_model_origin_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool BSPLoader::read(Filename const &file, bool is_transition = false)
 */
static PyObject *Dtool_BSPLoader_read_139(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.read")) {
    return nullptr;
  }
  // 1-virtual bool BSPLoader::read(Filename const &file, bool is_transition = false)
  PyObject *param1;
  PyObject *param2 = Py_False;
  static const char *keyword_list[] = {"file", "is_transition", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:read", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "BSPLoader.read", "Filename");
    }
    bool return_value = ((*local_this).read)(*param1_this, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const BSPLoader self, const Filename file, bool is_transition)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_read_139_comment =
  "C++ Interface:\n"
  "read(const BSPLoader self, const Filename file, bool is_transition)\n";
#else
static const char *Dtool_BSPLoader_read_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::do_optimizations(void)
 */
static PyObject *Dtool_BSPLoader_do_optimizations_140(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.do_optimizations")) {
    return nullptr;
  }
  // 1-void BSPLoader::do_optimizations(void)
  ((*local_this).do_optimizations)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_do_optimizations_140_comment =
  "C++ Interface:\n"
  "do_optimizations(const BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_do_optimizations_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_gamma(PN_stdfloat gamma, int overbright = 1)
 */
static PyObject *Dtool_BSPLoader_set_gamma_141(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_gamma")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_gamma(PN_stdfloat gamma, int overbright = 1)
  float param1;
  int param2 = 1;
  static const char *keyword_list[] = {"gamma", "overbright", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "f|i:set_gamma", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_gamma)((PN_stdfloat)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gamma(const BSPLoader self, float gamma, int overbright)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_gamma_141_comment =
  "C++ Interface:\n"
  "set_gamma(const BSPLoader self, float gamma, int overbright)\n";
#else
static const char *Dtool_BSPLoader_set_gamma_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat BSPLoader::get_gamma(void) const
 */
static PyObject *Dtool_BSPLoader_get_gamma_142(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat BSPLoader::get_gamma(void) const
  PN_stdfloat return_value = ((*(const BSPLoader*)local_this).get_gamma)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_gamma_142_comment =
  "C++ Interface:\n"
  "get_gamma(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_gamma_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_win(GraphicsWindow *win)
 */
static PyObject *Dtool_BSPLoader_set_win_143(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_win")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_win(GraphicsWindow *win)
  GraphicsWindow *arg_this = (GraphicsWindow *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsWindow, 1, "BSPLoader.set_win", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_win)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_win(const BSPLoader self, GraphicsWindow win)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_win_143_comment =
  "C++ Interface:\n"
  "set_win(const BSPLoader self, GraphicsWindow win)\n";
#else
static const char *Dtool_BSPLoader_set_win_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_camera(NodePath const &camera)
 */
static PyObject *Dtool_BSPLoader_set_camera_144(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_camera")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_camera(NodePath const &camera)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "BSPLoader.set_camera", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_camera)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_camera(const BSPLoader self, const NodePath camera)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_camera_144_comment =
  "C++ Interface:\n"
  "set_camera(const BSPLoader self, const NodePath camera)\n";
#else
static const char *Dtool_BSPLoader_set_camera_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_render(NodePath const &render)
 */
static PyObject *Dtool_BSPLoader_set_render_145(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_render")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_render(NodePath const &render)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "BSPLoader.set_render", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_render)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render(const BSPLoader self, const NodePath render)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_render_145_comment =
  "C++ Interface:\n"
  "set_render(const BSPLoader self, const NodePath render)\n";
#else
static const char *Dtool_BSPLoader_set_render_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_shader_generator(BSPShaderGenerator *shgen)
 */
static PyObject *Dtool_BSPLoader_set_shader_generator_146(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_shader_generator")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_shader_generator(BSPShaderGenerator *shgen)
  PT(BSPShaderGenerator) arg_this;
  if (!Dtool_Coerce_BSPShaderGenerator(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPLoader.set_shader_generator", "BSPShaderGenerator");
  }
  ((*local_this).set_shader_generator)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shader_generator(const BSPLoader self, BSPShaderGenerator shgen)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_shader_generator_146_comment =
  "C++ Interface:\n"
  "set_shader_generator(const BSPLoader self, BSPShaderGenerator shgen)\n";
#else
static const char *Dtool_BSPLoader_set_shader_generator_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_want_visibility(bool flag)
 */
static PyObject *Dtool_BSPLoader_set_want_visibility_147(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_want_visibility")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_want_visibility(bool flag)
  ((*local_this).set_want_visibility)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_want_visibility(const BSPLoader self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_want_visibility_147_comment =
  "C++ Interface:\n"
  "set_want_visibility(const BSPLoader self, bool flag)\n";
#else
static const char *Dtool_BSPLoader_set_want_visibility_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_want_lightmaps(bool flag)
 */
static PyObject *Dtool_BSPLoader_set_want_lightmaps_148(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_want_lightmaps")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_want_lightmaps(bool flag)
  ((*local_this).set_want_lightmaps)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_want_lightmaps(const BSPLoader self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_want_lightmaps_148_comment =
  "C++ Interface:\n"
  "set_want_lightmaps(const BSPLoader self, bool flag)\n";
#else
static const char *Dtool_BSPLoader_set_want_lightmaps_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_physics_type(int type)
 */
static PyObject *Dtool_BSPLoader_set_physics_type_149(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_physics_type")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_physics_type(int type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_physics_type)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_physics_type(const BSPLoader self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_physics_type_149_comment =
  "C++ Interface:\n"
  "set_physics_type(const BSPLoader self, int type)\n";
#else
static const char *Dtool_BSPLoader_set_physics_type_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_visualize_leafs(bool flag)
 */
static PyObject *Dtool_BSPLoader_set_visualize_leafs_150(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_visualize_leafs")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_visualize_leafs(bool flag)
  ((*local_this).set_visualize_leafs)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_visualize_leafs(const BSPLoader self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_visualize_leafs_150_comment =
  "C++ Interface:\n"
  "set_visualize_leafs(const BSPLoader self, bool flag)\n";
#else
static const char *Dtool_BSPLoader_set_visualize_leafs_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_materials_file(Filename const &file)
 */
static PyObject *Dtool_BSPLoader_set_materials_file_151(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_materials_file")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_materials_file(Filename const &file)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPLoader.set_materials_file", "Filename");
  }
  ((*local_this).set_materials_file)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_materials_file(const BSPLoader self, const Filename file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_materials_file_151_comment =
  "C++ Interface:\n"
  "set_materials_file(const BSPLoader self, const Filename file)\n";
#else
static const char *Dtool_BSPLoader_set_materials_file_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_wireframe(bool flag)
 */
static PyObject *Dtool_BSPLoader_set_wireframe_152(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_wireframe")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_wireframe(bool flag)
  ((*local_this).set_wireframe)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wireframe(const BSPLoader self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_wireframe_152_comment =
  "C++ Interface:\n"
  "set_wireframe(const BSPLoader self, bool flag)\n";
#else
static const char *Dtool_BSPLoader_set_wireframe_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPLoader::get_wireframe(void) const
 */
static PyObject *Dtool_BSPLoader_get_wireframe_153(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline bool BSPLoader::get_wireframe(void) const
  bool return_value = ((*(const BSPLoader*)local_this).get_wireframe)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_wireframe_153_comment =
  "C++ Interface:\n"
  "get_wireframe(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_wireframe_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath BSPLoader::get_camera(void) const
 */
static PyObject *Dtool_BSPLoader_get_camera_154(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline NodePath BSPLoader::get_camera(void) const
  NodePath *return_value = new NodePath(((*(const BSPLoader*)local_this).get_camera)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_camera_154_comment =
  "C++ Interface:\n"
  "get_camera(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_camera_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BSPLoader::trace_decal(std::string const &decal_material, LPoint2 const &decal_scale, float rotate, LPoint3 const &start, LPoint3 const &end, LColorf const &decal_color = LColorf(1))
 */
static PyObject *Dtool_BSPLoader_trace_decal_155(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.trace_decal")) {
    return nullptr;
  }
  // 1-inline void BSPLoader::trace_decal(std::string const &decal_material, LPoint2 const &decal_scale, float rotate, LPoint3 const &start, LPoint3 const &end, LColorf const &decal_color = LColorf(1))
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  float param3;
  PyObject *param4;
  PyObject *param5;
  PyObject *param6 = nullptr;
  static const char *keyword_list[] = {"decal_material", "decal_scale", "rotate", "start", "end", "decal_color", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#OfOO|O:trace_decal", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6)) {
    LPoint2f param2_local;
    LPoint2 const *param2_this = Dtool_Coerce_LPoint2f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "BSPLoader.trace_decal", "LPoint2f");
    }
    LPoint3f param4_local;
    LPoint3 const *param4_this = Dtool_Coerce_LPoint3f(param4, param4_local);
    if (!(param4_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "BSPLoader.trace_decal", "LPoint3f");
    }
    LPoint3f param5_local;
    LPoint3 const *param5_this = Dtool_Coerce_LPoint3f(param5, param5_local);
    if (!(param5_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "BSPLoader.trace_decal", "LPoint3f");
    }
    LVecBase4f param6_local;
    LColorf const *param6_this;
    if (param6 != nullptr) {
      param6_this = Dtool_Coerce_LVecBase4f(param6, param6_local);
    } else {
      param6_local = LColorf(1);
      param6_this = &param6_local;
    }
    if (param6 != nullptr && !(param6_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param6, 6, "BSPLoader.trace_decal", "LVecBase4f");
    }
    ((*local_this).trace_decal)(std::string(param1_str, param1_len), *param2_this, (float)param3, *param4_this, *param5_this, *param6_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "trace_decal(const BSPLoader self, str decal_material, const LPoint2f decal_scale, float rotate, const LPoint3f start, const LPoint3f end, const LVecBase4f decal_color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_trace_decal_155_comment =
  "C++ Interface:\n"
  "trace_decal(const BSPLoader self, str decal_material, const LPoint2f decal_scale, float rotate, const LPoint3f start, const LPoint3f end, const LVecBase4f decal_color)\n";
#else
static const char *Dtool_BSPLoader_trace_decal_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Texture *BSPLoader::get_closest_cubemap_texture(LPoint3 const &pos)
 */
static PyObject *Dtool_BSPLoader_get_closest_cubemap_texture_156(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.get_closest_cubemap_texture")) {
    return nullptr;
  }
  // 1-Texture *BSPLoader::get_closest_cubemap_texture(LPoint3 const &pos)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPLoader.get_closest_cubemap_texture", "LPoint3f");
  }
  Texture *return_value = ((*local_this).get_closest_cubemap_texture)(*arg_this);
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_closest_cubemap_texture(const BSPLoader self, const LPoint3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_closest_cubemap_texture_156_comment =
  "C++ Interface:\n"
  "get_closest_cubemap_texture(const BSPLoader self, const LPoint3f pos)\n";
#else
static const char *Dtool_BSPLoader_get_closest_cubemap_texture_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::build_cubemaps(void)
 */
static PyObject *Dtool_BSPLoader_build_cubemaps_157(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.build_cubemaps")) {
    return nullptr;
  }
  // 1-void BSPLoader::build_cubemaps(void)
  ((*local_this).build_cubemaps)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_build_cubemaps_157_comment =
  "C++ Interface:\n"
  "build_cubemaps(const BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_build_cubemaps_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_want_shadows(bool flag)
 */
static PyObject *Dtool_BSPLoader_set_want_shadows_158(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_want_shadows")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_want_shadows(bool flag)
  ((*local_this).set_want_shadows)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_want_shadows(const BSPLoader self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_want_shadows_158_comment =
  "C++ Interface:\n"
  "set_want_shadows(const BSPLoader self, bool flag)\n";
#else
static const char *Dtool_BSPLoader_set_want_shadows_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_shadow_dir(LVector3 const &dir)
 */
static PyObject *Dtool_BSPLoader_set_shadow_dir_159(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_shadow_dir")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_shadow_dir(LVector3 const &dir)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPLoader.set_shadow_dir", "LVector3f");
  }
  ((*local_this).set_shadow_dir)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_dir(const BSPLoader self, const LVector3f dir)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_shadow_dir_159_comment =
  "C++ Interface:\n"
  "set_shadow_dir(const BSPLoader self, const LVector3f dir)\n";
#else
static const char *Dtool_BSPLoader_set_shadow_dir_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BSPLoader::extract_modelnum(int entnum)
 */
static PyObject *Dtool_BSPLoader_extract_modelnum_160(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.extract_modelnum")) {
    return nullptr;
  }
  // 1-int BSPLoader::extract_modelnum(int entnum)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).extract_modelnum)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_modelnum(const BSPLoader self, int entnum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_extract_modelnum_160_comment =
  "C++ Interface:\n"
  "extract_modelnum(const BSPLoader self, int entnum)\n";
#else
static const char *Dtool_BSPLoader_extract_modelnum_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::get_model_bounds(int modelnum, LPoint3 &mins, LPoint3 &maxs)
 */
static PyObject *Dtool_BSPLoader_get_model_bounds_161(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.get_model_bounds")) {
    return nullptr;
  }
  // 1-void BSPLoader::get_model_bounds(int modelnum, LPoint3 &mins, LPoint3 &maxs)
  int param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"modelnum", "mins", "maxs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iOO:get_model_bounds", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3f param2_local;
    LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "BSPLoader.get_model_bounds", "LPoint3f");
    }
    LPoint3f param3_local;
    LPoint3 *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "BSPLoader.get_model_bounds", "LPoint3f");
    }
    ((*local_this).get_model_bounds)((int)param1, *param2_this, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_model_bounds(const BSPLoader self, int modelnum, LPoint3f mins, LPoint3f maxs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_model_bounds_161_comment =
  "C++ Interface:\n"
  "get_model_bounds(const BSPLoader self, int modelnum, LPoint3f mins, LPoint3f maxs)\n";
#else
static const char *Dtool_BSPLoader_get_model_bounds_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_ai(bool ai)
 */
static PyObject *Dtool_BSPLoader_set_ai_162(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_ai")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_ai(bool ai)
  ((*local_this).set_ai)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ai(const BSPLoader self, bool ai)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_ai_162_comment =
  "C++ Interface:\n"
  "set_ai(const BSPLoader self, bool ai)\n";
#else
static const char *Dtool_BSPLoader_set_ai_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPLoader::is_ai(void) const
 */
static PyObject *Dtool_BSPLoader_is_ai_163(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline bool BSPLoader::is_ai(void) const
  bool return_value = ((*(const BSPLoader*)local_this).is_ai)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_is_ai_163_comment =
  "C++ Interface:\n"
  "is_ai(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_is_ai_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BSPLoader::trace_line(LPoint3 const &start, LPoint3 const &end)
 */
static PyObject *Dtool_BSPLoader_trace_line_164(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.trace_line")) {
    return nullptr;
  }
  // 1-bool BSPLoader::trace_line(LPoint3 const &start, LPoint3 const &end)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"start", "end", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:trace_line", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "BSPLoader.trace_line", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "BSPLoader.trace_line", "LPoint3f");
    }
    bool return_value = ((*local_this).trace_line)(*param1_this, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "trace_line(const BSPLoader self, const LPoint3f start, const LPoint3f end)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_trace_line_164_comment =
  "C++ Interface:\n"
  "trace_line(const BSPLoader self, const LPoint3f start, const LPoint3f end)\n";
#else
static const char *Dtool_BSPLoader_trace_line_164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LPoint3 BSPLoader::clip_line(LPoint3 const &start, LPoint3 const &end)
 */
static PyObject *Dtool_BSPLoader_clip_line_165(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.clip_line")) {
    return nullptr;
  }
  // 1-LPoint3 BSPLoader::clip_line(LPoint3 const &start, LPoint3 const &end)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"start", "end", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:clip_line", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "BSPLoader.clip_line", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "BSPLoader.clip_line", "LPoint3f");
    }
    LPoint3 *return_value = new LPoint3(((*local_this).clip_line)(*param1_this, *param2_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clip_line(const BSPLoader self, const LPoint3f start, const LPoint3f end)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_clip_line_165_comment =
  "C++ Interface:\n"
  "clip_line(const BSPLoader self, const LPoint3f start, const LPoint3f end)\n";
#else
static const char *Dtool_BSPLoader_clip_line_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath BSPLoader::get_model(int modelnum) const
 */
static PyObject *Dtool_BSPLoader_get_model_166(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-NodePath BSPLoader::get_model(int modelnum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath(((*(const BSPLoader*)local_this).get_model)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_model(BSPLoader self, int modelnum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_model_166_comment =
  "C++ Interface:\n"
  "get_model(BSPLoader self, int modelnum)\n";
#else
static const char *Dtool_BSPLoader_get_model_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BSPLoader::find_leaf(LPoint3 const &pos, int headnode = 0)
 * inline int BSPLoader::find_leaf(NodePath const &np)
 */
static PyObject *Dtool_BSPLoader_find_leaf_167(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.find_leaf")) {
    return nullptr;
  }
  {
    // -2 int BSPLoader::find_leaf(LPoint3 const &pos, int headnode = 0)
    PyObject *param1;
    int param2 = 0;
    static const char *keyword_list[] = {"pos", "headnode", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:find_leaf", (char **)keyword_list, &param1, &param2)) {
      LPoint3 const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
      if (param1_this != nullptr) {
        int return_value = ((*local_this).find_leaf)(*param1_this, (int)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline int BSPLoader::find_leaf(NodePath const &np)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "np")) {
      NodePath const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
      if (param1_this != nullptr) {
        int return_value = ((*local_this).find_leaf)(*param1_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
  }

  {
    // -2 int BSPLoader::find_leaf(LPoint3 const &pos, int headnode = 0)
    PyObject *param1;
    int param2 = 0;
    static const char *keyword_list[] = {"pos", "headnode", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:find_leaf", (char **)keyword_list, &param1, &param2)) {
      LPoint3f param1_local;
      LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
      if ((param1_this != nullptr)) {
        int return_value = ((*local_this).find_leaf)(*param1_this, (int)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline int BSPLoader::find_leaf(NodePath const &np)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_leaf(const BSPLoader self, const LPoint3f pos, int headnode)\n"
      "find_leaf(const BSPLoader self, const NodePath np)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_find_leaf_167_comment =
  "C++ Interface:\n"
  "find_leaf(const BSPLoader self, const LPoint3f pos, int headnode)\n"
  "find_leaf(const BSPLoader self, const NodePath np)\n";
#else
static const char *Dtool_BSPLoader_find_leaf_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BSPLoader::find_node(LPoint3 const &pos)
 */
static PyObject *Dtool_BSPLoader_find_node_168(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.find_node")) {
    return nullptr;
  }
  // 1-int BSPLoader::find_node(LPoint3 const &pos)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPLoader.find_node", "LPoint3f");
  }
  int return_value = ((*local_this).find_node)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_node(const BSPLoader self, const LPoint3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_find_node_168_comment =
  "C++ Interface:\n"
  "find_node(const BSPLoader self, const LPoint3f pos)\n";
#else
static const char *Dtool_BSPLoader_find_node_168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BSPLoader::is_cluster_visible(int curr_cluster, int cluster) const
 */
static PyObject *Dtool_BSPLoader_is_cluster_visible_169(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-bool BSPLoader::is_cluster_visible(int curr_cluster, int cluster) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"curr_cluster", "cluster", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:is_cluster_visible", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const BSPLoader*)local_this).is_cluster_visible)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_cluster_visible(BSPLoader self, int curr_cluster, int cluster)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_is_cluster_visible_169_comment =
  "C++ Interface:\n"
  "is_cluster_visible(BSPLoader self, int curr_cluster, int cluster)\n";
#else
static const char *Dtool_BSPLoader_is_cluster_visible_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BSPLoader::pvs_bounds_test(GeometricBoundingVolume const *bounds, unsigned int required_leaf_flags = 0)
 */
static PyObject *Dtool_BSPLoader_pvs_bounds_test_170(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.pvs_bounds_test")) {
    return nullptr;
  }
  // 1-bool BSPLoader::pvs_bounds_test(GeometricBoundingVolume const *bounds, unsigned int required_leaf_flags = 0)
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"bounds", "required_leaf_flags", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:pvs_bounds_test", (char **)keyword_list, &param1, &param2)) {
    GeometricBoundingVolume const *param1_this = (GeometricBoundingVolume *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GeometricBoundingVolume, 1, "BSPLoader.pvs_bounds_test", true, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != nullptr) {
      bool return_value = ((*local_this).pvs_bounds_test)(param1_this, (unsigned int)param2);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pvs_bounds_test(const BSPLoader self, const GeometricBoundingVolume bounds, int required_leaf_flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_pvs_bounds_test_170_comment =
  "C++ Interface:\n"
  "pvs_bounds_test(const BSPLoader self, const GeometricBoundingVolume bounds, int required_leaf_flags)\n";
#else
static const char *Dtool_BSPLoader_pvs_bounds_test_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< GeometricBoundingVolume > BSPLoader::make_net_bounds(TransformState const *net_transform, GeometricBoundingVolume const *original)
 */
static PyObject *Dtool_BSPLoader_make_net_bounds_171(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.make_net_bounds")) {
    return nullptr;
  }
  // 1-ConstPointerTo< GeometricBoundingVolume > BSPLoader::make_net_bounds(TransformState const *net_transform, GeometricBoundingVolume const *original)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"net_transform", "original", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make_net_bounds", (char **)keyword_list, &param1, &param2)) {
    TransformState const *param1_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TransformState, 1, "BSPLoader.make_net_bounds", true, true);
    GeometricBoundingVolume const *param2_this = (GeometricBoundingVolume *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GeometricBoundingVolume, 2, "BSPLoader.make_net_bounds", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ConstPointerTo< GeometricBoundingVolume > return_value = ((*local_this).make_net_bounds)(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      GeometricBoundingVolume const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeometricBoundingVolume, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_net_bounds(const BSPLoader self, const TransformState net_transform, const GeometricBoundingVolume original)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_make_net_bounds_171_comment =
  "C++ Interface:\n"
  "make_net_bounds(const BSPLoader self, const TransformState net_transform, const GeometricBoundingVolume original)\n";
#else
static const char *Dtool_BSPLoader_make_net_bounds_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPLoader::has_active_level(void) const
 */
static PyObject *Dtool_BSPLoader_has_active_level_172(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline bool BSPLoader::has_active_level(void) const
  bool return_value = ((*(const BSPLoader*)local_this).has_active_level)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_has_active_level_172_comment =
  "C++ Interface:\n"
  "has_active_level(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_has_active_level_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPLoader::has_visibility(void) const
 */
static PyObject *Dtool_BSPLoader_has_visibility_173(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline bool BSPLoader::has_visibility(void) const
  bool return_value = ((*(const BSPLoader*)local_this).has_visibility)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_has_visibility_173_comment =
  "C++ Interface:\n"
  "has_visibility(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_has_visibility_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::cleanup(bool is_transition = false)
 */
static PyObject *Dtool_BSPLoader_cleanup_174(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.cleanup")) {
    return nullptr;
  }
  // 1-void BSPLoader::cleanup(bool is_transition = false)
  PyObject *param1 = Py_False;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "is_transition")) {
    ((*local_this).cleanup)((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cleanup(const BSPLoader self, bool is_transition)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_cleanup_174_comment =
  "C++ Interface:\n"
  "cleanup(const BSPLoader self, bool is_transition)\n";
#else
static const char *Dtool_BSPLoader_cleanup_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath BSPLoader::get_result(void) const
 */
static PyObject *Dtool_BSPLoader_get_result_175(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline NodePath BSPLoader::get_result(void) const
  NodePath *return_value = new NodePath(((*(const BSPLoader*)local_this).get_result)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_result_175_comment =
  "C++ Interface:\n"
  "get_result(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_result_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BSPLoader::set_current_leaf(int leaf)
 */
static PyObject *Dtool_BSPLoader_set_current_leaf_176(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_current_leaf")) {
    return nullptr;
  }
  // 1-inline void BSPLoader::set_current_leaf(int leaf)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_current_leaf)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_current_leaf(const BSPLoader self, int leaf)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_current_leaf_176_comment =
  "C++ Interface:\n"
  "set_current_leaf(const BSPLoader self, int leaf)\n";
#else
static const char *Dtool_BSPLoader_set_current_leaf_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BSPLoader::get_current_leaf(void) const
 */
static PyObject *Dtool_BSPLoader_get_current_leaf_177(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline int BSPLoader::get_current_leaf(void) const
  int return_value = ((*(const BSPLoader*)local_this).get_current_leaf)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_current_leaf_177_comment =
  "C++ Interface:\n"
  "get_current_leaf(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_current_leaf_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BSPLoader::get_num_visleafs(void) const
 */
static PyObject *Dtool_BSPLoader_get_num_visleafs_178(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline int BSPLoader::get_num_visleafs(void) const
  int return_value = ((*(const BSPLoader*)local_this).get_num_visleafs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_num_visleafs_178_comment =
  "C++ Interface:\n"
  "get_num_visleafs(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_num_visleafs_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 BSPLoader::get_leaf_center(int leaf) const
 */
static PyObject *Dtool_BSPLoader_get_leaf_center_179(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline LPoint3 BSPLoader::get_leaf_center(int leaf) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 *return_value = new LPoint3(((*(const BSPLoader*)local_this).get_leaf_center)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_leaf_center(BSPLoader self, int leaf)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_leaf_center_179_comment =
  "C++ Interface:\n"
  "get_leaf_center(BSPLoader self, int leaf)\n";
#else
static const char *Dtool_BSPLoader_get_leaf_center_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LTexCoord BSPLoader::get_lightcoords(int facenum, LVector3 const &point)
 */
static PyObject *Dtool_BSPLoader_get_lightcoords_180(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.get_lightcoords")) {
    return nullptr;
  }
  // 1-LTexCoord BSPLoader::get_lightcoords(int facenum, LVector3 const &point)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"facenum", "point", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_lightcoords", (char **)keyword_list, &param1, &param2)) {
    LVector3f param2_local;
    LVector3 const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "BSPLoader.get_lightcoords", "LVector3f");
    }
    LTexCoord *return_value = new LTexCoord(((*local_this).get_lightcoords)((int)param1, *param2_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_lightcoords(const BSPLoader self, int facenum, const LVector3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_lightcoords_180_comment =
  "C++ Interface:\n"
  "get_lightcoords(const BSPLoader self, int facenum, const LVector3f point)\n";
#else
static const char *Dtool_BSPLoader_get_lightcoords_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void BSPLoader::set_global_ptr(BSPLoader *ptr)
 */
static PyObject *Dtool_BSPLoader_set_global_ptr_181(PyObject *, PyObject *arg) {
  // 1-static void BSPLoader::set_global_ptr(BSPLoader *ptr)
  BSPLoader *arg_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BSPLoader, 0, "BSPLoader.set_global_ptr", false, true);
  if (arg_this != nullptr) {
    (BSPLoader::set_global_ptr)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_global_ptr(BSPLoader ptr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_global_ptr_181_comment =
  "C++ Interface:\n"
  "set_global_ptr(BSPLoader ptr)\n";
#else
static const char *Dtool_BSPLoader_set_global_ptr_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static BSPLoader *BSPLoader::get_global_ptr(void)
 */
static PyObject *Dtool_BSPLoader_get_global_ptr_182(PyObject *, PyObject *) {
  // 1-static BSPLoader *BSPLoader::get_global_ptr(void)
  BSPLoader *return_value = (BSPLoader::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BSPLoader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_global_ptr_182_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n";
#else
static const char *Dtool_BSPLoader_get_global_ptr_182_comment = nullptr;
#endif

static int Dtool_Init_BSPLoader(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_BSPLoader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPLoader) {
    printf("BSPLoader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPLoader *local_this = (BSPLoader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPLoader) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPLoader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPLoader) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BoundingKDOP
 */
/**
 * Python function wrapper for:
 * inline std::size_t BoundingKDOP::get_num_points(void) const
 */
static PyObject *Dtool_BoundingKDOP_get_num_points_187(PyObject *self, PyObject *) {
  BoundingKDOP *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingKDOP)) {
    return nullptr;
  }
  // 1-inline std::size_t BoundingKDOP::get_num_points(void) const
  std::size_t return_value = ((*(const BoundingKDOP*)local_this).get_num_points)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingKDOP_get_num_points_187_comment =
  "C++ Interface:\n"
  "get_num_points(BoundingKDOP self)\n";
#else
static const char *Dtool_BoundingKDOP_get_num_points_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 BoundingKDOP::get_point(int n) const
 */
static PyObject *Dtool_BoundingKDOP_get_point_188(PyObject *self, PyObject *arg) {
  BoundingKDOP *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingKDOP)) {
    return nullptr;
  }
  // 1-inline LPoint3 BoundingKDOP::get_point(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 *return_value = new LPoint3(((*(const BoundingKDOP*)local_this).get_point)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(BoundingKDOP self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BoundingKDOP_get_point_188_comment =
  "C++ Interface:\n"
  "get_point(BoundingKDOP self, int n)\n";
#else
static const char *Dtool_BoundingKDOP_get_point_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t BoundingKDOP::get_num_planes(void) const
 */
static PyObject *Dtool_BoundingKDOP_get_num_planes_189(PyObject *self, PyObject *) {
  BoundingKDOP *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingKDOP)) {
    return nullptr;
  }
  // 1-inline std::size_t BoundingKDOP::get_num_planes(void) const
  std::size_t return_value = ((*(const BoundingKDOP*)local_this).get_num_planes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingKDOP_get_num_planes_189_comment =
  "C++ Interface:\n"
  "get_num_planes(BoundingKDOP self)\n";
#else
static const char *Dtool_BoundingKDOP_get_num_planes_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPlane BoundingKDOP::get_plane(int n) const
 */
static PyObject *Dtool_BoundingKDOP_get_plane_190(PyObject *self, PyObject *arg) {
  BoundingKDOP *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingKDOP)) {
    return nullptr;
  }
  // 1-inline LPlane BoundingKDOP::get_plane(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPlane *return_value = new LPlane(((*(const BoundingKDOP*)local_this).get_plane)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_plane(BoundingKDOP self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BoundingKDOP_get_plane_190_comment =
  "C++ Interface:\n"
  "get_plane(BoundingKDOP self, int n)\n";
#else
static const char *Dtool_BoundingKDOP_get_plane_190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BoundingKDOP::get_class_type(void)
 */
static PyObject *Dtool_BoundingKDOP_get_class_type_191(PyObject *, PyObject *) {
  // 1-static TypeHandle BoundingKDOP::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BoundingKDOP::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingKDOP_get_class_type_191_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BoundingKDOP_get_class_type_191_comment = nullptr;
#endif

static int Dtool_Init_BoundingKDOP(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_BoundingKDOP(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BoundingKDOP) {
    printf("BoundingKDOP ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BoundingKDOP *local_this = (BoundingKDOP *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BoundingKDOP) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_FiniteBoundingVolume) {
    return (FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BoundingKDOP(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BoundingKDOP) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (BoundingKDOP*)other_this;
  }
  if (from_type == Dtool_Ptr_FiniteBoundingVolume) {
    FiniteBoundingVolume* other_this = (FiniteBoundingVolume*)from_this;
    return (BoundingKDOP*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (BoundingKDOP*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BoundingKDOP*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BoundingKDOP*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BoundingKDOP*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CBaseEntity
 */
/**
 * Python function wrapper for:
 * static TypeHandle CBaseEntity::get_class_type(void)
 */
static PyObject *Dtool_CBaseEntity_get_class_type_194(PyObject *, PyObject *) {
  // 1-static TypeHandle CBaseEntity::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CBaseEntity::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CBaseEntity_get_class_type_194_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CBaseEntity_get_class_type_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BSPLoader *CBaseEntity::get_loader(void) const
 */
static PyObject *Dtool_CBaseEntity_get_loader_196(PyObject *self, PyObject *) {
  CBaseEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBaseEntity)) {
    return nullptr;
  }
  // 1-BSPLoader *CBaseEntity::get_loader(void) const
  BSPLoader *return_value = ((*(const CBaseEntity*)local_this).get_loader)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BSPLoader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CBaseEntity_get_loader_196_comment =
  "C++ Interface:\n"
  "get_loader(CBaseEntity self)\n";
#else
static const char *Dtool_CBaseEntity_get_loader_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string CBaseEntity::get_entity_value(std::string const &key) const
 */
static PyObject *Dtool_CBaseEntity_get_entity_value_197(PyObject *self, PyObject *arg) {
  CBaseEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBaseEntity)) {
    return nullptr;
  }
  // 1-inline std::string CBaseEntity::get_entity_value(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    std::string return_value = ((*(const CBaseEntity*)local_this).get_entity_value)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value(CBaseEntity self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CBaseEntity_get_entity_value_197_comment =
  "C++ Interface:\n"
  "get_entity_value(CBaseEntity self, str key)\n";
#else
static const char *Dtool_CBaseEntity_get_entity_value_197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3 CBaseEntity::get_entity_value_vector(std::string const &key) const
 */
static PyObject *Dtool_CBaseEntity_get_entity_value_vector_198(PyObject *self, PyObject *arg) {
  CBaseEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBaseEntity)) {
    return nullptr;
  }
  // 1-LVector3 CBaseEntity::get_entity_value_vector(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    LVector3 *return_value = new LVector3(((*(const CBaseEntity*)local_this).get_entity_value_vector)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value_vector(CBaseEntity self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CBaseEntity_get_entity_value_vector_198_comment =
  "C++ Interface:\n"
  "get_entity_value_vector(CBaseEntity self, str key)\n";
#else
static const char *Dtool_CBaseEntity_get_entity_value_vector_198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LColor CBaseEntity::get_entity_value_color(std::string const &key, bool scale = true) const
 */
static PyObject *Dtool_CBaseEntity_get_entity_value_color_199(PyObject *self, PyObject *args, PyObject *kwds) {
  CBaseEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBaseEntity)) {
    return nullptr;
  }
  // 1-LColor CBaseEntity::get_entity_value_color(std::string const &key, bool scale = true) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2 = Py_True;
  static const char *keyword_list[] = {"key", "scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|O:get_entity_value_color", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    LColor *return_value = new LColor(((*(const CBaseEntity*)local_this).get_entity_value_color)(std::string(param1_str, param1_len), (PyObject_IsTrue(param2) != 0)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value_color(CBaseEntity self, str key, bool scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CBaseEntity_get_entity_value_color_199_comment =
  "C++ Interface:\n"
  "get_entity_value_color(CBaseEntity self, str key, bool scale)\n";
#else
static const char *Dtool_CBaseEntity_get_entity_value_color_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string CBaseEntity::get_classname(void) const
 */
static PyObject *Dtool_CBaseEntity_get_classname_200(PyObject *self, PyObject *) {
  CBaseEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBaseEntity)) {
    return nullptr;
  }
  // 1-inline std::string CBaseEntity::get_classname(void) const
  std::string return_value = ((*(const CBaseEntity*)local_this).get_classname)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CBaseEntity_get_classname_200_comment =
  "C++ Interface:\n"
  "get_classname(CBaseEntity self)\n";
#else
static const char *Dtool_CBaseEntity_get_classname_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string CBaseEntity::get_targetname(void) const
 */
static PyObject *Dtool_CBaseEntity_get_targetname_201(PyObject *self, PyObject *) {
  CBaseEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBaseEntity)) {
    return nullptr;
  }
  // 1-inline std::string CBaseEntity::get_targetname(void) const
  std::string return_value = ((*(const CBaseEntity*)local_this).get_targetname)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CBaseEntity_get_targetname_201_comment =
  "C++ Interface:\n"
  "get_targetname(CBaseEntity self)\n";
#else
static const char *Dtool_CBaseEntity_get_targetname_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CBaseEntity::get_bsp_entnum(void) const
 */
static PyObject *Dtool_CBaseEntity_get_bsp_entnum_202(PyObject *self, PyObject *) {
  CBaseEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBaseEntity)) {
    return nullptr;
  }
  // 1-inline int CBaseEntity::get_bsp_entnum(void) const
  int return_value = ((*(const CBaseEntity*)local_this).get_bsp_entnum)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CBaseEntity_get_bsp_entnum_202_comment =
  "C++ Interface:\n"
  "get_bsp_entnum(CBaseEntity self)\n";
#else
static const char *Dtool_CBaseEntity_get_bsp_entnum_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CBaseEntity::CBaseEntity(void)
 * inline CBaseEntity::CBaseEntity(CBaseEntity const &) = default
 */
static int Dtool_Init_CBaseEntity(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CBaseEntity() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CBaseEntity::CBaseEntity(void)
      CBaseEntity *return_value = new CBaseEntity();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBaseEntity, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CBaseEntity::CBaseEntity(CBaseEntity const &) = default
      CBaseEntity const *arg_this = (CBaseEntity *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CBaseEntity, 0, "CBaseEntity.CBaseEntity", true, true);
      if (arg_this != nullptr) {
        CBaseEntity *return_value = new CBaseEntity(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBaseEntity, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CBaseEntity() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CBaseEntity()\n"
      "CBaseEntity(const CBaseEntity param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CBaseEntity(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CBaseEntity) {
    printf("CBaseEntity ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CBaseEntity *local_this = (CBaseEntity *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CBaseEntity) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CBaseEntity(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CBaseEntity) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CBaseEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CBaseEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CBaseEntity*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CPointEntity
 */
/**
 * Python function wrapper for:
 * static TypeHandle CPointEntity::get_class_type(void)
 */
static PyObject *Dtool_CPointEntity_get_class_type_205(PyObject *, PyObject *) {
  // 1-static TypeHandle CPointEntity::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CPointEntity::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CPointEntity_get_class_type_205_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CPointEntity_get_class_type_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LPoint3 CPointEntity::get_origin(void) const
 */
static PyObject *Dtool_CPointEntity_get_origin_207(PyObject *self, PyObject *) {
  CPointEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CPointEntity)) {
    return nullptr;
  }
  // 1-LPoint3 CPointEntity::get_origin(void) const
  LPoint3 *return_value = new LPoint3(((*(const CPointEntity*)local_this).get_origin)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CPointEntity_get_origin_207_comment =
  "C++ Interface:\n"
  "get_origin(CPointEntity self)\n";
#else
static const char *Dtool_CPointEntity_get_origin_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3 CPointEntity::get_angles(void) const
 */
static PyObject *Dtool_CPointEntity_get_angles_208(PyObject *self, PyObject *) {
  CPointEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CPointEntity)) {
    return nullptr;
  }
  // 1-LVector3 CPointEntity::get_angles(void) const
  LVector3 *return_value = new LVector3(((*(const CPointEntity*)local_this).get_angles)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CPointEntity_get_angles_208_comment =
  "C++ Interface:\n"
  "get_angles(CPointEntity self)\n";
#else
static const char *Dtool_CPointEntity_get_angles_208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CPointEntity::CPointEntity(void)
 * inline CPointEntity::CPointEntity(CPointEntity const &) = default
 */
static int Dtool_Init_CPointEntity(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CPointEntity() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CPointEntity::CPointEntity(void)
      CPointEntity *return_value = new CPointEntity();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CPointEntity, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CPointEntity::CPointEntity(CPointEntity const &) = default
      CPointEntity const *arg_this = (CPointEntity *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CPointEntity, 0, "CPointEntity.CPointEntity", true, true);
      if (arg_this != nullptr) {
        CPointEntity *return_value = new CPointEntity(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CPointEntity, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CPointEntity() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CPointEntity()\n"
      "CPointEntity(const CPointEntity param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CPointEntity(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CPointEntity) {
    printf("CPointEntity ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CPointEntity *local_this = (CPointEntity *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CPointEntity) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CBaseEntity) {
    return (CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CPointEntity(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CPointEntity) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CBaseEntity) {
    CBaseEntity* other_this = (CBaseEntity*)from_this;
    return (CPointEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CPointEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CPointEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CPointEntity*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CBoundsEntity
 */
/**
 * Python function wrapper for:
 * static TypeHandle CBoundsEntity::get_class_type(void)
 */
static PyObject *Dtool_CBoundsEntity_get_class_type_211(PyObject *, PyObject *) {
  // 1-static TypeHandle CBoundsEntity::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CBoundsEntity::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CBoundsEntity_get_class_type_211_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CBoundsEntity_get_class_type_211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BoundingKDOP *CBoundsEntity::get_bounds(void) const
 */
static PyObject *Dtool_CBoundsEntity_get_bounds_213(PyObject *self, PyObject *) {
  CBoundsEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBoundsEntity)) {
    return nullptr;
  }
  // 1-BoundingKDOP *CBoundsEntity::get_bounds(void) const
  BoundingKDOP *return_value = ((*(const CBoundsEntity*)local_this).get_bounds)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BoundingKDOP, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CBoundsEntity_get_bounds_213_comment =
  "C++ Interface:\n"
  "get_bounds(CBoundsEntity self)\n";
#else
static const char *Dtool_CBoundsEntity_get_bounds_213_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CBoundsEntity::is_inside(LPoint3 const &pos) const
 */
static PyObject *Dtool_CBoundsEntity_is_inside_214(PyObject *self, PyObject *arg) {
  CBoundsEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBoundsEntity)) {
    return nullptr;
  }
  // 1-bool CBoundsEntity::is_inside(LPoint3 const &pos) const
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CBoundsEntity.is_inside", "LPoint3f");
  }
  bool return_value = ((*(const CBoundsEntity*)local_this).is_inside)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_inside(CBoundsEntity self, const LPoint3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CBoundsEntity_is_inside_214_comment =
  "C++ Interface:\n"
  "is_inside(CBoundsEntity self, const LPoint3f pos)\n";
#else
static const char *Dtool_CBoundsEntity_is_inside_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CBoundsEntity::fillin_bounds(LPoint3 &mins, LPoint3 &maxs)
 */
static PyObject *Dtool_CBoundsEntity_fillin_bounds_215(PyObject *self, PyObject *args, PyObject *kwds) {
  CBoundsEntity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CBoundsEntity, (void **)&local_this, "CBoundsEntity.fillin_bounds")) {
    return nullptr;
  }
  // 1-void CBoundsEntity::fillin_bounds(LPoint3 &mins, LPoint3 &maxs)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"mins", "maxs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:fillin_bounds", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CBoundsEntity.fillin_bounds", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CBoundsEntity.fillin_bounds", "LPoint3f");
    }
    ((*local_this).fillin_bounds)(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fillin_bounds(const CBoundsEntity self, LPoint3f mins, LPoint3f maxs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CBoundsEntity_fillin_bounds_215_comment =
  "C++ Interface:\n"
  "fillin_bounds(const CBoundsEntity self, LPoint3f mins, LPoint3f maxs)\n";
#else
static const char *Dtool_CBoundsEntity_fillin_bounds_215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CBoundsEntity::CBoundsEntity(void)
 * inline CBoundsEntity::CBoundsEntity(CBoundsEntity const &) = default
 */
static int Dtool_Init_CBoundsEntity(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CBoundsEntity() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CBoundsEntity::CBoundsEntity(void)
      CBoundsEntity *return_value = new CBoundsEntity();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBoundsEntity, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CBoundsEntity::CBoundsEntity(CBoundsEntity const &) = default
      CBoundsEntity const *arg_this = (CBoundsEntity *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CBoundsEntity, 0, "CBoundsEntity.CBoundsEntity", true, true);
      if (arg_this != nullptr) {
        CBoundsEntity *return_value = new CBoundsEntity(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBoundsEntity, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CBoundsEntity() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CBoundsEntity()\n"
      "CBoundsEntity(const CBoundsEntity param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CBoundsEntity(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CBoundsEntity) {
    printf("CBoundsEntity ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CBoundsEntity *local_this = (CBoundsEntity *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CBoundsEntity) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CBaseEntity) {
    return (CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CBoundsEntity(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CBoundsEntity) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CBaseEntity) {
    CBaseEntity* other_this = (CBaseEntity*)from_this;
    return (CBoundsEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CBoundsEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CBoundsEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CBoundsEntity*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CBrushEntity
 */
/**
 * Python function wrapper for:
 * static TypeHandle CBrushEntity::get_class_type(void)
 */
static PyObject *Dtool_CBrushEntity_get_class_type_218(PyObject *, PyObject *) {
  // 1-static TypeHandle CBrushEntity::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CBrushEntity::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CBrushEntity_get_class_type_218_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CBrushEntity_get_class_type_218_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath CBrushEntity::get_model_np(void) const
 */
static PyObject *Dtool_CBrushEntity_get_model_np_220(PyObject *self, PyObject *) {
  CBrushEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBrushEntity)) {
    return nullptr;
  }
  // 1-NodePath CBrushEntity::get_model_np(void) const
  NodePath *return_value = new NodePath(((*(const CBrushEntity*)local_this).get_model_np)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CBrushEntity_get_model_np_220_comment =
  "C++ Interface:\n"
  "get_model_np(CBrushEntity self)\n";
#else
static const char *Dtool_CBrushEntity_get_model_np_220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CBrushEntity::get_model_bounds(LPoint3 &mins, LPoint3 &maxs)
 */
static PyObject *Dtool_CBrushEntity_get_model_bounds_221(PyObject *self, PyObject *args, PyObject *kwds) {
  CBrushEntity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CBrushEntity, (void **)&local_this, "CBrushEntity.get_model_bounds")) {
    return nullptr;
  }
  // 1-void CBrushEntity::get_model_bounds(LPoint3 &mins, LPoint3 &maxs)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"mins", "maxs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_model_bounds", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CBrushEntity.get_model_bounds", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CBrushEntity.get_model_bounds", "LPoint3f");
    }
    ((*local_this).get_model_bounds)(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_model_bounds(const CBrushEntity self, LPoint3f mins, LPoint3f maxs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CBrushEntity_get_model_bounds_221_comment =
  "C++ Interface:\n"
  "get_model_bounds(const CBrushEntity self, LPoint3f mins, LPoint3f maxs)\n";
#else
static const char *Dtool_CBrushEntity_get_model_bounds_221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CBrushEntity::CBrushEntity(void)
 * inline CBrushEntity::CBrushEntity(CBrushEntity const &) = default
 */
static int Dtool_Init_CBrushEntity(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CBrushEntity() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CBrushEntity::CBrushEntity(void)
      CBrushEntity *return_value = new CBrushEntity();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBrushEntity, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CBrushEntity::CBrushEntity(CBrushEntity const &) = default
      CBrushEntity const *arg_this = (CBrushEntity *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CBrushEntity, 0, "CBrushEntity.CBrushEntity", true, true);
      if (arg_this != nullptr) {
        CBrushEntity *return_value = new CBrushEntity(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBrushEntity, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CBrushEntity() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CBrushEntity()\n"
      "CBrushEntity(const CBrushEntity param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CBrushEntity(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CBrushEntity) {
    printf("CBrushEntity ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CBrushEntity *local_this = (CBrushEntity *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CBrushEntity) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CBaseEntity) {
    return (CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CBrushEntity(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CBrushEntity) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CBaseEntity) {
    CBaseEntity* other_this = (CBaseEntity*)from_this;
    return (CBrushEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CBrushEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CBrushEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CBrushEntity*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShaderPermutations
 */
/**
 * Python function wrapper for:
 * inline void ShaderPermutations::add_permutation(std::string const &key, std::string const &value = "1")
 */
static PyObject *Dtool_ShaderPermutations_add_permutation_225(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderPermutations *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderPermutations, (void **)&local_this, "ShaderPermutations.add_permutation")) {
    return nullptr;
  }
  // 1-inline void ShaderPermutations::add_permutation(std::string const &key, std::string const &value = "1")
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = "1";
  Py_ssize_t param2_len = 1;
  static const char *keyword_list[] = {"key", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|s#:add_permutation", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    ((*local_this).add_permutation)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_permutation(const ShaderPermutations self, str key, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderPermutations_add_permutation_225_comment =
  "C++ Interface:\n"
  "add_permutation(const ShaderPermutations self, str key, str value)\n";
#else
static const char *Dtool_ShaderPermutations_add_permutation_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ShaderPermutations::complete(void)
 */
static PyObject *Dtool_ShaderPermutations_complete_226(PyObject *self, PyObject *) {
  ShaderPermutations *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderPermutations, (void **)&local_this, "ShaderPermutations.complete")) {
    return nullptr;
  }
  // 1-inline void ShaderPermutations::complete(void)
  ((*local_this).complete)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ShaderPermutations_complete_226_comment =
  "C++ Interface:\n"
  "complete(const ShaderPermutations self)\n";
#else
static const char *Dtool_ShaderPermutations_complete_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ShaderPermutations::add_input(ShaderInput const &inp)
 */
static PyObject *Dtool_ShaderPermutations_add_input_227(PyObject *self, PyObject *arg) {
  ShaderPermutations *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderPermutations, (void **)&local_this, "ShaderPermutations.add_input")) {
    return nullptr;
  }
  // 1-inline void ShaderPermutations::add_input(ShaderInput const &inp)
  ShaderInput const *arg_this = (ShaderInput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShaderInput, 1, "ShaderPermutations.add_input", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_input)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_input(const ShaderPermutations self, const ShaderInput inp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderPermutations_add_input_227_comment =
  "C++ Interface:\n"
  "add_input(const ShaderPermutations self, const ShaderInput inp)\n";
#else
static const char *Dtool_ShaderPermutations_add_input_227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ShaderPermutations::add_flag(int flag)
 */
static PyObject *Dtool_ShaderPermutations_add_flag_228(PyObject *self, PyObject *arg) {
  ShaderPermutations *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderPermutations, (void **)&local_this, "ShaderPermutations.add_flag")) {
    return nullptr;
  }
  // 1-inline void ShaderPermutations::add_flag(int flag)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).add_flag)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_flag(const ShaderPermutations self, int flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderPermutations_add_flag_228_comment =
  "C++ Interface:\n"
  "add_flag(const ShaderPermutations self, int flag)\n";
#else
static const char *Dtool_ShaderPermutations_add_flag_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ShaderPermutations::get_hash(void) const
 */
static PyObject *Dtool_ShaderPermutations_get_hash_229(PyObject *self, PyObject *) {
  ShaderPermutations *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShaderPermutations)) {
    return nullptr;
  }
  // 1-inline std::size_t ShaderPermutations::get_hash(void) const
  std::size_t return_value = ((*(const ShaderPermutations*)local_this).get_hash)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShaderPermutations_get_hash_229_comment =
  "C++ Interface:\n"
  "get_hash(ShaderPermutations self)\n";
#else
static const char *Dtool_ShaderPermutations_get_hash_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ShaderPermutations::ShaderPermutations(void)
 */
static int Dtool_Init_ShaderPermutations(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("ShaderPermutations() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ShaderPermutations() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline ShaderPermutations::ShaderPermutations(void)
  ShaderPermutations *return_value = new ShaderPermutations();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderPermutations, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ShaderPermutations()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ShaderPermutations(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShaderPermutations) {
    printf("ShaderPermutations ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShaderPermutations *local_this = (ShaderPermutations *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShaderPermutations) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShaderPermutations(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShaderPermutations) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ShaderPermutations*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShaderSpec
 */
/**
 * Python function wrapper for:
 * void ShaderSpec::read_shader_files(Filename const &vert_file, Filename const &pixel_file, Filename const &geom_file)
 */
static PyObject *Dtool_ShaderSpec_read_shader_files_237(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderSpec, (void **)&local_this, "ShaderSpec.read_shader_files")) {
    return nullptr;
  }
  // 1-void ShaderSpec::read_shader_files(Filename const &vert_file, Filename const &pixel_file, Filename const &geom_file)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"vert_file", "pixel_file", "geom_file", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:read_shader_files", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "ShaderSpec.read_shader_files", "Filename");
    }
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ShaderSpec.read_shader_files", "Filename");
    }
    Filename param3_local;
    Filename const *param3_this = Dtool_Coerce_Filename(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "ShaderSpec.read_shader_files", "Filename");
    }
    ((*local_this).read_shader_files)(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_shader_files(const ShaderSpec self, const Filename vert_file, const Filename pixel_file, const Filename geom_file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderSpec_read_shader_files_237_comment =
  "C++ Interface:\n"
  "read_shader_files(const ShaderSpec self, const Filename vert_file, const Filename pixel_file, const Filename geom_file)\n";
#else
static const char *Dtool_ShaderSpec_read_shader_files_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ShaderSpec::get_class_type(void)
 */
static PyObject *Dtool_ShaderSpec_get_class_type_238(PyObject *, PyObject *) {
  // 1-static TypeHandle ShaderSpec::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ShaderSpec::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderSpec_get_class_type_238_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ShaderSpec_get_class_type_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *ShaderSpec::upcast_to_ReferenceCount(void)
 */
static PyObject *Dtool_ShaderSpec_upcast_to_ReferenceCount_232(PyObject *self, PyObject *) {
  ShaderSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderSpec, (void **)&local_this, "ShaderSpec.upcast_to_ReferenceCount")) {
    return nullptr;
  }
  // 1-ReferenceCount *ShaderSpec::upcast_to_ReferenceCount(void)
  ReferenceCount *return_value = (ReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderSpec_upcast_to_ReferenceCount_232_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(const ShaderSpec self)\n"
  "\n"
  "upcast from ShaderSpec to ReferenceCount";
#else
static const char *Dtool_ShaderSpec_upcast_to_ReferenceCount_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *ShaderSpec::upcast_to_Namable(void)
 */
static PyObject *Dtool_ShaderSpec_upcast_to_Namable_235(PyObject *self, PyObject *) {
  ShaderSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderSpec, (void **)&local_this, "ShaderSpec.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *ShaderSpec::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderSpec_upcast_to_Namable_235_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const ShaderSpec self)\n"
  "\n"
  "upcast from ShaderSpec to Namable";
#else
static const char *Dtool_ShaderSpec_upcast_to_Namable_235_comment = nullptr;
#endif

static int Dtool_Init_ShaderSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_ShaderSpec(PyObject *args, CPT(ShaderSpec) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ShaderSpec)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_ShaderSpec(PyObject *args, PT(ShaderSpec) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ShaderSpec)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ShaderSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShaderSpec) {
    printf("ShaderSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShaderSpec *local_this = (ShaderSpec *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShaderSpec) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShaderSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShaderSpec) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ShaderSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ShaderSpec*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PlanarReflections
 */
/**
 * Python function wrapper for:
 * Texture *PlanarReflections::get_reflection_texture(void) const
 */
static PyObject *Dtool_PlanarReflections_get_reflection_texture_241(PyObject *self, PyObject *) {
  PlanarReflections *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PlanarReflections)) {
    return nullptr;
  }
  // 1-Texture *PlanarReflections::get_reflection_texture(void) const
  Texture *return_value = ((*(const PlanarReflections*)local_this).get_reflection_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PlanarReflections_get_reflection_texture_241_comment =
  "C++ Interface:\n"
  "get_reflection_texture(PlanarReflections self)\n";
#else
static const char *Dtool_PlanarReflections_get_reflection_texture_241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PlanarReflections::PlanarReflections(PlanarReflections const &) = default
 */
static int Dtool_Init_PlanarReflections(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("PlanarReflections() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline PlanarReflections::PlanarReflections(PlanarReflections const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    PlanarReflections const *param0_this = (PlanarReflections *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PlanarReflections, 0, "PlanarReflections.PlanarReflections", true, true);
    if (param0_this != nullptr) {
      PlanarReflections *return_value = new PlanarReflections(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PlanarReflections, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PlanarReflections(const PlanarReflections param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PlanarReflections(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PlanarReflections) {
    printf("PlanarReflections ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PlanarReflections *local_this = (PlanarReflections *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PlanarReflections) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PlanarReflections(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PlanarReflections) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PlanarReflections*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPShaderGenerator
 */
/**
 * Python function wrapper for:
 * void BSPShaderGenerator::set_sun_light(NodePath const &np)
 */
static PyObject *Dtool_BSPShaderGenerator_set_sun_light_250(PyObject *self, PyObject *arg) {
  BSPShaderGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPShaderGenerator, (void **)&local_this, "BSPShaderGenerator.set_sun_light")) {
    return nullptr;
  }
  // 1-void BSPShaderGenerator::set_sun_light(NodePath const &np)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "BSPShaderGenerator.set_sun_light", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_sun_light)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sun_light(const BSPShaderGenerator self, const NodePath np)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_set_sun_light_250_comment =
  "C++ Interface:\n"
  "set_sun_light(const BSPShaderGenerator self, const NodePath np)\n";
#else
static const char *Dtool_BSPShaderGenerator_set_sun_light_250_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPShaderGenerator::add_shader(PointerTo< ShaderSpec > spec)
 */
static PyObject *Dtool_BSPShaderGenerator_add_shader_251(PyObject *self, PyObject *arg) {
  BSPShaderGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPShaderGenerator, (void **)&local_this, "BSPShaderGenerator.add_shader")) {
    return nullptr;
  }
  // 1-void BSPShaderGenerator::add_shader(PointerTo< ShaderSpec > spec)
  PT(ShaderSpec) arg_this;
  if (!Dtool_Coerce_ShaderSpec(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPShaderGenerator.add_shader", "ShaderSpec");
  }
  ((*local_this).add_shader)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_shader(const BSPShaderGenerator self, ShaderSpec spec)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_add_shader_251_comment =
  "C++ Interface:\n"
  "add_shader(const BSPShaderGenerator self, ShaderSpec spec)\n";
#else
static const char *Dtool_BSPShaderGenerator_add_shader_251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 BSPShaderGenerator::get_sun_vector(void) const
 */
static PyObject *Dtool_BSPShaderGenerator_get_sun_vector_252(PyObject *self, PyObject *) {
  BSPShaderGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPShaderGenerator)) {
    return nullptr;
  }
  // 1-inline LVector3 BSPShaderGenerator::get_sun_vector(void) const
  LVector3 *return_value = new LVector3(((*(const BSPShaderGenerator*)local_this).get_sun_vector)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_get_sun_vector_252_comment =
  "C++ Interface:\n"
  "get_sun_vector(BSPShaderGenerator self)\n";
#else
static const char *Dtool_BSPShaderGenerator_get_sun_vector_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPShaderGenerator::has_shadow_sunlight(void) const
 */
static PyObject *Dtool_BSPShaderGenerator_has_shadow_sunlight_253(PyObject *self, PyObject *) {
  BSPShaderGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPShaderGenerator)) {
    return nullptr;
  }
  // 1-inline bool BSPShaderGenerator::has_shadow_sunlight(void) const
  bool return_value = ((*(const BSPShaderGenerator*)local_this).has_shadow_sunlight)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_has_shadow_sunlight_253_comment =
  "C++ Interface:\n"
  "has_shadow_sunlight(BSPShaderGenerator self)\n";
#else
static const char *Dtool_BSPShaderGenerator_has_shadow_sunlight_253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture *BSPShaderGenerator::get_pssm_array_texture(void) const
 */
static PyObject *Dtool_BSPShaderGenerator_get_pssm_array_texture_254(PyObject *self, PyObject *) {
  BSPShaderGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPShaderGenerator)) {
    return nullptr;
  }
  // 1-inline Texture *BSPShaderGenerator::get_pssm_array_texture(void) const
  Texture *return_value = ((*(const BSPShaderGenerator*)local_this).get_pssm_array_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_get_pssm_array_texture_254_comment =
  "C++ Interface:\n"
  "get_pssm_array_texture(BSPShaderGenerator self)\n";
#else
static const char *Dtool_BSPShaderGenerator_get_pssm_array_texture_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath BSPShaderGenerator::get_camera(void) const
 */
static PyObject *Dtool_BSPShaderGenerator_get_camera_256(PyObject *self, PyObject *) {
  BSPShaderGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPShaderGenerator)) {
    return nullptr;
  }
  // 1-inline NodePath BSPShaderGenerator::get_camera(void) const
  NodePath *return_value = new NodePath(((*(const BSPShaderGenerator*)local_this).get_camera)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_get_camera_256_comment =
  "C++ Interface:\n"
  "get_camera(BSPShaderGenerator self)\n";
#else
static const char *Dtool_BSPShaderGenerator_get_camera_256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath BSPShaderGenerator::get_render(void) const
 */
static PyObject *Dtool_BSPShaderGenerator_get_render_257(PyObject *self, PyObject *) {
  BSPShaderGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPShaderGenerator)) {
    return nullptr;
  }
  // 1-inline NodePath BSPShaderGenerator::get_render(void) const
  NodePath *return_value = new NodePath(((*(const BSPShaderGenerator*)local_this).get_render)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_get_render_257_comment =
  "C++ Interface:\n"
  "get_render(BSPShaderGenerator self)\n";
#else
static const char *Dtool_BSPShaderGenerator_get_render_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPShaderGenerator::set_shader_quality(int quality)
 */
static PyObject *Dtool_BSPShaderGenerator_set_shader_quality_258(PyObject *self, PyObject *arg) {
  BSPShaderGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPShaderGenerator, (void **)&local_this, "BSPShaderGenerator.set_shader_quality")) {
    return nullptr;
  }
  // 1-void BSPShaderGenerator::set_shader_quality(int quality)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_shader_quality)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shader_quality(const BSPShaderGenerator self, int quality)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_set_shader_quality_258_comment =
  "C++ Interface:\n"
  "set_shader_quality(const BSPShaderGenerator self, int quality)\n";
#else
static const char *Dtool_BSPShaderGenerator_set_shader_quality_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BSPShaderGenerator::get_shader_quality(void) const
 */
static PyObject *Dtool_BSPShaderGenerator_get_shader_quality_259(PyObject *self, PyObject *) {
  BSPShaderGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPShaderGenerator)) {
    return nullptr;
  }
  // 1-inline int BSPShaderGenerator::get_shader_quality(void) const
  int return_value = ((*(const BSPShaderGenerator*)local_this).get_shader_quality)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_get_shader_quality_259_comment =
  "C++ Interface:\n"
  "get_shader_quality(BSPShaderGenerator self)\n";
#else
static const char *Dtool_BSPShaderGenerator_get_shader_quality_259_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BSPShaderGenerator::set_fog(Fog *fog)
 */
static PyObject *Dtool_BSPShaderGenerator_set_fog_260(PyObject *self, PyObject *arg) {
  BSPShaderGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPShaderGenerator, (void **)&local_this, "BSPShaderGenerator.set_fog")) {
    return nullptr;
  }
  // 1-inline void BSPShaderGenerator::set_fog(Fog *fog)
  Fog *arg_this = (Fog *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Fog, 1, "BSPShaderGenerator.set_fog", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_fog)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fog(const BSPShaderGenerator self, Fog fog)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_set_fog_260_comment =
  "C++ Interface:\n"
  "set_fog(const BSPShaderGenerator self, Fog fog)\n";
#else
static const char *Dtool_BSPShaderGenerator_set_fog_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BSPShaderGenerator::clear_fog(void)
 */
static PyObject *Dtool_BSPShaderGenerator_clear_fog_261(PyObject *self, PyObject *) {
  BSPShaderGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPShaderGenerator, (void **)&local_this, "BSPShaderGenerator.clear_fog")) {
    return nullptr;
  }
  // 1-inline void BSPShaderGenerator::clear_fog(void)
  ((*local_this).clear_fog)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_clear_fog_261_comment =
  "C++ Interface:\n"
  "clear_fog(const BSPShaderGenerator self)\n";
#else
static const char *Dtool_BSPShaderGenerator_clear_fog_261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Fog *BSPShaderGenerator::get_fog(void) const
 */
static PyObject *Dtool_BSPShaderGenerator_get_fog_262(PyObject *self, PyObject *) {
  BSPShaderGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPShaderGenerator)) {
    return nullptr;
  }
  // 1-inline Fog *BSPShaderGenerator::get_fog(void) const
  Fog *return_value = ((*(const BSPShaderGenerator*)local_this).get_fog)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Fog, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_get_fog_262_comment =
  "C++ Interface:\n"
  "get_fog(BSPShaderGenerator self)\n";
#else
static const char *Dtool_BSPShaderGenerator_get_fog_262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PTA_LVecBase4f BSPShaderGenerator::get_fog_data(void) const
 */
static PyObject *Dtool_BSPShaderGenerator_get_fog_data_263(PyObject *self, PyObject *) {
  BSPShaderGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPShaderGenerator)) {
    return nullptr;
  }
  // 1-inline PTA_LVecBase4f BSPShaderGenerator::get_fog_data(void) const
  PTA_LVecBase4f *return_value = new PTA_LVecBase4f(((*(const BSPShaderGenerator*)local_this).get_fog_data)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_get_fog_data_263_comment =
  "C++ Interface:\n"
  "get_fog_data(BSPShaderGenerator self)\n";
#else
static const char *Dtool_BSPShaderGenerator_get_fog_data_263_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BSPShaderGenerator::set_exposure_adustment(float exposure)
 */
static PyObject *Dtool_BSPShaderGenerator_set_exposure_adustment_264(PyObject *self, PyObject *arg) {
  BSPShaderGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPShaderGenerator, (void **)&local_this, "BSPShaderGenerator.set_exposure_adustment")) {
    return nullptr;
  }
  // 1-inline void BSPShaderGenerator::set_exposure_adustment(float exposure)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_exposure_adustment)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_exposure_adustment(const BSPShaderGenerator self, float exposure)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_set_exposure_adustment_264_comment =
  "C++ Interface:\n"
  "set_exposure_adustment(const BSPShaderGenerator self, float exposure)\n";
#else
static const char *Dtool_BSPShaderGenerator_set_exposure_adustment_264_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PTA_float BSPShaderGenerator::get_exposure_adjustment(void) const
 */
static PyObject *Dtool_BSPShaderGenerator_get_exposure_adjustment_265(PyObject *self, PyObject *) {
  BSPShaderGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPShaderGenerator)) {
    return nullptr;
  }
  // 1-inline PTA_float BSPShaderGenerator::get_exposure_adjustment(void) const
  PTA_float *return_value = new PTA_float(((*(const BSPShaderGenerator*)local_this).get_exposure_adjustment)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_float, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_get_exposure_adjustment_265_comment =
  "C++ Interface:\n"
  "get_exposure_adjustment(BSPShaderGenerator self)\n";
#else
static const char *Dtool_BSPShaderGenerator_get_exposure_adjustment_265_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsStateGuardian *BSPShaderGenerator::get_gsg(void) const
 */
static PyObject *Dtool_BSPShaderGenerator_get_gsg_266(PyObject *self, PyObject *) {
  BSPShaderGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPShaderGenerator)) {
    return nullptr;
  }
  // 1-inline GraphicsStateGuardian *BSPShaderGenerator::get_gsg(void) const
  GraphicsStateGuardian *return_value = ((*(const BSPShaderGenerator*)local_this).get_gsg)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsStateGuardian, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_get_gsg_266_comment =
  "C++ Interface:\n"
  "get_gsg(BSPShaderGenerator self)\n";
#else
static const char *Dtool_BSPShaderGenerator_get_gsg_266_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsOutput *BSPShaderGenerator::get_output(void) const
 */
static PyObject *Dtool_BSPShaderGenerator_get_output_267(PyObject *self, PyObject *) {
  BSPShaderGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPShaderGenerator)) {
    return nullptr;
  }
  // 1-inline GraphicsOutput *BSPShaderGenerator::get_output(void) const
  GraphicsOutput *return_value = ((*(const BSPShaderGenerator*)local_this).get_output)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_get_output_267_comment =
  "C++ Interface:\n"
  "get_output(BSPShaderGenerator self)\n";
#else
static const char *Dtool_BSPShaderGenerator_get_output_267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PlanarReflections *BSPShaderGenerator::get_planar_reflections(void) const
 */
static PyObject *Dtool_BSPShaderGenerator_get_planar_reflections_268(PyObject *self, PyObject *) {
  BSPShaderGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPShaderGenerator)) {
    return nullptr;
  }
  // 1-inline PlanarReflections *BSPShaderGenerator::get_planar_reflections(void) const
  PlanarReflections *return_value = ((*(const BSPShaderGenerator*)local_this).get_planar_reflections)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PlanarReflections, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_get_planar_reflections_268_comment =
  "C++ Interface:\n"
  "get_planar_reflections(BSPShaderGenerator self)\n";
#else
static const char *Dtool_BSPShaderGenerator_get_planar_reflections_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void BSPShaderGenerator::set_identity_cubemap(Texture *tex)
 */
static PyObject *Dtool_BSPShaderGenerator_set_identity_cubemap_269(PyObject *, PyObject *arg) {
  // 1-static void BSPShaderGenerator::set_identity_cubemap(Texture *tex)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 0, "BSPShaderGenerator.set_identity_cubemap", false, true);
  if (arg_this != nullptr) {
    (BSPShaderGenerator::set_identity_cubemap)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_identity_cubemap(Texture tex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_set_identity_cubemap_269_comment =
  "C++ Interface:\n"
  "set_identity_cubemap(Texture tex)\n";
#else
static const char *Dtool_BSPShaderGenerator_set_identity_cubemap_269_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Texture *BSPShaderGenerator::get_identity_cubemap(void)
 */
static PyObject *Dtool_BSPShaderGenerator_get_identity_cubemap_270(PyObject *, PyObject *) {
  // 1-static Texture *BSPShaderGenerator::get_identity_cubemap(void)
  Texture *return_value = (BSPShaderGenerator::get_identity_cubemap)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_get_identity_cubemap_270_comment =
  "C++ Interface:\n"
  "get_identity_cubemap()\n";
#else
static const char *Dtool_BSPShaderGenerator_get_identity_cubemap_270_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< Shader > BSPShaderGenerator::make_shader(ShaderSpec const *spec, ShaderPermutations const *perms)
 */
static PyObject *Dtool_BSPShaderGenerator_make_shader_271(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< Shader > BSPShaderGenerator::make_shader(ShaderSpec const *spec, ShaderPermutations const *perms)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"spec", "perms", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make_shader", (char **)keyword_list, &param0, &param1)) {
    CPT(ShaderSpec) param0_this;
    if (!Dtool_ConstCoerce_ShaderSpec(param0, param0_this)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "BSPShaderGenerator.make_shader", "ShaderSpec");
    }
    ShaderPermutations const *param1_this = (ShaderPermutations *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ShaderPermutations, 1, "BSPShaderGenerator.make_shader", true, true);
    if (param1_this != nullptr) {
      ConstPointerTo< Shader > return_value = (BSPShaderGenerator::make_shader)(std::move(param0_this), param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      Shader const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Shader, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_shader(const ShaderSpec spec, const ShaderPermutations perms)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_make_shader_271_comment =
  "C++ Interface:\n"
  "make_shader(const ShaderSpec spec, const ShaderPermutations perms)\n";
#else
static const char *Dtool_BSPShaderGenerator_make_shader_271_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPShaderGenerator::update(void)
 */
static PyObject *Dtool_BSPShaderGenerator_update_272(PyObject *self, PyObject *) {
  BSPShaderGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPShaderGenerator, (void **)&local_this, "BSPShaderGenerator.update")) {
    return nullptr;
  }
  // 1-void BSPShaderGenerator::update(void)
  ((*local_this).update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_update_272_comment =
  "C++ Interface:\n"
  "update(const BSPShaderGenerator self)\n";
#else
static const char *Dtool_BSPShaderGenerator_update_272_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BSPShaderGenerator::get_class_type(void)
 */
static PyObject *Dtool_BSPShaderGenerator_get_class_type_273(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPShaderGenerator::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BSPShaderGenerator::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPShaderGenerator_get_class_type_273_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPShaderGenerator_get_class_type_273_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPShaderGenerator::BSPShaderGenerator(BSPShaderGenerator const &) = default
 * BSPShaderGenerator::BSPShaderGenerator(GraphicsOutput *output, GraphicsStateGuardian *gsg, NodePath const &camera, NodePath const &render)
 */
static int Dtool_Init_BSPShaderGenerator(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline BSPShaderGenerator::BSPShaderGenerator(BSPShaderGenerator const &) = default
      CPT(BSPShaderGenerator) arg_this;
      if (!Dtool_ConstCoerce_BSPShaderGenerator(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "BSPShaderGenerator.BSPShaderGenerator", "BSPShaderGenerator");
        return -1;
      }
      BSPShaderGenerator *return_value = new BSPShaderGenerator(*std::move(arg_this));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPShaderGenerator, true, false);
    }
    break;
  case 4:
    {
      // 1-BSPShaderGenerator::BSPShaderGenerator(GraphicsOutput *output, GraphicsStateGuardian *gsg, NodePath const &camera, NodePath const &render)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"output", "gsg", "camera", "render", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:BSPShaderGenerator", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        GraphicsOutput *param0_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsOutput, 0, "BSPShaderGenerator.BSPShaderGenerator", false, true);
        GraphicsStateGuardian *param1_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsStateGuardian, 1, "BSPShaderGenerator.BSPShaderGenerator", false, true);
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "BSPShaderGenerator.BSPShaderGenerator", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "BSPShaderGenerator.BSPShaderGenerator", true, true);
        if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
          BSPShaderGenerator *return_value = new BSPShaderGenerator(param0_this, param1_this, *param2_this, *param3_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPShaderGenerator, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BSPShaderGenerator() takes 1 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPShaderGenerator(const BSPShaderGenerator param0)\n"
      "BSPShaderGenerator(GraphicsOutput output, GraphicsStateGuardian gsg, const NodePath camera, const NodePath render)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BSPShaderGenerator(PyObject *args, CPT(BSPShaderGenerator) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPShaderGenerator)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 4) {
      // 1-BSPShaderGenerator::BSPShaderGenerator(GraphicsOutput *output, GraphicsStateGuardian *gsg, NodePath const &camera, NodePath const &render)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      if (PyArg_UnpackTuple(args, "BSPShaderGenerator", 4, 4, &param0, &param1, &param2, &param3)) {
        GraphicsOutput *param0_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsOutput, 0, "BSPShaderGenerator.BSPShaderGenerator", false, false);
        GraphicsStateGuardian *param1_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsStateGuardian, 1, "BSPShaderGenerator.BSPShaderGenerator", false, false);
        NodePath const *param2_this = nullptr;
        DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_NodePath);
        NodePath const *param3_this = nullptr;
        DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_NodePath);
        if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
          BSPShaderGenerator *return_value = new BSPShaderGenerator(param0_this, param1_this, *param2_this, *param3_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_BSPShaderGenerator(PyObject *args, PT(BSPShaderGenerator) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPShaderGenerator)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 4) {
      // 1-BSPShaderGenerator::BSPShaderGenerator(GraphicsOutput *output, GraphicsStateGuardian *gsg, NodePath const &camera, NodePath const &render)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      if (PyArg_UnpackTuple(args, "BSPShaderGenerator", 4, 4, &param0, &param1, &param2, &param3)) {
        GraphicsOutput *param0_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsOutput, 0, "BSPShaderGenerator.BSPShaderGenerator", false, false);
        GraphicsStateGuardian *param1_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsStateGuardian, 1, "BSPShaderGenerator.BSPShaderGenerator", false, false);
        NodePath const *param2_this = nullptr;
        DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_NodePath);
        NodePath const *param3_this = nullptr;
        DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_NodePath);
        if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
          BSPShaderGenerator *return_value = new BSPShaderGenerator(param0_this, param1_this, *param2_this, *param3_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_BSPShaderGenerator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPShaderGenerator) {
    printf("BSPShaderGenerator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPShaderGenerator *local_this = (BSPShaderGenerator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPShaderGenerator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(ShaderGenerator *) local_this;
  }
  if (requested_type == Dtool_Ptr_ShaderGenerator) {
    return (ShaderGenerator *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(ShaderGenerator *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(ShaderGenerator *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPShaderGenerator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPShaderGenerator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPShaderGenerator*)other_this;
  }
  if (from_type == Dtool_Ptr_ShaderGenerator) {
    ShaderGenerator* other_this = (ShaderGenerator*)from_this;
    return (BSPShaderGenerator*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPShaderGenerator*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BSPShaderGenerator*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPCullTraverser
 */
/**
 * Python function wrapper for:
 * static TypeHandle BSPCullTraverser::get_class_type(void)
 */
static PyObject *Dtool_BSPCullTraverser_get_class_type_277(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPCullTraverser::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BSPCullTraverser::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPCullTraverser_get_class_type_277_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPCullTraverser_get_class_type_277_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPCullTraverser::has_camera_bits(unsigned int bits) const
 */
static PyObject *Dtool_BSPCullTraverser_has_camera_bits_279(PyObject *self, PyObject *arg) {
  BSPCullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPCullTraverser)) {
    return nullptr;
  }
  // 1-inline bool BSPCullTraverser::has_camera_bits(unsigned int bits) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    bool return_value = ((*(const BSPCullTraverser*)local_this).has_camera_bits)((unsigned int)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_camera_bits(BSPCullTraverser self, int bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPCullTraverser_has_camera_bits_279_comment =
  "C++ Interface:\n"
  "has_camera_bits(BSPCullTraverser self, int bits)\n";
#else
static const char *Dtool_BSPCullTraverser_has_camera_bits_279_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPCullTraverser::needs_lighting(void) const
 */
static PyObject *Dtool_BSPCullTraverser_needs_lighting_280(PyObject *self, PyObject *) {
  BSPCullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPCullTraverser)) {
    return nullptr;
  }
  // 1-inline bool BSPCullTraverser::needs_lighting(void) const
  bool return_value = ((*(const BSPCullTraverser*)local_this).needs_lighting)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPCullTraverser_needs_lighting_280_comment =
  "C++ Interface:\n"
  "needs_lighting(BSPCullTraverser self)\n";
#else
static const char *Dtool_BSPCullTraverser_needs_lighting_280_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPCullTraverser::needs_culling(void) const
 */
static PyObject *Dtool_BSPCullTraverser_needs_culling_281(PyObject *self, PyObject *) {
  BSPCullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPCullTraverser)) {
    return nullptr;
  }
  // 1-inline bool BSPCullTraverser::needs_culling(void) const
  bool return_value = ((*(const BSPCullTraverser*)local_this).needs_culling)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPCullTraverser_needs_culling_281_comment =
  "C++ Interface:\n"
  "needs_culling(BSPCullTraverser self)\n";
#else
static const char *Dtool_BSPCullTraverser_needs_culling_281_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int BSPCullTraverser::get_required_leaf_flags(void) const
 */
static PyObject *Dtool_BSPCullTraverser_get_required_leaf_flags_282(PyObject *self, PyObject *) {
  BSPCullTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPCullTraverser)) {
    return nullptr;
  }
  // 1-inline unsigned int BSPCullTraverser::get_required_leaf_flags(void) const
  unsigned int return_value = ((*(const BSPCullTraverser*)local_this).get_required_leaf_flags)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPCullTraverser_get_required_leaf_flags_282_comment =
  "C++ Interface:\n"
  "get_required_leaf_flags(BSPCullTraverser self)\n"
  "\n"
  "/**\n"
  "\t * Returns the flags that must be set on a leaf for it to be\n"
  "\t * rendered by the current camera.\n"
  "\t */";
#else
static const char *Dtool_BSPCullTraverser_get_required_leaf_flags_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPCullTraverser::BSPCullTraverser(BSPCullTraverser const &) = default
 * BSPCullTraverser::BSPCullTraverser(CullTraverser *trav, BSPLoader *loader)
 */
static int Dtool_Init_BSPCullTraverser(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline BSPCullTraverser::BSPCullTraverser(BSPCullTraverser const &) = default
      CPT(BSPCullTraverser) arg_this;
      if (!Dtool_ConstCoerce_BSPCullTraverser(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "BSPCullTraverser.BSPCullTraverser", "BSPCullTraverser");
        return -1;
      }
      BSPCullTraverser *return_value = new BSPCullTraverser(*std::move(arg_this));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPCullTraverser, true, false);
    }
    break;
  case 2:
    {
      // 1-BSPCullTraverser::BSPCullTraverser(CullTraverser *trav, BSPLoader *loader)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"trav", "loader", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:BSPCullTraverser", (char **)keyword_list, &param0, &param1)) {
        CullTraverser *param0_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_CullTraverser, 0, "BSPCullTraverser.BSPCullTraverser", false, true);
        BSPLoader *param1_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BSPLoader, 1, "BSPCullTraverser.BSPCullTraverser", false, true);
        if (param0_this != nullptr && param1_this != nullptr) {
          BSPCullTraverser *return_value = new BSPCullTraverser(param0_this, param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPCullTraverser, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BSPCullTraverser() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPCullTraverser(const BSPCullTraverser param0)\n"
      "BSPCullTraverser(CullTraverser trav, BSPLoader loader)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BSPCullTraverser(PyObject *args, CPT(BSPCullTraverser) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPCullTraverser)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-BSPCullTraverser::BSPCullTraverser(CullTraverser *trav, BSPLoader *loader)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "BSPCullTraverser", 2, 2, &param0, &param1)) {
        CullTraverser *param0_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_CullTraverser, 0, "BSPCullTraverser.BSPCullTraverser", false, false);
        BSPLoader *param1_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BSPLoader, 1, "BSPCullTraverser.BSPCullTraverser", false, false);
        if (param0_this != nullptr && param1_this != nullptr) {
          BSPCullTraverser *return_value = new BSPCullTraverser(param0_this, param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_BSPCullTraverser(PyObject *args, PT(BSPCullTraverser) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPCullTraverser)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-BSPCullTraverser::BSPCullTraverser(CullTraverser *trav, BSPLoader *loader)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "BSPCullTraverser", 2, 2, &param0, &param1)) {
        CullTraverser *param0_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_CullTraverser, 0, "BSPCullTraverser.BSPCullTraverser", false, false);
        BSPLoader *param1_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BSPLoader, 1, "BSPCullTraverser.BSPCullTraverser", false, false);
        if (param0_this != nullptr && param1_this != nullptr) {
          BSPCullTraverser *return_value = new BSPCullTraverser(param0_this, param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_BSPCullTraverser(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPCullTraverser) {
    printf("BSPCullTraverser ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPCullTraverser *local_this = (BSPCullTraverser *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPCullTraverser) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CullTraverser) {
    return (CullTraverser *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CullTraverser *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CullTraverser *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CullTraverser *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPCullTraverser(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPCullTraverser) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CullTraverser) {
    CullTraverser* other_this = (CullTraverser*)from_this;
    return (BSPCullTraverser*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPCullTraverser*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPCullTraverser*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BSPCullTraverser*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPRender
 */
/**
 * Python function wrapper for:
 * static TypeHandle BSPRender::get_class_type(void)
 */
static PyObject *Dtool_BSPRender_get_class_type_285(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPRender::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BSPRender::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPRender_get_class_type_285_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPRender_get_class_type_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPRender::BSPRender(BSPRender const &) = default
 * BSPRender::BSPRender(std::string const &name, BSPLoader *loader)
 */
static int Dtool_Init_BSPRender(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline BSPRender::BSPRender(BSPRender const &) = default
      CPT(BSPRender) arg_this;
      if (!Dtool_ConstCoerce_BSPRender(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "BSPRender.BSPRender", "BSPRender");
        return -1;
      }
      BSPRender *return_value = new BSPRender(*std::move(arg_this));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPRender, true, false);
    }
    break;
  case 2:
    {
      // 1-BSPRender::BSPRender(std::string const &name, BSPLoader *loader)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      static const char *keyword_list[] = {"name", "loader", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:BSPRender", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        BSPLoader *param1_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BSPLoader, 1, "BSPRender.BSPRender", false, true);
        if (param1_this != nullptr) {
          BSPRender *return_value = new BSPRender(std::string(param0_str, param0_len), param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPRender, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BSPRender() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPRender(const BSPRender param0)\n"
      "BSPRender(str name, BSPLoader loader)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BSPRender(PyObject *args, CPT(BSPRender) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPRender)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-BSPRender::BSPRender(std::string const &name, BSPLoader *loader)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:BSPRender", &param0_str, &param0_len, &param1)) {
        BSPLoader *param1_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BSPLoader, 1, "BSPRender.BSPRender", false, false);
        if (param1_this != nullptr) {
          BSPRender *return_value = new BSPRender(std::string(param0_str, param0_len), param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_BSPRender(PyObject *args, PT(BSPRender) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPRender)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-BSPRender::BSPRender(std::string const &name, BSPLoader *loader)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:BSPRender", &param0_str, &param0_len, &param1)) {
        BSPLoader *param1_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BSPLoader, 1, "BSPRender.BSPRender", false, false);
        if (param1_this != nullptr) {
          BSPRender *return_value = new BSPRender(std::string(param0_str, param0_len), param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_BSPRender(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPRender) {
    printf("BSPRender ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPRender *local_this = (BSPRender *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPRender) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPRender(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPRender) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (BSPRender*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (BSPRender*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPRender*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPRender*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BSPRender*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BSPRender*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPRoot
 */
/**
 * Python function wrapper for:
 * static TypeHandle BSPRoot::get_class_type(void)
 */
static PyObject *Dtool_BSPRoot_get_class_type_289(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPRoot::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BSPRoot::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPRoot_get_class_type_289_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPRoot_get_class_type_289_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPRoot::BSPRoot(BSPRoot const &) = default
 * BSPRoot::BSPRoot(std::string const &name)
 */
static int Dtool_Init_BSPRoot(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "BSPRoot() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline BSPRoot::BSPRoot(BSPRoot const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      BSPRoot const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BSPRoot);
      if (param0_this != nullptr) {
        BSPRoot *return_value = new BSPRoot(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPRoot, true, false);
      }
    }
  }

  {
    // -2 BSPRoot::BSPRoot(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:BSPRoot", (char **)keyword_list, &param0_str, &param0_len)) {
      BSPRoot *return_value = new BSPRoot(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPRoot, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline BSPRoot::BSPRoot(BSPRoot const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(BSPRoot) param0_this;
      if (Dtool_ConstCoerce_BSPRoot(param0, param0_this)) {
        BSPRoot *return_value = new BSPRoot(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPRoot, true, false);
      }
    }
  }

  // No coercion possible: BSPRoot::BSPRoot(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPRoot(const BSPRoot param0)\n"
      "BSPRoot(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BSPRoot(PyObject *args, CPT(BSPRoot) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPRoot)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BSPRoot::BSPRoot(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      BSPRoot *return_value = new BSPRoot(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_BSPRoot(PyObject *args, PT(BSPRoot) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPRoot)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BSPRoot::BSPRoot(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      BSPRoot *return_value = new BSPRoot(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_BSPRoot(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPRoot) {
    printf("BSPRoot ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPRoot *local_this = (BSPRoot *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPRoot) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPRoot(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPRoot) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (BSPRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (BSPRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BSPRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BSPRoot*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPProp
 */
/**
 * Python function wrapper for:
 * static TypeHandle BSPProp::get_class_type(void)
 */
static PyObject *Dtool_BSPProp_get_class_type_294(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPProp::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BSPProp::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPProp_get_class_type_294_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPProp_get_class_type_294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPProp::BSPProp(BSPProp const &) = default
 * BSPProp::BSPProp(std::string const &name)
 */
static int Dtool_Init_BSPProp(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "BSPProp() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline BSPProp::BSPProp(BSPProp const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      BSPProp const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BSPProp);
      if (param0_this != nullptr) {
        BSPProp *return_value = new BSPProp(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPProp, true, false);
      }
    }
  }

  {
    // -2 BSPProp::BSPProp(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:BSPProp", (char **)keyword_list, &param0_str, &param0_len)) {
      BSPProp *return_value = new BSPProp(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPProp, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline BSPProp::BSPProp(BSPProp const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(BSPProp) param0_this;
      if (Dtool_ConstCoerce_BSPProp(param0, param0_this)) {
        BSPProp *return_value = new BSPProp(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPProp, true, false);
      }
    }
  }

  // No coercion possible: BSPProp::BSPProp(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPProp(const BSPProp param0)\n"
      "BSPProp(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BSPProp(PyObject *args, CPT(BSPProp) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPProp)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BSPProp::BSPProp(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      BSPProp *return_value = new BSPProp(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_BSPProp(PyObject *args, PT(BSPProp) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPProp)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BSPProp::BSPProp(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      BSPProp *return_value = new BSPProp(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_BSPProp(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPProp) {
    printf("BSPProp ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPProp *local_this = (BSPProp *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPProp) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ModelNode) {
    return (ModelNode *)(ModelRoot *) local_this;
  }
  if (requested_type == Dtool_Ptr_ModelRoot) {
    return (ModelRoot *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(ModelNode *)(ModelRoot *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(ModelNode *)(ModelRoot *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *)(ModelRoot *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *)(ModelRoot *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *)(ModelRoot *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(ModelNode *)(ModelRoot *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPProp(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPProp) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ModelNode) {
    ModelNode* other_this = (ModelNode*)from_this;
    return (BSPProp*)other_this;
  }
  if (from_type == Dtool_Ptr_ModelRoot) {
    ModelRoot* other_this = (ModelRoot*)from_this;
    return (BSPProp*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (BSPProp*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (BSPProp*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPProp*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPProp*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BSPProp*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BSPProp*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPModel
 */
/**
 * Python function wrapper for:
 * static TypeHandle BSPModel::get_class_type(void)
 */
static PyObject *Dtool_BSPModel_get_class_type_299(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPModel::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BSPModel::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPModel_get_class_type_299_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPModel_get_class_type_299_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPModel::BSPModel(BSPModel const &) = default
 * BSPModel::BSPModel(std::string const &name)
 */
static int Dtool_Init_BSPModel(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "BSPModel() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline BSPModel::BSPModel(BSPModel const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      BSPModel const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BSPModel);
      if (param0_this != nullptr) {
        BSPModel *return_value = new BSPModel(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPModel, true, false);
      }
    }
  }

  {
    // -2 BSPModel::BSPModel(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:BSPModel", (char **)keyword_list, &param0_str, &param0_len)) {
      BSPModel *return_value = new BSPModel(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPModel, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline BSPModel::BSPModel(BSPModel const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(BSPModel) param0_this;
      if (Dtool_ConstCoerce_BSPModel(param0, param0_this)) {
        BSPModel *return_value = new BSPModel(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPModel, true, false);
      }
    }
  }

  // No coercion possible: BSPModel::BSPModel(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPModel(const BSPModel param0)\n"
      "BSPModel(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BSPModel(PyObject *args, CPT(BSPModel) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPModel)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BSPModel::BSPModel(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      BSPModel *return_value = new BSPModel(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_BSPModel(PyObject *args, PT(BSPModel) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPModel)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BSPModel::BSPModel(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      BSPModel *return_value = new BSPModel(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_BSPModel(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPModel) {
    printf("BSPModel ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPModel *local_this = (BSPModel *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPModel) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ModelNode) {
    return (ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPModel(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPModel) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ModelNode) {
    ModelNode* other_this = (ModelNode*)from_this;
    return (BSPModel*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (BSPModel*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (BSPModel*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPModel*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPModel*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BSPModel*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BSPModel*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VertexLitGenericSpec
 */
/**
 * Python function wrapper for:
 * VertexLitGenericSpec::VertexLitGenericSpec(void)
 */
static int Dtool_Init_VertexLitGenericSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("VertexLitGenericSpec() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "VertexLitGenericSpec() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-VertexLitGenericSpec::VertexLitGenericSpec(void)
  VertexLitGenericSpec *return_value = new VertexLitGenericSpec();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VertexLitGenericSpec, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VertexLitGenericSpec()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_VertexLitGenericSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VertexLitGenericSpec) {
    printf("VertexLitGenericSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VertexLitGenericSpec *local_this = (VertexLitGenericSpec *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VertexLitGenericSpec) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ShaderSpec) {
    return (ShaderSpec *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VertexLitGenericSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VertexLitGenericSpec) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (VertexLitGenericSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VertexLitGenericSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ShaderSpec) {
    ShaderSpec* other_this = (ShaderSpec*)from_this;
    return (VertexLitGenericSpec*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LightmappedGenericSpec
 */
/**
 * Python function wrapper for:
 * LightmappedGenericSpec::LightmappedGenericSpec(void)
 */
static int Dtool_Init_LightmappedGenericSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("LightmappedGenericSpec() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "LightmappedGenericSpec() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-LightmappedGenericSpec::LightmappedGenericSpec(void)
  LightmappedGenericSpec *return_value = new LightmappedGenericSpec();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LightmappedGenericSpec, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LightmappedGenericSpec()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LightmappedGenericSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LightmappedGenericSpec) {
    printf("LightmappedGenericSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LightmappedGenericSpec *local_this = (LightmappedGenericSpec *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LightmappedGenericSpec) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ShaderSpec) {
    return (ShaderSpec *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LightmappedGenericSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LightmappedGenericSpec) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (LightmappedGenericSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LightmappedGenericSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ShaderSpec) {
    ShaderSpec* other_this = (ShaderSpec*)from_this;
    return (LightmappedGenericSpec*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class UnlitGenericSpec
 */
/**
 * Python function wrapper for:
 * UnlitGenericSpec::UnlitGenericSpec(void)
 */
static int Dtool_Init_UnlitGenericSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("UnlitGenericSpec() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "UnlitGenericSpec() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-UnlitGenericSpec::UnlitGenericSpec(void)
  UnlitGenericSpec *return_value = new UnlitGenericSpec();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnlitGenericSpec, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UnlitGenericSpec()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_UnlitGenericSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_UnlitGenericSpec) {
    printf("UnlitGenericSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  UnlitGenericSpec *local_this = (UnlitGenericSpec *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_UnlitGenericSpec) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ShaderSpec) {
    return (ShaderSpec *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_UnlitGenericSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_UnlitGenericSpec) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (UnlitGenericSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (UnlitGenericSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ShaderSpec) {
    ShaderSpec* other_this = (ShaderSpec*)from_this;
    return (UnlitGenericSpec*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class UnlitNoMatSpec
 */
/**
 * Python function wrapper for:
 * UnlitNoMatSpec::UnlitNoMatSpec(void)
 */
static int Dtool_Init_UnlitNoMatSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("UnlitNoMatSpec() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "UnlitNoMatSpec() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-UnlitNoMatSpec::UnlitNoMatSpec(void)
  UnlitNoMatSpec *return_value = new UnlitNoMatSpec();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnlitNoMatSpec, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UnlitNoMatSpec()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_UnlitNoMatSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_UnlitNoMatSpec) {
    printf("UnlitNoMatSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  UnlitNoMatSpec *local_this = (UnlitNoMatSpec *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_UnlitNoMatSpec) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ShaderSpec) {
    return (ShaderSpec *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_UnlitNoMatSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_UnlitNoMatSpec) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (UnlitNoMatSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (UnlitNoMatSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ShaderSpec) {
    ShaderSpec* other_this = (ShaderSpec*)from_this;
    return (UnlitNoMatSpec*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CSMRenderSpec
 */
/**
 * Python function wrapper for:
 * CSMRenderSpec::CSMRenderSpec(void)
 */
static int Dtool_Init_CSMRenderSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CSMRenderSpec() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CSMRenderSpec() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-CSMRenderSpec::CSMRenderSpec(void)
  CSMRenderSpec *return_value = new CSMRenderSpec();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CSMRenderSpec, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CSMRenderSpec()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CSMRenderSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CSMRenderSpec) {
    printf("CSMRenderSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CSMRenderSpec *local_this = (CSMRenderSpec *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CSMRenderSpec) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ShaderSpec) {
    return (ShaderSpec *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CSMRenderSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CSMRenderSpec) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CSMRenderSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CSMRenderSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ShaderSpec) {
    ShaderSpec* other_this = (ShaderSpec*)from_this;
    return (CSMRenderSpec*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SkyBoxSpec
 */
/**
 * Python function wrapper for:
 * SkyBoxSpec::SkyBoxSpec(void)
 */
static int Dtool_Init_SkyBoxSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("SkyBoxSpec() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "SkyBoxSpec() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-SkyBoxSpec::SkyBoxSpec(void)
  SkyBoxSpec *return_value = new SkyBoxSpec();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SkyBoxSpec, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SkyBoxSpec()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SkyBoxSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SkyBoxSpec) {
    printf("SkyBoxSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SkyBoxSpec *local_this = (SkyBoxSpec *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SkyBoxSpec) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ShaderSpec) {
    return (ShaderSpec *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SkyBoxSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SkyBoxSpec) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SkyBoxSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SkyBoxSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ShaderSpec) {
    ShaderSpec* other_this = (ShaderSpec*)from_this;
    return (SkyBoxSpec*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AmbientBoostEffect
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffect > AmbientBoostEffect::make(void)
 */
static PyObject *Dtool_AmbientBoostEffect_make_322(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderEffect > AmbientBoostEffect::make(void)
  ConstPointerTo< RenderEffect > return_value = (AmbientBoostEffect::make)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderEffect const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AmbientBoostEffect_make_322_comment =
  "C++ Interface:\n"
  "make()\n";
#else
static const char *Dtool_AmbientBoostEffect_make_322_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AmbientBoostEffect::get_class_type(void)
 */
static PyObject *Dtool_AmbientBoostEffect_get_class_type_323(PyObject *, PyObject *) {
  // 1-static TypeHandle AmbientBoostEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AmbientBoostEffect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AmbientBoostEffect_get_class_type_323_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AmbientBoostEffect_get_class_type_323_comment = nullptr;
#endif

static int Dtool_Init_AmbientBoostEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AmbientBoostEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AmbientBoostEffect) {
    printf("AmbientBoostEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AmbientBoostEffect *local_this = (AmbientBoostEffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AmbientBoostEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderEffect) {
    return (RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AmbientBoostEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AmbientBoostEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AmbientBoostEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderEffect) {
    RenderEffect* other_this = (RenderEffect*)from_this;
    return (AmbientBoostEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AmbientBoostEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AmbientBoostEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AmbientBoostEffect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Audio3DManager
 */
/**
 * Python function wrapper for:
 * inline void Audio3DManager::set_distance_factor(PN_stdfloat factor)
 */
static PyObject *Dtool_Audio3DManager_set_distance_factor_327(PyObject *self, PyObject *arg) {
  Audio3DManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Audio3DManager, (void **)&local_this, "Audio3DManager.set_distance_factor")) {
    return nullptr;
  }
  // 1-inline void Audio3DManager::set_distance_factor(PN_stdfloat factor)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_distance_factor)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_distance_factor(const Audio3DManager self, float factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_set_distance_factor_327_comment =
  "C++ Interface:\n"
  "set_distance_factor(const Audio3DManager self, float factor)\n";
#else
static const char *Dtool_Audio3DManager_set_distance_factor_327_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Audio3DManager::get_distance_factor(void) const
 */
static PyObject *Dtool_Audio3DManager_get_distance_factor_328(PyObject *self, PyObject *) {
  Audio3DManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Audio3DManager)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Audio3DManager::get_distance_factor(void) const
  PN_stdfloat return_value = ((*(const Audio3DManager*)local_this).get_distance_factor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_get_distance_factor_328_comment =
  "C++ Interface:\n"
  "get_distance_factor(Audio3DManager self)\n";
#else
static const char *Dtool_Audio3DManager_get_distance_factor_328_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Audio3DManager::set_doppler_factor(PN_stdfloat factor)
 */
static PyObject *Dtool_Audio3DManager_set_doppler_factor_329(PyObject *self, PyObject *arg) {
  Audio3DManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Audio3DManager, (void **)&local_this, "Audio3DManager.set_doppler_factor")) {
    return nullptr;
  }
  // 1-inline void Audio3DManager::set_doppler_factor(PN_stdfloat factor)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_doppler_factor)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_doppler_factor(const Audio3DManager self, float factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_set_doppler_factor_329_comment =
  "C++ Interface:\n"
  "set_doppler_factor(const Audio3DManager self, float factor)\n";
#else
static const char *Dtool_Audio3DManager_set_doppler_factor_329_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Audio3DManager::get_doppler_factor(void) const
 */
static PyObject *Dtool_Audio3DManager_get_doppler_factor_330(PyObject *self, PyObject *) {
  Audio3DManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Audio3DManager)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Audio3DManager::get_doppler_factor(void) const
  PN_stdfloat return_value = ((*(const Audio3DManager*)local_this).get_doppler_factor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_get_doppler_factor_330_comment =
  "C++ Interface:\n"
  "get_doppler_factor(Audio3DManager self)\n";
#else
static const char *Dtool_Audio3DManager_get_doppler_factor_330_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Audio3DManager::set_drop_off_factor(PN_stdfloat factor)
 */
static PyObject *Dtool_Audio3DManager_set_drop_off_factor_331(PyObject *self, PyObject *arg) {
  Audio3DManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Audio3DManager, (void **)&local_this, "Audio3DManager.set_drop_off_factor")) {
    return nullptr;
  }
  // 1-inline void Audio3DManager::set_drop_off_factor(PN_stdfloat factor)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_drop_off_factor)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_drop_off_factor(const Audio3DManager self, float factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_set_drop_off_factor_331_comment =
  "C++ Interface:\n"
  "set_drop_off_factor(const Audio3DManager self, float factor)\n";
#else
static const char *Dtool_Audio3DManager_set_drop_off_factor_331_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Audio3DManager::get_drop_off_factor(void) const
 */
static PyObject *Dtool_Audio3DManager_get_drop_off_factor_332(PyObject *self, PyObject *) {
  Audio3DManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Audio3DManager)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Audio3DManager::get_drop_off_factor(void) const
  PN_stdfloat return_value = ((*(const Audio3DManager*)local_this).get_drop_off_factor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_get_drop_off_factor_332_comment =
  "C++ Interface:\n"
  "get_drop_off_factor(Audio3DManager self)\n";
#else
static const char *Dtool_Audio3DManager_get_drop_off_factor_332_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Audio3DManager::set_sound_min_distance(AudioSound *sound, PN_stdfloat dist)
 */
static PyObject *Dtool_Audio3DManager_set_sound_min_distance_333(PyObject *self, PyObject *args, PyObject *kwds) {
  Audio3DManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Audio3DManager, (void **)&local_this, "Audio3DManager.set_sound_min_distance")) {
    return nullptr;
  }
  // 1-inline void Audio3DManager::set_sound_min_distance(AudioSound *sound, PN_stdfloat dist)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"sound", "dist", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_sound_min_distance", (char **)keyword_list, &param1, &param2)) {
    AudioSound *param1_this = (AudioSound *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AudioSound, 1, "Audio3DManager.set_sound_min_distance", false, true);
    if (param1_this != nullptr) {
      ((*local_this).set_sound_min_distance)(param1_this, (PN_stdfloat)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sound_min_distance(const Audio3DManager self, AudioSound sound, float dist)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_set_sound_min_distance_333_comment =
  "C++ Interface:\n"
  "set_sound_min_distance(const Audio3DManager self, AudioSound sound, float dist)\n";
#else
static const char *Dtool_Audio3DManager_set_sound_min_distance_333_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Audio3DManager::get_sound_min_distance(AudioSound *sound) const
 */
static PyObject *Dtool_Audio3DManager_get_sound_min_distance_334(PyObject *self, PyObject *arg) {
  Audio3DManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Audio3DManager)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Audio3DManager::get_sound_min_distance(AudioSound *sound) const
  AudioSound *arg_this = (AudioSound *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AudioSound, 1, "Audio3DManager.get_sound_min_distance", false, true);
  if (arg_this != nullptr) {
    PN_stdfloat return_value = ((*(const Audio3DManager*)local_this).get_sound_min_distance)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sound_min_distance(Audio3DManager self, AudioSound sound)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_get_sound_min_distance_334_comment =
  "C++ Interface:\n"
  "get_sound_min_distance(Audio3DManager self, AudioSound sound)\n";
#else
static const char *Dtool_Audio3DManager_get_sound_min_distance_334_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Audio3DManager::set_sound_max_distance(AudioSound *sound, PN_stdfloat dist)
 */
static PyObject *Dtool_Audio3DManager_set_sound_max_distance_335(PyObject *self, PyObject *args, PyObject *kwds) {
  Audio3DManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Audio3DManager, (void **)&local_this, "Audio3DManager.set_sound_max_distance")) {
    return nullptr;
  }
  // 1-inline void Audio3DManager::set_sound_max_distance(AudioSound *sound, PN_stdfloat dist)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"sound", "dist", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_sound_max_distance", (char **)keyword_list, &param1, &param2)) {
    AudioSound *param1_this = (AudioSound *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AudioSound, 1, "Audio3DManager.set_sound_max_distance", false, true);
    if (param1_this != nullptr) {
      ((*local_this).set_sound_max_distance)(param1_this, (PN_stdfloat)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sound_max_distance(const Audio3DManager self, AudioSound sound, float dist)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_set_sound_max_distance_335_comment =
  "C++ Interface:\n"
  "set_sound_max_distance(const Audio3DManager self, AudioSound sound, float dist)\n";
#else
static const char *Dtool_Audio3DManager_set_sound_max_distance_335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Audio3DManager::get_sound_max_distance(AudioSound *sound) const
 */
static PyObject *Dtool_Audio3DManager_get_sound_max_distance_336(PyObject *self, PyObject *arg) {
  Audio3DManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Audio3DManager)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Audio3DManager::get_sound_max_distance(AudioSound *sound) const
  AudioSound *arg_this = (AudioSound *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AudioSound, 1, "Audio3DManager.get_sound_max_distance", false, true);
  if (arg_this != nullptr) {
    PN_stdfloat return_value = ((*(const Audio3DManager*)local_this).get_sound_max_distance)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sound_max_distance(Audio3DManager self, AudioSound sound)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_get_sound_max_distance_336_comment =
  "C++ Interface:\n"
  "get_sound_max_distance(Audio3DManager self, AudioSound sound)\n";
#else
static const char *Dtool_Audio3DManager_get_sound_max_distance_336_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Audio3DManager::attach_listener(NodePath const &listener)
 */
static PyObject *Dtool_Audio3DManager_attach_listener_337(PyObject *self, PyObject *arg) {
  Audio3DManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Audio3DManager, (void **)&local_this, "Audio3DManager.attach_listener")) {
    return nullptr;
  }
  // 1-inline void Audio3DManager::attach_listener(NodePath const &listener)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "Audio3DManager.attach_listener", true, true);
  if (arg_this != nullptr) {
    ((*local_this).attach_listener)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_listener(const Audio3DManager self, const NodePath listener)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_attach_listener_337_comment =
  "C++ Interface:\n"
  "attach_listener(const Audio3DManager self, const NodePath listener)\n";
#else
static const char *Dtool_Audio3DManager_attach_listener_337_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Audio3DManager::detach_listener(void)
 */
static PyObject *Dtool_Audio3DManager_detach_listener_338(PyObject *self, PyObject *) {
  Audio3DManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Audio3DManager, (void **)&local_this, "Audio3DManager.detach_listener")) {
    return nullptr;
  }
  // 1-inline void Audio3DManager::detach_listener(void)
  ((*local_this).detach_listener)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_detach_listener_338_comment =
  "C++ Interface:\n"
  "detach_listener(const Audio3DManager self)\n";
#else
static const char *Dtool_Audio3DManager_detach_listener_338_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< AudioSound > Audio3DManager::load_sfx(std::string const &path)
 */
static PyObject *Dtool_Audio3DManager_load_sfx_339(PyObject *self, PyObject *arg) {
  Audio3DManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Audio3DManager, (void **)&local_this, "Audio3DManager.load_sfx")) {
    return nullptr;
  }
  // 1-inline PointerTo< AudioSound > Audio3DManager::load_sfx(std::string const &path)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PointerTo< AudioSound > return_value = ((*local_this).load_sfx)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    AudioSound *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AudioSound, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_sfx(const Audio3DManager self, str path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_load_sfx_339_comment =
  "C++ Interface:\n"
  "load_sfx(const Audio3DManager self, str path)\n";
#else
static const char *Dtool_Audio3DManager_load_sfx_339_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Audio3DManager::attach_sound_to_object(AudioSound *sound, NodePath const &object)
 */
static PyObject *Dtool_Audio3DManager_attach_sound_to_object_340(PyObject *self, PyObject *args, PyObject *kwds) {
  Audio3DManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Audio3DManager, (void **)&local_this, "Audio3DManager.attach_sound_to_object")) {
    return nullptr;
  }
  // 1-void Audio3DManager::attach_sound_to_object(AudioSound *sound, NodePath const &object)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"sound", "object", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:attach_sound_to_object", (char **)keyword_list, &param1, &param2)) {
    AudioSound *param1_this = (AudioSound *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AudioSound, 1, "Audio3DManager.attach_sound_to_object", false, true);
    NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "Audio3DManager.attach_sound_to_object", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).attach_sound_to_object)(param1_this, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_sound_to_object(const Audio3DManager self, AudioSound sound, const NodePath object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_attach_sound_to_object_340_comment =
  "C++ Interface:\n"
  "attach_sound_to_object(const Audio3DManager self, AudioSound sound, const NodePath object)\n";
#else
static const char *Dtool_Audio3DManager_attach_sound_to_object_340_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Audio3DManager::detach_sound(AudioSound *sound)
 */
static PyObject *Dtool_Audio3DManager_detach_sound_341(PyObject *self, PyObject *arg) {
  Audio3DManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Audio3DManager, (void **)&local_this, "Audio3DManager.detach_sound")) {
    return nullptr;
  }
  // 1-void Audio3DManager::detach_sound(AudioSound *sound)
  AudioSound *arg_this = (AudioSound *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AudioSound, 1, "Audio3DManager.detach_sound", false, true);
  if (arg_this != nullptr) {
    ((*local_this).detach_sound)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "detach_sound(const Audio3DManager self, AudioSound sound)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_detach_sound_341_comment =
  "C++ Interface:\n"
  "detach_sound(const Audio3DManager self, AudioSound sound)\n";
#else
static const char *Dtool_Audio3DManager_detach_sound_341_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Audio3DManager::print_audio_digest(void)
 */
static PyObject *Dtool_Audio3DManager_print_audio_digest_342(PyObject *self, PyObject *) {
  Audio3DManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Audio3DManager, (void **)&local_this, "Audio3DManager.print_audio_digest")) {
    return nullptr;
  }
  // 1-void Audio3DManager::print_audio_digest(void)
  ((*local_this).print_audio_digest)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_print_audio_digest_342_comment =
  "C++ Interface:\n"
  "print_audio_digest(const Audio3DManager self)\n";
#else
static const char *Dtool_Audio3DManager_print_audio_digest_342_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Audio3DManager::update(void)
 */
static PyObject *Dtool_Audio3DManager_update_343(PyObject *self, PyObject *) {
  Audio3DManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Audio3DManager, (void **)&local_this, "Audio3DManager.update")) {
    return nullptr;
  }
  // 1-void Audio3DManager::update(void)
  ((*local_this).update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Audio3DManager_update_343_comment =
  "C++ Interface:\n"
  "update(const Audio3DManager self)\n";
#else
static const char *Dtool_Audio3DManager_update_343_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Audio3DManager::Audio3DManager(Audio3DManager const &) = default
 * Audio3DManager::Audio3DManager(AudioManager *mgr, NodePath const &listener_target = NodePath(), NodePath const &root = NodePath())
 */
static int Dtool_Init_Audio3DManager(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 Audio3DManager::Audio3DManager(AudioManager *mgr, NodePath const &listener_target = NodePath(), NodePath const &root = NodePath())
    PyObject *param0;
    PyObject *param1 = nullptr;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"mgr", "listener_target", "root", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:Audio3DManager", (char **)keyword_list, &param0, &param1, &param2)) {
      AudioManager *param0_this = (AudioManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AudioManager, 0, "Audio3DManager.Audio3DManager", false, false);
      NodePath const *param1_this;
      const NodePath &param1_ref = NodePath();
      if (param1 == nullptr) {
        param1_this = &param1_ref;
      } else {
        param1_this = nullptr;
        DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
      }
      NodePath const *param2_this;
      const NodePath &param2_ref = NodePath();
      if (param2 == nullptr) {
        param2_this = &param2_ref;
      } else {
        param2_this = nullptr;
        DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_NodePath);
      }
      if (param0_this != nullptr && (param1 == nullptr || param1_this != nullptr) && (param2 == nullptr || param2_this != nullptr)) {
        Audio3DManager *return_value = new Audio3DManager(param0_this, *param1_this, *param2_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Audio3DManager, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: Audio3DManager::Audio3DManager(AudioManager *mgr, NodePath const &listener_target = NodePath(), NodePath const &root = NodePath())
  {
    // -2 inline Audio3DManager::Audio3DManager(Audio3DManager const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(Audio3DManager) param0_this;
      if (Dtool_ConstCoerce_Audio3DManager(param0, param0_this)) {
        Audio3DManager *return_value = new Audio3DManager(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Audio3DManager, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Audio3DManager(AudioManager mgr, const NodePath listener_target, const NodePath root)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Audio3DManager(PyObject *args, CPT(Audio3DManager) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_Audio3DManager)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Audio3DManager::Audio3DManager(AudioManager *mgr, NodePath const &listener_target, NodePath const &root)
    AudioManager *arg_this = (AudioManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AudioManager, 0, "Audio3DManager.Audio3DManager", false, false);
    if (arg_this != nullptr) {
      Audio3DManager *return_value = new Audio3DManager(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-Audio3DManager::Audio3DManager(AudioManager *mgr, NodePath const &listener_target, NodePath const &root = NodePath())
      PyObject *param0;
      PyObject *param1;
      PyObject *param2 = nullptr;
      if (PyArg_UnpackTuple(args, "Audio3DManager", 2, 3, &param0, &param1, &param2)) {
        AudioManager *param0_this = (AudioManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AudioManager, 0, "Audio3DManager.Audio3DManager", false, false);
        NodePath const *param1_this = nullptr;
        DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
        NodePath const *param2_this;
        const NodePath &param2_ref = NodePath();
        if (param2 == nullptr) {
          param2_this = &param2_ref;
        } else {
          param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_NodePath);
        }
        if (param0_this != nullptr && param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
          Audio3DManager *return_value = new Audio3DManager(param0_this, *param1_this, *param2_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_Audio3DManager(PyObject *args, PT(Audio3DManager) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_Audio3DManager)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Audio3DManager::Audio3DManager(AudioManager *mgr, NodePath const &listener_target, NodePath const &root)
    AudioManager *arg_this = (AudioManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AudioManager, 0, "Audio3DManager.Audio3DManager", false, false);
    if (arg_this != nullptr) {
      Audio3DManager *return_value = new Audio3DManager(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-Audio3DManager::Audio3DManager(AudioManager *mgr, NodePath const &listener_target, NodePath const &root = NodePath())
      PyObject *param0;
      PyObject *param1;
      PyObject *param2 = nullptr;
      if (PyArg_UnpackTuple(args, "Audio3DManager", 2, 3, &param0, &param1, &param2)) {
        AudioManager *param0_this = (AudioManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AudioManager, 0, "Audio3DManager.Audio3DManager", false, false);
        NodePath const *param1_this = nullptr;
        DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
        NodePath const *param2_this;
        const NodePath &param2_ref = NodePath();
        if (param2 == nullptr) {
          param2_this = &param2_ref;
        } else {
          param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_NodePath);
        }
        if (param0_this != nullptr && param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
          Audio3DManager *return_value = new Audio3DManager(param0_this, *param1_this, *param2_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_Audio3DManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Audio3DManager) {
    printf("Audio3DManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Audio3DManager *local_this = (Audio3DManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Audio3DManager) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Audio3DManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Audio3DManager) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Audio3DManager*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CIOLib
 */
/**
 * Python function wrapper for:
 * static void CIOLib::set_pupil_direction(float x, float y, LVector3 &left, LVector3 &right)
 */
static PyObject *Dtool_CIOLib_set_pupil_direction_346(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static void CIOLib::set_pupil_direction(float x, float y, LVector3 &left, LVector3 &right)
  float param0;
  float param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"x", "y", "left", "right", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffOO:set_pupil_direction", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LVector3f param2_local;
    LVector3 *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CIOLib.set_pupil_direction", "LVector3f");
    }
    LVector3f param3_local;
    LVector3 *param3_this = Dtool_Coerce_LVector3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "CIOLib.set_pupil_direction", "LVector3f");
    }
    (CIOLib::set_pupil_direction)((float)param0, (float)param1, *param2_this, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pupil_direction(float x, float y, LVector3f left, LVector3f right)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CIOLib_set_pupil_direction_346_comment =
  "C++ Interface:\n"
  "set_pupil_direction(float x, float y, LVector3f left, LVector3f right)\n";
#else
static const char *Dtool_CIOLib_set_pupil_direction_346_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static LVector2 CIOLib::look_pupils_at(NodePath const &node, LVector3 const &point, NodePath const &eyes)
 */
static PyObject *Dtool_CIOLib_look_pupils_at_347(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static LVector2 CIOLib::look_pupils_at(NodePath const &node, LVector3 const &point, NodePath const &eyes)
  PyObject *param0;
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"node", "point", "eyes", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:look_pupils_at", (char **)keyword_list, &param0, &param1, &param2)) {
    NodePath const *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NodePath, 0, "CIOLib.look_pupils_at", true, true);
    LVector3f param1_local;
    LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CIOLib.look_pupils_at", "LVector3f");
    }
    NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CIOLib.look_pupils_at", true, true);
    if (param0_this != nullptr && param2_this != nullptr) {
      LVector2 *return_value = new LVector2((CIOLib::look_pupils_at)(*param0_this, *param1_this, *param2_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "look_pupils_at(const NodePath node, const LVector3f point, const NodePath eyes)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CIOLib_look_pupils_at_347_comment =
  "C++ Interface:\n"
  "look_pupils_at(const NodePath node, const LVector3f point, const NodePath eyes)\n";
#else
static const char *Dtool_CIOLib_look_pupils_at_347_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CIOLib::CIOLib(void) = default
 * inline CIOLib::CIOLib(CIOLib const &) = default
 */
static int Dtool_Init_CIOLib(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CIOLib() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline CIOLib::CIOLib(void) = default
      CIOLib *return_value = new CIOLib();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CIOLib, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CIOLib::CIOLib(CIOLib const &) = default
      CIOLib const *arg_this = (CIOLib *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CIOLib, 0, "CIOLib.CIOLib", true, true);
      if (arg_this != nullptr) {
        CIOLib *return_value = new CIOLib(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CIOLib, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CIOLib() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CIOLib()\n"
      "CIOLib(const CIOLib param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CIOLib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CIOLib) {
    printf("CIOLib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CIOLib *local_this = (CIOLib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CIOLib) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CIOLib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CIOLib) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DecalModulateSpec
 */
/**
 * Python function wrapper for:
 * DecalModulateSpec::DecalModulateSpec(void)
 */
static int Dtool_Init_DecalModulateSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("DecalModulateSpec() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "DecalModulateSpec() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-DecalModulateSpec::DecalModulateSpec(void)
  DecalModulateSpec *return_value = new DecalModulateSpec();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DecalModulateSpec, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DecalModulateSpec()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DecalModulateSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DecalModulateSpec) {
    printf("DecalModulateSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DecalModulateSpec *local_this = (DecalModulateSpec *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DecalModulateSpec) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(ShaderSpec *)(UnlitGenericSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(ShaderSpec *)(UnlitGenericSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ShaderSpec) {
    return (ShaderSpec *)(UnlitGenericSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_UnlitGenericSpec) {
    return (UnlitGenericSpec *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DecalModulateSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DecalModulateSpec) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (DecalModulateSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DecalModulateSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ShaderSpec) {
    ShaderSpec* other_this = (ShaderSpec*)from_this;
    return (DecalModulateSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_UnlitGenericSpec) {
    UnlitGenericSpec* other_this = (UnlitGenericSpec*)from_this;
    return (DecalModulateSpec*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GlowNode
 */
/**
 * Python function wrapper for:
 * static TypeHandle GlowNode::get_class_type(void)
 */
static PyObject *Dtool_GlowNode_get_class_type_355(PyObject *, PyObject *) {
  // 1-static TypeHandle GlowNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GlowNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GlowNode_get_class_type_355_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GlowNode_get_class_type_355_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GlowNode::GlowNode(GeomNode const &copy, float query_size = ::r_glow_querysize)
 * inline GlowNode::GlowNode(GlowNode const &) = default
 * GlowNode::GlowNode(std::string const &name, float query_size = ::r_glow_querysize)
 */
static int Dtool_Init_GlowNode(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 GlowNode::GlowNode(GeomNode const &copy, float query_size = ::r_glow_querysize)
    PyObject *param0;
    float param1 = ::r_glow_querysize;
    static const char *keyword_list[] = {"copy", "query_size", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:GlowNode", (char **)keyword_list, &param0, &param1)) {
      GeomNode const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomNode);
      if (param0_this != nullptr) {
        GlowNode *return_value = new GlowNode(*param0_this, (float)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GlowNode, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 GlowNode::GlowNode(std::string const &name, float query_size = ::r_glow_querysize)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    float param1 = ::r_glow_querysize;
    static const char *keyword_list[] = {"name", "query_size", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|f:GlowNode", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
      GlowNode *return_value = new GlowNode(std::string(param0_str, param0_len), (float)param1);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GlowNode, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: GlowNode::GlowNode(GeomNode const &copy, float query_size = ::r_glow_querysize)
  // No coercion possible: GlowNode::GlowNode(std::string const &name, float query_size = ::r_glow_querysize)
  {
    // -2 inline GlowNode::GlowNode(GlowNode const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(GlowNode) param0_this;
      if (Dtool_ConstCoerce_GlowNode(param0, param0_this)) {
        GlowNode *return_value = new GlowNode(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GlowNode, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GlowNode(const GeomNode copy, float query_size)\n"
      "GlowNode(str name, float query_size)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_GlowNode(PyObject *args, CPT(GlowNode) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_GlowNode)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 GlowNode::GlowNode(GeomNode const &copy, float query_size)
      GeomNode const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_GeomNode);
      if (arg_this != nullptr) {
        GlowNode *return_value = new GlowNode(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
    }

    {
      // -2 GlowNode::GlowNode(std::string const &name, float query_size)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
        param0_str = nullptr;
      }
#endif
      if (param0_str != nullptr) {
        GlowNode *return_value = new GlowNode(std::string(param0_str, param0_len));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      {
        // -2 GlowNode::GlowNode(GeomNode const &copy, float query_size)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:GlowNode", &param0, &param1)) {
          GeomNode const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomNode);
          if (param0_this != nullptr) {
            GlowNode *return_value = new GlowNode(*param0_this, (float)param1);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 GlowNode::GlowNode(std::string const &name, float query_size)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        float param1;
        if (PyArg_ParseTuple(args, "s#f:GlowNode", &param0_str, &param0_len, &param1)) {
          GlowNode *return_value = new GlowNode(std::string(param0_str, param0_len), (float)param1);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

bool Dtool_Coerce_GlowNode(PyObject *args, PT(GlowNode) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_GlowNode)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 GlowNode::GlowNode(GeomNode const &copy, float query_size)
      GeomNode const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_GeomNode);
      if (arg_this != nullptr) {
        GlowNode *return_value = new GlowNode(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
    }

    {
      // -2 GlowNode::GlowNode(std::string const &name, float query_size)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
        param0_str = nullptr;
      }
#endif
      if (param0_str != nullptr) {
        GlowNode *return_value = new GlowNode(std::string(param0_str, param0_len));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      {
        // -2 GlowNode::GlowNode(GeomNode const &copy, float query_size)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:GlowNode", &param0, &param1)) {
          GeomNode const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GeomNode);
          if (param0_this != nullptr) {
            GlowNode *return_value = new GlowNode(*param0_this, (float)param1);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 GlowNode::GlowNode(std::string const &name, float query_size)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        float param1;
        if (PyArg_ParseTuple(args, "s#f:GlowNode", &param0_str, &param0_len, &param1)) {
          GlowNode *return_value = new GlowNode(std::string(param0_str, param0_len), (float)param1);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

static void *Dtool_UpcastInterface_GlowNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GlowNode) {
    printf("GlowNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GlowNode *local_this = (GlowNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GlowNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_GeomNode) {
    return (GeomNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(GeomNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(GeomNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(GeomNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(GeomNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(GeomNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(GeomNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GlowNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GlowNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_GeomNode) {
    GeomNode* other_this = (GeomNode*)from_this;
    return (GlowNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (GlowNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (GlowNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GlowNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GlowNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GlowNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GlowNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PostProcessEffect
 */
/**
 * Python function wrapper for:
 * static TypeHandle PostProcessEffect::get_class_type(void)
 */
static PyObject *Dtool_PostProcessEffect_get_class_type_363(PyObject *, PyObject *) {
  // 1-static TypeHandle PostProcessEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PostProcessEffect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PostProcessEffect_get_class_type_363_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PostProcessEffect_get_class_type_363_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual Texture *PostProcessEffect::get_final_texture(void) = 0
 */
static PyObject *Dtool_PostProcessEffect_get_final_texture_364(PyObject *self, PyObject *) {
  PostProcessEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessEffect, (void **)&local_this, "PostProcessEffect.get_final_texture")) {
    return nullptr;
  }
  // 1-virtual Texture *PostProcessEffect::get_final_texture(void) = 0
  Texture *return_value = ((*local_this).get_final_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PostProcessEffect_get_final_texture_364_comment =
  "C++ Interface:\n"
  "get_final_texture(const PostProcessEffect self)\n";
#else
static const char *Dtool_PostProcessEffect_get_final_texture_364_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PostProcessEffect::add_pass(PostProcessPass *pass)
 */
static PyObject *Dtool_PostProcessEffect_add_pass_365(PyObject *self, PyObject *arg) {
  PostProcessEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessEffect, (void **)&local_this, "PostProcessEffect.add_pass")) {
    return nullptr;
  }
  // 1-void PostProcessEffect::add_pass(PostProcessPass *pass)
  PT(PostProcessPass) arg_this;
  if (!Dtool_Coerce_PostProcessPass(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PostProcessEffect.add_pass", "PostProcessPass");
  }
  ((*local_this).add_pass)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_pass(const PostProcessEffect self, PostProcessPass pass)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcessEffect_add_pass_365_comment =
  "C++ Interface:\n"
  "add_pass(const PostProcessEffect self, PostProcessPass pass)\n";
#else
static const char *Dtool_PostProcessEffect_add_pass_365_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PostProcessEffect::remove_pass(PostProcessPass *pass)
 */
static PyObject *Dtool_PostProcessEffect_remove_pass_366(PyObject *self, PyObject *arg) {
  PostProcessEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessEffect, (void **)&local_this, "PostProcessEffect.remove_pass")) {
    return nullptr;
  }
  // 1-void PostProcessEffect::remove_pass(PostProcessPass *pass)
  PT(PostProcessPass) arg_this;
  if (!Dtool_Coerce_PostProcessPass(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PostProcessEffect.remove_pass", "PostProcessPass");
  }
  ((*local_this).remove_pass)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_pass(const PostProcessEffect self, PostProcessPass pass)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcessEffect_remove_pass_366_comment =
  "C++ Interface:\n"
  "remove_pass(const PostProcessEffect self, PostProcessPass pass)\n";
#else
static const char *Dtool_PostProcessEffect_remove_pass_366_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PostProcessPass *PostProcessEffect::get_pass(std::string const &name)
 */
static PyObject *Dtool_PostProcessEffect_get_pass_367(PyObject *self, PyObject *arg) {
  PostProcessEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessEffect, (void **)&local_this, "PostProcessEffect.get_pass")) {
    return nullptr;
  }
  // 1-PostProcessPass *PostProcessEffect::get_pass(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PostProcessPass *return_value = ((*local_this).get_pass)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PostProcessPass, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pass(const PostProcessEffect self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcessEffect_get_pass_367_comment =
  "C++ Interface:\n"
  "get_pass(const PostProcessEffect self, str name)\n";
#else
static const char *Dtool_PostProcessEffect_get_pass_367_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PostProcessEffect::setup(void)
 */
static PyObject *Dtool_PostProcessEffect_setup_368(PyObject *self, PyObject *) {
  PostProcessEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessEffect, (void **)&local_this, "PostProcessEffect.setup")) {
    return nullptr;
  }
  // 1-virtual void PostProcessEffect::setup(void)
  ((*local_this).setup)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PostProcessEffect_setup_368_comment =
  "C++ Interface:\n"
  "setup(const PostProcessEffect self)\n";
#else
static const char *Dtool_PostProcessEffect_setup_368_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PostProcessEffect::update(void)
 */
static PyObject *Dtool_PostProcessEffect_update_369(PyObject *self, PyObject *) {
  PostProcessEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessEffect, (void **)&local_this, "PostProcessEffect.update")) {
    return nullptr;
  }
  // 1-virtual void PostProcessEffect::update(void)
  ((*local_this).update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PostProcessEffect_update_369_comment =
  "C++ Interface:\n"
  "update(const PostProcessEffect self)\n";
#else
static const char *Dtool_PostProcessEffect_update_369_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PostProcessEffect::window_event(GraphicsOutput *win)
 */
static PyObject *Dtool_PostProcessEffect_window_event_370(PyObject *self, PyObject *arg) {
  PostProcessEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessEffect, (void **)&local_this, "PostProcessEffect.window_event")) {
    return nullptr;
  }
  // 1-void PostProcessEffect::window_event(GraphicsOutput *win)
  GraphicsOutput *arg_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsOutput, 1, "PostProcessEffect.window_event", false, true);
  if (arg_this != nullptr) {
    ((*local_this).window_event)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "window_event(const PostProcessEffect self, GraphicsOutput win)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcessEffect_window_event_370_comment =
  "C++ Interface:\n"
  "window_event(const PostProcessEffect self, GraphicsOutput win)\n";
#else
static const char *Dtool_PostProcessEffect_window_event_370_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PostProcessEffect::shutdown(void)
 */
static PyObject *Dtool_PostProcessEffect_shutdown_371(PyObject *self, PyObject *) {
  PostProcessEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessEffect, (void **)&local_this, "PostProcessEffect.shutdown")) {
    return nullptr;
  }
  // 1-virtual void PostProcessEffect::shutdown(void)
  ((*local_this).shutdown)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PostProcessEffect_shutdown_371_comment =
  "C++ Interface:\n"
  "shutdown(const PostProcessEffect self)\n";
#else
static const char *Dtool_PostProcessEffect_shutdown_371_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *PostProcessEffect::upcast_to_ReferenceCount(void)
 */
static PyObject *Dtool_PostProcessEffect_upcast_to_ReferenceCount_359(PyObject *self, PyObject *) {
  PostProcessEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessEffect, (void **)&local_this, "PostProcessEffect.upcast_to_ReferenceCount")) {
    return nullptr;
  }
  // 1-ReferenceCount *PostProcessEffect::upcast_to_ReferenceCount(void)
  ReferenceCount *return_value = (ReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PostProcessEffect_upcast_to_ReferenceCount_359_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(const PostProcessEffect self)\n"
  "\n"
  "upcast from PostProcessEffect to ReferenceCount";
#else
static const char *Dtool_PostProcessEffect_upcast_to_ReferenceCount_359_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *PostProcessEffect::upcast_to_Namable(void)
 */
static PyObject *Dtool_PostProcessEffect_upcast_to_Namable_361(PyObject *self, PyObject *) {
  PostProcessEffect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessEffect, (void **)&local_this, "PostProcessEffect.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *PostProcessEffect::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_PostProcessEffect_upcast_to_Namable_361_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const PostProcessEffect self)\n"
  "\n"
  "upcast from PostProcessEffect to Namable";
#else
static const char *Dtool_PostProcessEffect_upcast_to_Namable_361_comment = nullptr;
#endif

static int Dtool_Init_PostProcessEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_PostProcessEffect(PyObject *args, CPT(PostProcessEffect) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PostProcessEffect)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_PostProcessEffect(PyObject *args, PT(PostProcessEffect) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PostProcessEffect)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_PostProcessEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PostProcessEffect) {
    printf("PostProcessEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PostProcessEffect *local_this = (PostProcessEffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PostProcessEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PostProcessEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PostProcessEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PostProcessEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PostProcessEffect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PostProcessPass
 */
/**
 * Python function wrapper for:
 * static TypeHandle PostProcessPass::get_class_type(void)
 */
static PyObject *Dtool_PostProcessPass_get_class_type_379(PyObject *, PyObject *) {
  // 1-static TypeHandle PostProcessPass::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PostProcessPass::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_get_class_type_379_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PostProcessPass_get_class_type_379_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath PostProcessPass::get_quad(void) const
 */
static PyObject *Dtool_PostProcessPass_get_quad_381(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PostProcessPass)) {
    return nullptr;
  }
  // 1-inline NodePath PostProcessPass::get_quad(void) const
  NodePath *return_value = new NodePath(((*(const PostProcessPass*)local_this).get_quad)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_get_quad_381_comment =
  "C++ Interface:\n"
  "get_quad(PostProcessPass self)\n";
#else
static const char *Dtool_PostProcessPass_get_quad_381_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector2i PostProcessPass::get_back_buffer_dimensions(void) const
 */
static PyObject *Dtool_PostProcessPass_get_back_buffer_dimensions_382(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PostProcessPass)) {
    return nullptr;
  }
  // 1-LVector2i PostProcessPass::get_back_buffer_dimensions(void) const
  LVector2i *return_value = new LVector2i(((*(const PostProcessPass*)local_this).get_back_buffer_dimensions)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_get_back_buffer_dimensions_382_comment =
  "C++ Interface:\n"
  "get_back_buffer_dimensions(PostProcessPass self)\n";
#else
static const char *Dtool_PostProcessPass_get_back_buffer_dimensions_382_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath PostProcessPass::get_camera(void) const
 */
static PyObject *Dtool_PostProcessPass_get_camera_383(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PostProcessPass)) {
    return nullptr;
  }
  // 1-inline NodePath PostProcessPass::get_camera(void) const
  NodePath *return_value = new NodePath(((*(const PostProcessPass*)local_this).get_camera)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_get_camera_383_comment =
  "C++ Interface:\n"
  "get_camera(PostProcessPass self)\n";
#else
static const char *Dtool_PostProcessPass_get_camera_383_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PostProcessPass::has_texture_bits(int bits) const
 */
static PyObject *Dtool_PostProcessPass_has_texture_bits_384(PyObject *self, PyObject *arg) {
  PostProcessPass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PostProcessPass)) {
    return nullptr;
  }
  // 1-inline bool PostProcessPass::has_texture_bits(int bits) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const PostProcessPass*)local_this).has_texture_bits)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_texture_bits(PostProcessPass self, int bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_has_texture_bits_384_comment =
  "C++ Interface:\n"
  "has_texture_bits(PostProcessPass self, int bits)\n";
#else
static const char *Dtool_PostProcessPass_has_texture_bits_384_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PostProcessPass::set_div_size(bool div_size, int div)
 */
static PyObject *Dtool_PostProcessPass_set_div_size_385(PyObject *self, PyObject *args, PyObject *kwds) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.set_div_size")) {
    return nullptr;
  }
  // 1-inline void PostProcessPass::set_div_size(bool div_size, int div)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"div_size", "div", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_div_size", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_div_size)((PyObject_IsTrue(param1) != 0), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_div_size(const PostProcessPass self, bool div_size, int div)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_set_div_size_385_comment =
  "C++ Interface:\n"
  "set_div_size(const PostProcessPass self, bool div_size, int div)\n";
#else
static const char *Dtool_PostProcessPass_set_div_size_385_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PostProcessPass::set_forced_size(bool force_size, LVector2i const &forced_size)
 */
static PyObject *Dtool_PostProcessPass_set_forced_size_386(PyObject *self, PyObject *args, PyObject *kwds) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.set_forced_size")) {
    return nullptr;
  }
  // 1-inline void PostProcessPass::set_forced_size(bool force_size, LVector2i const &forced_size)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"force_size", "forced_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_forced_size", (char **)keyword_list, &param1, &param2)) {
    LVector2i param2_local;
    LVector2i const *param2_this = Dtool_Coerce_LVector2i(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PostProcessPass.set_forced_size", "LVector2i");
    }
    ((*local_this).set_forced_size)((PyObject_IsTrue(param1) != 0), *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_forced_size(const PostProcessPass self, bool force_size, const LVector2i forced_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_set_forced_size_386_comment =
  "C++ Interface:\n"
  "set_forced_size(const PostProcessPass self, bool force_size, const LVector2i forced_size)\n";
#else
static const char *Dtool_PostProcessPass_set_forced_size_386_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PostProcessPass::set_framebuffer_properties(FrameBufferProperties const &fbprops)
 */
static PyObject *Dtool_PostProcessPass_set_framebuffer_properties_387(PyObject *self, PyObject *arg) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.set_framebuffer_properties")) {
    return nullptr;
  }
  // 1-inline void PostProcessPass::set_framebuffer_properties(FrameBufferProperties const &fbprops)
  FrameBufferProperties const *arg_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_FrameBufferProperties, 1, "PostProcessPass.set_framebuffer_properties", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_framebuffer_properties)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_framebuffer_properties(const PostProcessPass self, const FrameBufferProperties fbprops)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_set_framebuffer_properties_387_comment =
  "C++ Interface:\n"
  "set_framebuffer_properties(const PostProcessPass self, const FrameBufferProperties fbprops)\n";
#else
static const char *Dtool_PostProcessPass_set_framebuffer_properties_387_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PostProcessPass::set_output_texture_bits(int bits)
 */
static PyObject *Dtool_PostProcessPass_set_output_texture_bits_388(PyObject *self, PyObject *arg) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.set_output_texture_bits")) {
    return nullptr;
  }
  // 1-inline void PostProcessPass::set_output_texture_bits(int bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_output_texture_bits)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_output_texture_bits(const PostProcessPass self, int bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_set_output_texture_bits_388_comment =
  "C++ Interface:\n"
  "set_output_texture_bits(const PostProcessPass self, int bits)\n";
#else
static const char *Dtool_PostProcessPass_set_output_texture_bits_388_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector2i PostProcessPass::get_corrected_size(LVector2i const &size)
 */
static PyObject *Dtool_PostProcessPass_get_corrected_size_389(PyObject *self, PyObject *arg) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.get_corrected_size")) {
    return nullptr;
  }
  // 1-LVector2i PostProcessPass::get_corrected_size(LVector2i const &size)
  LVector2i arg_local;
  LVector2i const *arg_this = Dtool_Coerce_LVector2i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PostProcessPass.get_corrected_size", "LVector2i");
  }
  LVector2i *return_value = new LVector2i(((*local_this).get_corrected_size)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_corrected_size(const PostProcessPass self, const LVector2i size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_get_corrected_size_389_comment =
  "C++ Interface:\n"
  "get_corrected_size(const PostProcessPass self, const LVector2i size)\n";
#else
static const char *Dtool_PostProcessPass_get_corrected_size_389_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Texture *PostProcessPass::get_texture(int bit)
 */
static PyObject *Dtool_PostProcessPass_get_texture_390(PyObject *self, PyObject *arg) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.get_texture")) {
    return nullptr;
  }
  // 1-Texture *PostProcessPass::get_texture(int bit)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    Texture *return_value = ((*local_this).get_texture)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texture(const PostProcessPass self, int bit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_get_texture_390_comment =
  "C++ Interface:\n"
  "get_texture(const PostProcessPass self, int bit)\n";
#else
static const char *Dtool_PostProcessPass_get_texture_390_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture *PostProcessPass::get_color_texture(void)
 */
static PyObject *Dtool_PostProcessPass_get_color_texture_391(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.get_color_texture")) {
    return nullptr;
  }
  // 1-inline Texture *PostProcessPass::get_color_texture(void)
  Texture *return_value = ((*local_this).get_color_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_get_color_texture_391_comment =
  "C++ Interface:\n"
  "get_color_texture(const PostProcessPass self)\n";
#else
static const char *Dtool_PostProcessPass_get_color_texture_391_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture *PostProcessPass::get_depth_texture(void)
 */
static PyObject *Dtool_PostProcessPass_get_depth_texture_392(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.get_depth_texture")) {
    return nullptr;
  }
  // 1-inline Texture *PostProcessPass::get_depth_texture(void)
  Texture *return_value = ((*local_this).get_depth_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_get_depth_texture_392_comment =
  "C++ Interface:\n"
  "get_depth_texture(const PostProcessPass self)\n";
#else
static const char *Dtool_PostProcessPass_get_depth_texture_392_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool PostProcessPass::setup_buffer(void)
 */
static PyObject *Dtool_PostProcessPass_setup_buffer_393(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.setup_buffer")) {
    return nullptr;
  }
  // 1-virtual bool PostProcessPass::setup_buffer(void)
  bool return_value = ((*local_this).setup_buffer)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_setup_buffer_393_comment =
  "C++ Interface:\n"
  "setup_buffer(const PostProcessPass self)\n";
#else
static const char *Dtool_PostProcessPass_setup_buffer_393_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PostProcessPass::setup_textures(void)
 */
static PyObject *Dtool_PostProcessPass_setup_textures_394(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.setup_textures")) {
    return nullptr;
  }
  // 1-virtual void PostProcessPass::setup_textures(void)
  ((*local_this).setup_textures)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_setup_textures_394_comment =
  "C++ Interface:\n"
  "setup_textures(const PostProcessPass self)\n";
#else
static const char *Dtool_PostProcessPass_setup_textures_394_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PostProcessPass::setup_quad(void)
 */
static PyObject *Dtool_PostProcessPass_setup_quad_395(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.setup_quad")) {
    return nullptr;
  }
  // 1-virtual void PostProcessPass::setup_quad(void)
  ((*local_this).setup_quad)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_setup_quad_395_comment =
  "C++ Interface:\n"
  "setup_quad(const PostProcessPass self)\n";
#else
static const char *Dtool_PostProcessPass_setup_quad_395_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PostProcessPass::setup_camera(void)
 */
static PyObject *Dtool_PostProcessPass_setup_camera_396(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.setup_camera")) {
    return nullptr;
  }
  // 1-virtual void PostProcessPass::setup_camera(void)
  ((*local_this).setup_camera)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_setup_camera_396_comment =
  "C++ Interface:\n"
  "setup_camera(const PostProcessPass self)\n";
#else
static const char *Dtool_PostProcessPass_setup_camera_396_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PostProcessPass::setup_region(void)
 */
static PyObject *Dtool_PostProcessPass_setup_region_397(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.setup_region")) {
    return nullptr;
  }
  // 1-virtual void PostProcessPass::setup_region(void)
  ((*local_this).setup_region)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_setup_region_397_comment =
  "C++ Interface:\n"
  "setup_region(const PostProcessPass self)\n";
#else
static const char *Dtool_PostProcessPass_setup_region_397_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PostProcessPass::setup(void)
 */
static PyObject *Dtool_PostProcessPass_setup_398(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.setup")) {
    return nullptr;
  }
  // 1-virtual void PostProcessPass::setup(void)
  ((*local_this).setup)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_setup_398_comment =
  "C++ Interface:\n"
  "setup(const PostProcessPass self)\n";
#else
static const char *Dtool_PostProcessPass_setup_398_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PostProcessPass::update(void)
 */
static PyObject *Dtool_PostProcessPass_update_399(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.update")) {
    return nullptr;
  }
  // 1-virtual void PostProcessPass::update(void)
  ((*local_this).update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_update_399_comment =
  "C++ Interface:\n"
  "update(const PostProcessPass self)\n";
#else
static const char *Dtool_PostProcessPass_update_399_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PostProcessPass::window_event(GraphicsOutput *output)
 */
static PyObject *Dtool_PostProcessPass_window_event_400(PyObject *self, PyObject *arg) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.window_event")) {
    return nullptr;
  }
  // 1-virtual void PostProcessPass::window_event(GraphicsOutput *output)
  GraphicsOutput *arg_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsOutput, 1, "PostProcessPass.window_event", false, true);
  if (arg_this != nullptr) {
    ((*local_this).window_event)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "window_event(const PostProcessPass self, GraphicsOutput output)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_window_event_400_comment =
  "C++ Interface:\n"
  "window_event(const PostProcessPass self, GraphicsOutput output)\n";
#else
static const char *Dtool_PostProcessPass_window_event_400_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PostProcessPass::shutdown(void)
 */
static PyObject *Dtool_PostProcessPass_shutdown_401(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.shutdown")) {
    return nullptr;
  }
  // 1-virtual void PostProcessPass::shutdown(void)
  ((*local_this).shutdown)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_shutdown_401_comment =
  "C++ Interface:\n"
  "shutdown(const PostProcessPass self)\n";
#else
static const char *Dtool_PostProcessPass_shutdown_401_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static FrameBufferProperties PostProcessPass::get_default_fbprops(void)
 */
static PyObject *Dtool_PostProcessPass_get_default_fbprops_402(PyObject *, PyObject *) {
  // 1-static FrameBufferProperties PostProcessPass::get_default_fbprops(void)
  FrameBufferProperties *return_value = new FrameBufferProperties((PostProcessPass::get_default_fbprops)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_FrameBufferProperties, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_get_default_fbprops_402_comment =
  "C++ Interface:\n"
  "get_default_fbprops()\n";
#else
static const char *Dtool_PostProcessPass_get_default_fbprops_402_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *PostProcessPass::upcast_to_ReferenceCount(void)
 */
static PyObject *Dtool_PostProcessPass_upcast_to_ReferenceCount_375(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.upcast_to_ReferenceCount")) {
    return nullptr;
  }
  // 1-ReferenceCount *PostProcessPass::upcast_to_ReferenceCount(void)
  ReferenceCount *return_value = (ReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_upcast_to_ReferenceCount_375_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(const PostProcessPass self)\n"
  "\n"
  "upcast from PostProcessPass to ReferenceCount";
#else
static const char *Dtool_PostProcessPass_upcast_to_ReferenceCount_375_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *PostProcessPass::upcast_to_Namable(void)
 */
static PyObject *Dtool_PostProcessPass_upcast_to_Namable_377(PyObject *self, PyObject *) {
  PostProcessPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessPass, (void **)&local_this, "PostProcessPass.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *PostProcessPass::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_PostProcessPass_upcast_to_Namable_377_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const PostProcessPass self)\n"
  "\n"
  "upcast from PostProcessPass to Namable";
#else
static const char *Dtool_PostProcessPass_upcast_to_Namable_377_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PostProcessPass::PostProcessPass(PostProcess *pp, std::string const &name = "pass", int texture_output_bits = 0, FrameBufferProperties const &fbprops = PostProcessPass::get_default_fbprops(), bool force_size = false, LVector2i const &forced_size = LVector2i::zero(), bool div_size = false, int div = 1)
 * inline PostProcessPass::PostProcessPass(PostProcessPass const &) = default
 */
static int Dtool_Init_PostProcessPass(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 PostProcessPass::PostProcessPass(PostProcess *pp, std::string const &name = "pass", int texture_output_bits = 0, FrameBufferProperties const &fbprops = PostProcessPass::get_default_fbprops(), bool force_size = false, LVector2i const &forced_size = LVector2i::zero(), bool div_size = false, int div = 1)
    PyObject *param0;
    const char *param1_str = "pass";
    Py_ssize_t param1_len = 4;
    int param2 = 0;
    PyObject *param3 = nullptr;
    PyObject *param4 = Py_False;
    PyObject *param5 = nullptr;
    PyObject *param6 = Py_False;
    int param7 = 1;
    static const char *keyword_list[] = {"pp", "name", "texture_output_bits", "fbprops", "force_size", "forced_size", "div_size", "div", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#iOOOOi:PostProcessPass", (char **)keyword_list, &param0, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6, &param7)) {
      PostProcess *param0_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PostProcess, 0, "PostProcessPass.PostProcessPass", false, false);
      FrameBufferProperties const *param3_this;
      const FrameBufferProperties &param3_ref = PostProcessPass::get_default_fbprops();
      if (param3 == nullptr) {
        param3_this = &param3_ref;
      } else {
        param3_this = nullptr;
        DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_FrameBufferProperties);
      }
      LVector2i const *param5_this;
      const LVector2i &param5_ref = LVector2i::zero();
      if (param5 == nullptr) {
        param5_this = &param5_ref;
      } else {
        param5_this = nullptr;
        DtoolInstance_GetPointer(param5, param5_this, *Dtool_Ptr_LVector2i);
      }
      if (param0_this != nullptr && (param3 == nullptr || param3_this != nullptr) && (param5 == nullptr || param5_this != nullptr)) {
        PostProcessPass *return_value = new PostProcessPass(param0_this, std::string(param1_str, param1_len), (int)param2, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this, (PyObject_IsTrue(param6) != 0), (int)param7);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PostProcessPass, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline PostProcessPass::PostProcessPass(PostProcessPass const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      PostProcessPass const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PostProcessPass);
      if (param0_this != nullptr) {
        PostProcessPass *return_value = new PostProcessPass(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PostProcessPass, true, false);
      }
    }
  }

  {
    // -2 PostProcessPass::PostProcessPass(PostProcess *pp, std::string const &name = "pass", int texture_output_bits = 0, FrameBufferProperties const &fbprops = PostProcessPass::get_default_fbprops(), bool force_size = false, LVector2i const &forced_size = LVector2i::zero(), bool div_size = false, int div = 1)
    PyObject *param0;
    const char *param1_str = "pass";
    Py_ssize_t param1_len = 4;
    int param2 = 0;
    PyObject *param3 = nullptr;
    PyObject *param4 = Py_False;
    PyObject *param5 = nullptr;
    PyObject *param6 = Py_False;
    int param7 = 1;
    static const char *keyword_list[] = {"pp", "name", "texture_output_bits", "fbprops", "force_size", "forced_size", "div_size", "div", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#iOOOOi:PostProcessPass", (char **)keyword_list, &param0, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6, &param7)) {
      PostProcess *param0_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PostProcess, 0, "PostProcessPass.PostProcessPass", false, false);
      FrameBufferProperties const *param3_this;
      const FrameBufferProperties &param3_ref = PostProcessPass::get_default_fbprops();
      if (param3 == nullptr) {
        param3_this = &param3_ref;
      } else {
        param3_this = nullptr;
        DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_FrameBufferProperties);
      }
      LVector2i param5_local;
      LVector2i const *param5_this;
      if (param5 != nullptr) {
        param5_this = Dtool_Coerce_LVector2i(param5, param5_local);
      } else {
        param5_local = LVector2i::zero();
        param5_this = &param5_local;
      }
      if (param0_this != nullptr && (param3 == nullptr || param3_this != nullptr) && (param5 == nullptr || (param5_this != nullptr))) {
        PostProcessPass *return_value = new PostProcessPass(param0_this, std::string(param1_str, param1_len), (int)param2, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this, (PyObject_IsTrue(param6) != 0), (int)param7);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PostProcessPass, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline PostProcessPass::PostProcessPass(PostProcessPass const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(PostProcessPass) param0_this;
      if (Dtool_ConstCoerce_PostProcessPass(param0, param0_this)) {
        PostProcessPass *return_value = new PostProcessPass(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PostProcessPass, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PostProcessPass(PostProcess pp, str name, int texture_output_bits, const FrameBufferProperties fbprops, bool force_size, const LVector2i forced_size, bool div_size, int div)\n"
      "PostProcessPass(const PostProcessPass param0)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PostProcessPass(PyObject *args, CPT(PostProcessPass) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PostProcessPass)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PostProcessPass::PostProcessPass(PostProcess *pp, std::string const &name, int texture_output_bits, FrameBufferProperties const &fbprops, bool force_size, LVector2i const &forced_size, bool div_size, int div)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "PostProcessPass.PostProcessPass", false, false);
    if (arg_this != nullptr) {
      PostProcessPass *return_value = new PostProcessPass(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 8) {
      // 1-PostProcessPass::PostProcessPass(PostProcess *pp, std::string const &name, int texture_output_bits = 0, FrameBufferProperties const &fbprops = PostProcessPass::get_default_fbprops(), bool force_size = false, LVector2i const &forced_size = LVector2i::zero(), bool div_size = false, int div = 1)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      int param2 = 0;
      PyObject *param3 = nullptr;
      PyObject *param4 = Py_False;
      PyObject *param5 = nullptr;
      PyObject *param6 = Py_False;
      int param7 = 1;
      if (PyArg_ParseTuple(args, "Os#|iOOOOi:PostProcessPass", &param0, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6, &param7)) {
        PostProcess *param0_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PostProcess, 0, "PostProcessPass.PostProcessPass", false, false);
        FrameBufferProperties const *param3_this;
        const FrameBufferProperties &param3_ref = PostProcessPass::get_default_fbprops();
        if (param3 == nullptr) {
          param3_this = &param3_ref;
        } else {
          param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_FrameBufferProperties);
        }
        LVector2i const *param5_this;
        const LVector2i &param5_ref = LVector2i::zero();
        if (param5 == nullptr) {
          param5_this = &param5_ref;
        } else {
          param5_this = nullptr;
          DtoolInstance_GetPointer(param5, param5_this, *Dtool_Ptr_LVector2i);
        }
        if (param0_this != nullptr && (param3 == nullptr || param3_this != nullptr) && (param5 == nullptr || param5_this != nullptr)) {
          PostProcessPass *return_value = new PostProcessPass(param0_this, std::string(param1_str, param1_len), (int)param2, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this, (PyObject_IsTrue(param6) != 0), (int)param7);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_PostProcessPass(PyObject *args, PT(PostProcessPass) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PostProcessPass)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PostProcessPass::PostProcessPass(PostProcess *pp, std::string const &name, int texture_output_bits, FrameBufferProperties const &fbprops, bool force_size, LVector2i const &forced_size, bool div_size, int div)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "PostProcessPass.PostProcessPass", false, false);
    if (arg_this != nullptr) {
      PostProcessPass *return_value = new PostProcessPass(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 8) {
      // 1-PostProcessPass::PostProcessPass(PostProcess *pp, std::string const &name, int texture_output_bits = 0, FrameBufferProperties const &fbprops = PostProcessPass::get_default_fbprops(), bool force_size = false, LVector2i const &forced_size = LVector2i::zero(), bool div_size = false, int div = 1)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      int param2 = 0;
      PyObject *param3 = nullptr;
      PyObject *param4 = Py_False;
      PyObject *param5 = nullptr;
      PyObject *param6 = Py_False;
      int param7 = 1;
      if (PyArg_ParseTuple(args, "Os#|iOOOOi:PostProcessPass", &param0, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6, &param7)) {
        PostProcess *param0_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PostProcess, 0, "PostProcessPass.PostProcessPass", false, false);
        FrameBufferProperties const *param3_this;
        const FrameBufferProperties &param3_ref = PostProcessPass::get_default_fbprops();
        if (param3 == nullptr) {
          param3_this = &param3_ref;
        } else {
          param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_FrameBufferProperties);
        }
        LVector2i const *param5_this;
        const LVector2i &param5_ref = LVector2i::zero();
        if (param5 == nullptr) {
          param5_this = &param5_ref;
        } else {
          param5_this = nullptr;
          DtoolInstance_GetPointer(param5, param5_this, *Dtool_Ptr_LVector2i);
        }
        if (param0_this != nullptr && (param3 == nullptr || param3_this != nullptr) && (param5 == nullptr || param5_this != nullptr)) {
          PostProcessPass *return_value = new PostProcessPass(param0_this, std::string(param1_str, param1_len), (int)param2, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this, (PyObject_IsTrue(param6) != 0), (int)param7);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_PostProcessPass(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PostProcessPass) {
    printf("PostProcessPass ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PostProcessPass *local_this = (PostProcessPass *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PostProcessPass) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PostProcessPass(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PostProcessPass) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PostProcessPass*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PostProcessPass*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PostProcessScenePass
 */
/**
 * Python function wrapper for:
 * void PostProcessScenePass::setup_scene_camera(int i)
 */
static PyObject *Dtool_PostProcessScenePass_setup_scene_camera_406(PyObject *self, PyObject *arg) {
  PostProcessScenePass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessScenePass, (void **)&local_this, "PostProcessScenePass.setup_scene_camera")) {
    return nullptr;
  }
  // 1-void PostProcessScenePass::setup_scene_camera(int i)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).setup_scene_camera)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_scene_camera(const PostProcessScenePass self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcessScenePass_setup_scene_camera_406_comment =
  "C++ Interface:\n"
  "setup_scene_camera(const PostProcessScenePass self, int i)\n";
#else
static const char *Dtool_PostProcessScenePass_setup_scene_camera_406_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PostProcessScenePass::set_camera_state(RenderState const *state)
 */
static PyObject *Dtool_PostProcessScenePass_set_camera_state_407(PyObject *self, PyObject *arg) {
  PostProcessScenePass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcessScenePass, (void **)&local_this, "PostProcessScenePass.set_camera_state")) {
    return nullptr;
  }
  // 1-void PostProcessScenePass::set_camera_state(RenderState const *state)
  CPT(RenderState) arg_this;
  if (!Dtool_ConstCoerce_RenderState(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PostProcessScenePass.set_camera_state", "RenderState");
  }
  ((*local_this).set_camera_state)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_camera_state(const PostProcessScenePass self, const RenderState state)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcessScenePass_set_camera_state_407_comment =
  "C++ Interface:\n"
  "set_camera_state(const PostProcessScenePass self, const RenderState state)\n";
#else
static const char *Dtool_PostProcessScenePass_set_camera_state_407_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PostProcessScenePass::PostProcessScenePass(PostProcess *pp, int output_texture_bits = ::bits_PASSTEXTURE_COLOR, int auxbits = 0)
 * inline PostProcessScenePass::PostProcessScenePass(PostProcessScenePass const &) = default
 */
static int Dtool_Init_PostProcessScenePass(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 PostProcessScenePass::PostProcessScenePass(PostProcess *pp, int output_texture_bits = ::bits_PASSTEXTURE_COLOR, int auxbits = 0)
    PyObject *param0;
    int param1 = ::bits_PASSTEXTURE_COLOR;
    int param2 = 0;
    static const char *keyword_list[] = {"pp", "output_texture_bits", "auxbits", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ii:PostProcessScenePass", (char **)keyword_list, &param0, &param1, &param2)) {
      PostProcess *param0_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PostProcess, 0, "PostProcessScenePass.PostProcessScenePass", false, false);
      if (param0_this != nullptr) {
        PostProcessScenePass *return_value = new PostProcessScenePass(param0_this, (int)param1, (int)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PostProcessScenePass, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: PostProcessScenePass::PostProcessScenePass(PostProcess *pp, int output_texture_bits = ::bits_PASSTEXTURE_COLOR, int auxbits = 0)
  {
    // -2 inline PostProcessScenePass::PostProcessScenePass(PostProcessScenePass const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(PostProcessScenePass) param0_this;
      if (Dtool_ConstCoerce_PostProcessScenePass(param0, param0_this)) {
        PostProcessScenePass *return_value = new PostProcessScenePass(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PostProcessScenePass, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PostProcessScenePass(PostProcess pp, int output_texture_bits, int auxbits)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PostProcessScenePass(PyObject *args, CPT(PostProcessScenePass) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PostProcessScenePass)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PostProcessScenePass::PostProcessScenePass(PostProcess *pp, int output_texture_bits, int auxbits)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "PostProcessScenePass.PostProcessScenePass", false, false);
    if (arg_this != nullptr) {
      PostProcessScenePass *return_value = new PostProcessScenePass(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-PostProcessScenePass::PostProcessScenePass(PostProcess *pp, int output_texture_bits, int auxbits = 0)
      PyObject *param0;
      int param1;
      int param2 = 0;
      if (PyArg_ParseTuple(args, "Oi|i:PostProcessScenePass", &param0, &param1, &param2)) {
        PostProcess *param0_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PostProcess, 0, "PostProcessScenePass.PostProcessScenePass", false, false);
        if (param0_this != nullptr) {
          PostProcessScenePass *return_value = new PostProcessScenePass(param0_this, (int)param1, (int)param2);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_PostProcessScenePass(PyObject *args, PT(PostProcessScenePass) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PostProcessScenePass)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PostProcessScenePass::PostProcessScenePass(PostProcess *pp, int output_texture_bits, int auxbits)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "PostProcessScenePass.PostProcessScenePass", false, false);
    if (arg_this != nullptr) {
      PostProcessScenePass *return_value = new PostProcessScenePass(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-PostProcessScenePass::PostProcessScenePass(PostProcess *pp, int output_texture_bits, int auxbits = 0)
      PyObject *param0;
      int param1;
      int param2 = 0;
      if (PyArg_ParseTuple(args, "Oi|i:PostProcessScenePass", &param0, &param1, &param2)) {
        PostProcess *param0_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PostProcess, 0, "PostProcessScenePass.PostProcessScenePass", false, false);
        if (param0_this != nullptr) {
          PostProcessScenePass *return_value = new PostProcessScenePass(param0_this, (int)param1, (int)param2);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_PostProcessScenePass(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PostProcessScenePass) {
    printf("PostProcessScenePass ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PostProcessScenePass *local_this = (PostProcessScenePass *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PostProcessScenePass) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PostProcessPass *) local_this;
  }
  if (requested_type == Dtool_Ptr_PostProcessPass) {
    return (PostProcessPass *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(PostProcessPass *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PostProcessScenePass(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PostProcessScenePass) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PostProcessScenePass*)other_this;
  }
  if (from_type == Dtool_Ptr_PostProcessPass) {
    PostProcessPass* other_this = (PostProcessPass*)from_this;
    return (PostProcessScenePass*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PostProcessScenePass*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PostProcess
 */
/**
 * Python function wrapper for:
 * void PostProcess::startup(GraphicsOutput *output)
 */
static PyObject *Dtool_PostProcess_startup_411(PyObject *self, PyObject *arg) {
  PostProcess *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcess, (void **)&local_this, "PostProcess.startup")) {
    return nullptr;
  }
  // 1-void PostProcess::startup(GraphicsOutput *output)
  GraphicsOutput *arg_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsOutput, 1, "PostProcess.startup", false, true);
  if (arg_this != nullptr) {
    ((*local_this).startup)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "startup(const PostProcess self, GraphicsOutput output)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_startup_411_comment =
  "C++ Interface:\n"
  "startup(const PostProcess self, GraphicsOutput output)\n";
#else
static const char *Dtool_PostProcess_startup_411_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PostProcess::add_camera(NodePath const &camera)
 */
static PyObject *Dtool_PostProcess_add_camera_412(PyObject *self, PyObject *arg) {
  PostProcess *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcess, (void **)&local_this, "PostProcess.add_camera")) {
    return nullptr;
  }
  // 1-void PostProcess::add_camera(NodePath const &camera)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "PostProcess.add_camera", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_camera)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_camera(const PostProcess self, const NodePath camera)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_add_camera_412_comment =
  "C++ Interface:\n"
  "add_camera(const PostProcess self, const NodePath camera)\n";
#else
static const char *Dtool_PostProcess_add_camera_412_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PostProcess::remove_camera(NodePath const &camera)
 */
static PyObject *Dtool_PostProcess_remove_camera_413(PyObject *self, PyObject *arg) {
  PostProcess *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcess, (void **)&local_this, "PostProcess.remove_camera")) {
    return nullptr;
  }
  // 1-void PostProcess::remove_camera(NodePath const &camera)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "PostProcess.remove_camera", true, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_camera)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_camera(const PostProcess self, const NodePath camera)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_remove_camera_413_comment =
  "C++ Interface:\n"
  "remove_camera(const PostProcess self, const NodePath camera)\n";
#else
static const char *Dtool_PostProcess_remove_camera_413_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PostProcess::add_effect(PostProcessEffect *effect)
 */
static PyObject *Dtool_PostProcess_add_effect_414(PyObject *self, PyObject *arg) {
  PostProcess *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcess, (void **)&local_this, "PostProcess.add_effect")) {
    return nullptr;
  }
  // 1-inline void PostProcess::add_effect(PostProcessEffect *effect)
  PT(PostProcessEffect) arg_this;
  if (!Dtool_Coerce_PostProcessEffect(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PostProcess.add_effect", "PostProcessEffect");
  }
  ((*local_this).add_effect)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_effect(const PostProcess self, PostProcessEffect effect)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_add_effect_414_comment =
  "C++ Interface:\n"
  "add_effect(const PostProcess self, PostProcessEffect effect)\n";
#else
static const char *Dtool_PostProcess_add_effect_414_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PostProcess::remove_effect(PostProcessEffect *effect)
 */
static PyObject *Dtool_PostProcess_remove_effect_415(PyObject *self, PyObject *arg) {
  PostProcess *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcess, (void **)&local_this, "PostProcess.remove_effect")) {
    return nullptr;
  }
  // 1-inline void PostProcess::remove_effect(PostProcessEffect *effect)
  PT(PostProcessEffect) arg_this;
  if (!Dtool_Coerce_PostProcessEffect(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PostProcess.remove_effect", "PostProcessEffect");
  }
  ((*local_this).remove_effect)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_effect(const PostProcess self, PostProcessEffect effect)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_remove_effect_415_comment =
  "C++ Interface:\n"
  "remove_effect(const PostProcess self, PostProcessEffect effect)\n";
#else
static const char *Dtool_PostProcess_remove_effect_415_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PostProcessEffect *PostProcess::get_effect(std::string const &name)
 */
static PyObject *Dtool_PostProcess_get_effect_416(PyObject *self, PyObject *arg) {
  PostProcess *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcess, (void **)&local_this, "PostProcess.get_effect")) {
    return nullptr;
  }
  // 1-inline PostProcessEffect *PostProcess::get_effect(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PostProcessEffect *return_value = ((*local_this).get_effect)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PostProcessEffect, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_effect(const PostProcess self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_get_effect_416_comment =
  "C++ Interface:\n"
  "get_effect(const PostProcess self, str name)\n";
#else
static const char *Dtool_PostProcess_get_effect_416_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture *PostProcess::get_scene_color_texture(void) const
 */
static PyObject *Dtool_PostProcess_get_scene_color_texture_417(PyObject *self, PyObject *) {
  PostProcess *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PostProcess)) {
    return nullptr;
  }
  // 1-inline Texture *PostProcess::get_scene_color_texture(void) const
  Texture *return_value = ((*(const PostProcess*)local_this).get_scene_color_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_get_scene_color_texture_417_comment =
  "C++ Interface:\n"
  "get_scene_color_texture(PostProcess self)\n";
#else
static const char *Dtool_PostProcess_get_scene_color_texture_417_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture *PostProcess::get_scene_depth_texture(void) const
 */
static PyObject *Dtool_PostProcess_get_scene_depth_texture_418(PyObject *self, PyObject *) {
  PostProcess *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PostProcess)) {
    return nullptr;
  }
  // 1-inline Texture *PostProcess::get_scene_depth_texture(void) const
  Texture *return_value = ((*(const PostProcess*)local_this).get_scene_depth_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_get_scene_depth_texture_418_comment =
  "C++ Interface:\n"
  "get_scene_depth_texture(PostProcess self)\n";
#else
static const char *Dtool_PostProcess_get_scene_depth_texture_418_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PostProcessScenePass *PostProcess::get_scene_pass(void) const
 */
static PyObject *Dtool_PostProcess_get_scene_pass_419(PyObject *self, PyObject *) {
  PostProcess *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PostProcess)) {
    return nullptr;
  }
  // 1-inline PostProcessScenePass *PostProcess::get_scene_pass(void) const
  PostProcessScenePass *return_value = ((*(const PostProcess*)local_this).get_scene_pass)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PostProcessScenePass, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_get_scene_pass_419_comment =
  "C++ Interface:\n"
  "get_scene_pass(PostProcess self)\n";
#else
static const char *Dtool_PostProcess_get_scene_pass_419_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsOutput *PostProcess::get_output(void) const
 */
static PyObject *Dtool_PostProcess_get_output_420(PyObject *self, PyObject *) {
  PostProcess *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PostProcess)) {
    return nullptr;
  }
  // 1-inline GraphicsOutput *PostProcess::get_output(void) const
  GraphicsOutput *return_value = ((*(const PostProcess*)local_this).get_output)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_get_output_420_comment =
  "C++ Interface:\n"
  "get_output(PostProcess self)\n";
#else
static const char *Dtool_PostProcess_get_output_420_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath PostProcess::get_camera(int n) const
 */
static PyObject *Dtool_PostProcess_get_camera_421(PyObject *self, PyObject *arg) {
  PostProcess *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PostProcess)) {
    return nullptr;
  }
  // 1-inline NodePath PostProcess::get_camera(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath(((*(const PostProcess*)local_this).get_camera)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_camera(PostProcess self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_get_camera_421_comment =
  "C++ Interface:\n"
  "get_camera(PostProcess self, int n)\n";
#else
static const char *Dtool_PostProcess_get_camera_421_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PostProcess::next_sort(void)
 */
static PyObject *Dtool_PostProcess_next_sort_422(PyObject *self, PyObject *) {
  PostProcess *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcess, (void **)&local_this, "PostProcess.next_sort")) {
    return nullptr;
  }
  // 1-inline int PostProcess::next_sort(void)
  int return_value = ((*local_this).next_sort)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_next_sort_422_comment =
  "C++ Interface:\n"
  "next_sort(const PostProcess self)\n";
#else
static const char *Dtool_PostProcess_next_sort_422_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DisplayRegion *PostProcess::get_output_display_region(void) const
 */
static PyObject *Dtool_PostProcess_get_output_display_region_423(PyObject *self, PyObject *) {
  PostProcess *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PostProcess)) {
    return nullptr;
  }
  // 1-inline DisplayRegion *PostProcess::get_output_display_region(void) const
  DisplayRegion *return_value = ((*(const PostProcess*)local_this).get_output_display_region)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_get_output_display_region_423_comment =
  "C++ Interface:\n"
  "get_output_display_region(PostProcess self)\n";
#else
static const char *Dtool_PostProcess_get_output_display_region_423_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PostProcess::is_fullscreen(void) const
 */
static PyObject *Dtool_PostProcess_is_fullscreen_424(PyObject *self, PyObject *) {
  PostProcess *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PostProcess)) {
    return nullptr;
  }
  // 1-inline bool PostProcess::is_fullscreen(void) const
  bool return_value = ((*(const PostProcess*)local_this).is_fullscreen)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_is_fullscreen_424_comment =
  "C++ Interface:\n"
  "is_fullscreen(PostProcess self)\n";
#else
static const char *Dtool_PostProcess_is_fullscreen_424_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PostProcess::set_scene_aux_bits(int bits)
 */
static PyObject *Dtool_PostProcess_set_scene_aux_bits_425(PyObject *self, PyObject *arg) {
  PostProcess *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcess, (void **)&local_this, "PostProcess.set_scene_aux_bits")) {
    return nullptr;
  }
  // 1-void PostProcess::set_scene_aux_bits(int bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_scene_aux_bits)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scene_aux_bits(const PostProcess self, int bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_set_scene_aux_bits_425_comment =
  "C++ Interface:\n"
  "set_scene_aux_bits(const PostProcess self, int bits)\n";
#else
static const char *Dtool_PostProcess_set_scene_aux_bits_425_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PostProcess::set_stacked_clears(int n, DrawableRegion *region)
 */
static PyObject *Dtool_PostProcess_set_stacked_clears_426(PyObject *self, PyObject *args, PyObject *kwds) {
  PostProcess *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcess, (void **)&local_this, "PostProcess.set_stacked_clears")) {
    return nullptr;
  }
  // 1-void PostProcess::set_stacked_clears(int n, DrawableRegion *region)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "region", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_stacked_clears", (char **)keyword_list, &param1, &param2)) {
    DrawableRegion *param2_this = (DrawableRegion *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_DrawableRegion, 2, "PostProcess.set_stacked_clears", false, true);
    if (param2_this != nullptr) {
      ((*local_this).set_stacked_clears)((int)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_stacked_clears(const PostProcess self, int n, DrawableRegion region)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_set_stacked_clears_426_comment =
  "C++ Interface:\n"
  "set_stacked_clears(const PostProcess self, int n, DrawableRegion region)\n";
#else
static const char *Dtool_PostProcess_set_stacked_clears_426_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PostProcess::set_window_clears(DrawableRegion *region)
 */
static PyObject *Dtool_PostProcess_set_window_clears_427(PyObject *self, PyObject *arg) {
  PostProcess *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcess, (void **)&local_this, "PostProcess.set_window_clears")) {
    return nullptr;
  }
  // 1-void PostProcess::set_window_clears(DrawableRegion *region)
  DrawableRegion *arg_this = (DrawableRegion *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DrawableRegion, 1, "PostProcess.set_window_clears", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_window_clears)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_window_clears(const PostProcess self, DrawableRegion region)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_set_window_clears_427_comment =
  "C++ Interface:\n"
  "set_window_clears(const PostProcess self, DrawableRegion region)\n";
#else
static const char *Dtool_PostProcess_set_window_clears_427_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PostProcess::set_clears(int n, DrawableRegion *region)
 */
static PyObject *Dtool_PostProcess_set_clears_428(PyObject *self, PyObject *args, PyObject *kwds) {
  PostProcess *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcess, (void **)&local_this, "PostProcess.set_clears")) {
    return nullptr;
  }
  // 1-void PostProcess::set_clears(int n, DrawableRegion *region)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "region", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_clears", (char **)keyword_list, &param1, &param2)) {
    DrawableRegion *param2_this = (DrawableRegion *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_DrawableRegion, 2, "PostProcess.set_clears", false, true);
    if (param2_this != nullptr) {
      ((*local_this).set_clears)((int)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clears(const PostProcess self, int n, DrawableRegion region)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_set_clears_428_comment =
  "C++ Interface:\n"
  "set_clears(const PostProcess self, int n, DrawableRegion region)\n";
#else
static const char *Dtool_PostProcess_set_clears_428_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PostProcess::shutdown(void)
 */
static PyObject *Dtool_PostProcess_shutdown_429(PyObject *self, PyObject *) {
  PostProcess *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcess, (void **)&local_this, "PostProcess.shutdown")) {
    return nullptr;
  }
  // 1-void PostProcess::shutdown(void)
  ((*local_this).shutdown)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_shutdown_429_comment =
  "C++ Interface:\n"
  "shutdown(const PostProcess self)\n";
#else
static const char *Dtool_PostProcess_shutdown_429_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PostProcess::update(void)
 */
static PyObject *Dtool_PostProcess_update_430(PyObject *self, PyObject *) {
  PostProcess *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcess, (void **)&local_this, "PostProcess.update")) {
    return nullptr;
  }
  // 1-void PostProcess::update(void)
  ((*local_this).update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_update_430_comment =
  "C++ Interface:\n"
  "update(const PostProcess self)\n";
#else
static const char *Dtool_PostProcess_update_430_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PostProcess::window_event(void)
 */
static PyObject *Dtool_PostProcess_window_event_431(PyObject *self, PyObject *) {
  PostProcess *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PostProcess, (void **)&local_this, "PostProcess.window_event")) {
    return nullptr;
  }
  // 1-void PostProcess::window_event(void)
  ((*local_this).window_event)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PostProcess_window_event_431_comment =
  "C++ Interface:\n"
  "window_event(const PostProcess self)\n";
#else
static const char *Dtool_PostProcess_window_event_431_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PostProcess::PostProcess(void)
 * inline PostProcess::PostProcess(PostProcess const &) = default
 */
static int Dtool_Init_PostProcess(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("PostProcess() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-PostProcess::PostProcess(void)
      PostProcess *return_value = new PostProcess();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PostProcess, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PostProcess::PostProcess(PostProcess const &) = default
      PostProcess const *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "PostProcess.PostProcess", true, true);
      if (arg_this != nullptr) {
        PostProcess *return_value = new PostProcess(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PostProcess, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PostProcess() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PostProcess()\n"
      "PostProcess(const PostProcess param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PostProcess(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PostProcess) {
    printf("PostProcess ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PostProcess *local_this = (PostProcess *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PostProcess) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PostProcess(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PostProcess) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PostProcess*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class HDRPass
 */
/**
 * Python function wrapper for:
 * static TypeHandle HDRPass::get_class_type(void)
 */
static PyObject *Dtool_HDRPass_get_class_type_434(PyObject *, PyObject *) {
  // 1-static TypeHandle HDRPass::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((HDRPass::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_HDRPass_get_class_type_434_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_HDRPass_get_class_type_434_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void HDRPass::set_exposure_output(PTA_float output)
 */
static PyObject *Dtool_HDRPass_set_exposure_output_436(PyObject *self, PyObject *arg) {
  HDRPass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HDRPass, (void **)&local_this, "HDRPass.set_exposure_output")) {
    return nullptr;
  }
  // 1-inline void HDRPass::set_exposure_output(PTA_float output)
  PointerToArray< float > arg_local;
  PTA_float *arg_this = Dtool_Coerce_PointerToArray_float(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HDRPass.set_exposure_output", "PointerToArray");
  }
  ((*local_this).set_exposure_output)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_exposure_output(const HDRPass self, PointerToArray output)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HDRPass_set_exposure_output_436_comment =
  "C++ Interface:\n"
  "set_exposure_output(const HDRPass self, PointerToArray output)\n";
#else
static const char *Dtool_HDRPass_set_exposure_output_436_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float HDRPass::get_exposure(void) const
 */
static PyObject *Dtool_HDRPass_get_exposure_437(PyObject *self, PyObject *) {
  HDRPass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HDRPass)) {
    return nullptr;
  }
  // 1-inline float HDRPass::get_exposure(void) const
  float return_value = ((*(const HDRPass*)local_this).get_exposure)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HDRPass_get_exposure_437_comment =
  "C++ Interface:\n"
  "get_exposure(HDRPass self)\n"
  "\n"
  "/**\n"
  "\t * Returns the calculated exposure adjustment.\n"
  "\t */";
#else
static const char *Dtool_HDRPass_get_exposure_437_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline HDRPass::HDRPass(HDRPass const &) = default
 * HDRPass::HDRPass(PostProcess *pp)
 */
static int Dtool_Init_HDRPass(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "HDRPass() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline HDRPass::HDRPass(HDRPass const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      HDRPass const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_HDRPass);
      if (param0_this != nullptr) {
        HDRPass *return_value = new HDRPass(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HDRPass, true, false);
      }
    }
  }

  {
    // -2 HDRPass::HDRPass(PostProcess *pp)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "pp")) {
      PostProcess *param0_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PostProcess, 0, "HDRPass.HDRPass", false, false);
      if (param0_this != nullptr) {
        HDRPass *return_value = new HDRPass(param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HDRPass, true, false);
      }
    }
  }

  {
    // -2 inline HDRPass::HDRPass(HDRPass const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(HDRPass) param0_this;
      if (Dtool_ConstCoerce_HDRPass(param0, param0_this)) {
        HDRPass *return_value = new HDRPass(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HDRPass, true, false);
      }
    }
  }

  // No coercion possible: HDRPass::HDRPass(PostProcess *pp)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HDRPass(const HDRPass param0)\n"
      "HDRPass(PostProcess pp)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_HDRPass(PyObject *args, CPT(HDRPass) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_HDRPass)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-HDRPass::HDRPass(PostProcess *pp)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "HDRPass.HDRPass", false, false);
    if (arg_this != nullptr) {
      HDRPass *return_value = new HDRPass(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_HDRPass(PyObject *args, PT(HDRPass) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_HDRPass)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-HDRPass::HDRPass(PostProcess *pp)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "HDRPass.HDRPass", false, false);
    if (arg_this != nullptr) {
      HDRPass *return_value = new HDRPass(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_HDRPass(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_HDRPass) {
    printf("HDRPass ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  HDRPass *local_this = (HDRPass *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_HDRPass) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PostProcessPass *) local_this;
  }
  if (requested_type == Dtool_Ptr_PostProcessPass) {
    return (PostProcessPass *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(PostProcessPass *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_HDRPass(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_HDRPass) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (HDRPass*)other_this;
  }
  if (from_type == Dtool_Ptr_PostProcessPass) {
    PostProcessPass* other_this = (PostProcessPass*)from_this;
    return (HDRPass*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (HDRPass*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class HDREffect
 */
/**
 * Python function wrapper for:
 * inline HDRPass *HDREffect::get_hdr_pass(void) const
 */
static PyObject *Dtool_HDREffect_get_hdr_pass_441(PyObject *self, PyObject *) {
  HDREffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HDREffect)) {
    return nullptr;
  }
  // 1-inline HDRPass *HDREffect::get_hdr_pass(void) const
  HDRPass *return_value = ((*(const HDREffect*)local_this).get_hdr_pass)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HDRPass, true, false);
}

#ifndef NDEBUG
static const char *Dtool_HDREffect_get_hdr_pass_441_comment =
  "C++ Interface:\n"
  "get_hdr_pass(HDREffect self)\n";
#else
static const char *Dtool_HDREffect_get_hdr_pass_441_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * HDREffect::HDREffect(PostProcess *pp)
 */
static int Dtool_Init_HDREffect(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "HDREffect() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "pp")) {
    // 1-HDREffect::HDREffect(PostProcess *pp)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "HDREffect.HDREffect", false, true);
    if (arg_this != nullptr) {
      HDREffect *return_value = new HDREffect(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HDREffect, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HDREffect(PostProcess pp)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_HDREffect(PyObject *args, CPT(HDREffect) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_HDREffect)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-HDREffect::HDREffect(PostProcess *pp)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "HDREffect.HDREffect", false, false);
    if (arg_this != nullptr) {
      HDREffect *return_value = new HDREffect(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_HDREffect(PyObject *args, PT(HDREffect) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_HDREffect)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-HDREffect::HDREffect(PostProcess *pp)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "HDREffect.HDREffect", false, false);
    if (arg_this != nullptr) {
      HDREffect *return_value = new HDREffect(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_HDREffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_HDREffect) {
    printf("HDREffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  HDREffect *local_this = (HDREffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_HDREffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PostProcessEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_PostProcessEffect) {
    return (PostProcessEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(PostProcessEffect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_HDREffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_HDREffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (HDREffect*)other_this;
  }
  if (from_type == Dtool_Ptr_PostProcessEffect) {
    PostProcessEffect* other_this = (PostProcessEffect*)from_this;
    return (HDREffect*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (HDREffect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BloomEffect
 */
/**
 * Python function wrapper for:
 * static TypeHandle BloomEffect::get_class_type(void)
 */
static PyObject *Dtool_BloomEffect_get_class_type_444(PyObject *, PyObject *) {
  // 1-static TypeHandle BloomEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BloomEffect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BloomEffect_get_class_type_444_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BloomEffect_get_class_type_444_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BloomEffect::BloomEffect(PostProcess *pp)
 */
static int Dtool_Init_BloomEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "BloomEffect() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "pp")) {
    // 1-BloomEffect::BloomEffect(PostProcess *pp)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "BloomEffect.BloomEffect", false, true);
    if (arg_this != nullptr) {
      BloomEffect *return_value = new BloomEffect(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BloomEffect, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BloomEffect(PostProcess pp)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BloomEffect(PyObject *args, CPT(BloomEffect) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BloomEffect)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BloomEffect::BloomEffect(PostProcess *pp)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "BloomEffect.BloomEffect", false, false);
    if (arg_this != nullptr) {
      BloomEffect *return_value = new BloomEffect(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_BloomEffect(PyObject *args, PT(BloomEffect) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BloomEffect)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BloomEffect::BloomEffect(PostProcess *pp)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "BloomEffect.BloomEffect", false, false);
    if (arg_this != nullptr) {
      BloomEffect *return_value = new BloomEffect(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_BloomEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BloomEffect) {
    printf("BloomEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BloomEffect *local_this = (BloomEffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BloomEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PostProcessEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_PostProcessEffect) {
    return (PostProcessEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(PostProcessEffect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BloomEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BloomEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (BloomEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_PostProcessEffect) {
    PostProcessEffect* other_this = (PostProcessEffect*)from_this;
    return (BloomEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BloomEffect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LightingOriginEffect
 */
/**
 * Python function wrapper for:
 * static TypeHandle LightingOriginEffect::get_class_type(void)
 */
static PyObject *Dtool_LightingOriginEffect_get_class_type_448(PyObject *, PyObject *) {
  // 1-static TypeHandle LightingOriginEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LightingOriginEffect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LightingOriginEffect_get_class_type_448_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LightingOriginEffect_get_class_type_448_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffect > LightingOriginEffect::make(LVector3 const &origin)
 */
static PyObject *Dtool_LightingOriginEffect_make_449(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderEffect > LightingOriginEffect::make(LVector3 const &origin)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "LightingOriginEffect.make", "LVector3f");
  }
  ConstPointerTo< RenderEffect > return_value = (LightingOriginEffect::make)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderEffect const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(const LVector3f origin)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightingOriginEffect_make_449_comment =
  "C++ Interface:\n"
  "make(const LVector3f origin)\n";
#else
static const char *Dtool_LightingOriginEffect_make_449_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 LightingOriginEffect::get_lighting_origin(void) const
 */
static PyObject *Dtool_LightingOriginEffect_get_lighting_origin_450(PyObject *self, PyObject *) {
  LightingOriginEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightingOriginEffect)) {
    return nullptr;
  }
  // 1-inline LVector3 LightingOriginEffect::get_lighting_origin(void) const
  LVector3 *return_value = new LVector3(((*(const LightingOriginEffect*)local_this).get_lighting_origin)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LightingOriginEffect_get_lighting_origin_450_comment =
  "C++ Interface:\n"
  "get_lighting_origin(LightingOriginEffect self)\n";
#else
static const char *Dtool_LightingOriginEffect_get_lighting_origin_450_comment = nullptr;
#endif

static int Dtool_Init_LightingOriginEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_LightingOriginEffect(PyObject *args, CPT(LightingOriginEffect) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LightingOriginEffect)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderEffect > LightingOriginEffect::make(LVector3 const &origin)
    LVector3 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVector3f);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderEffect > return_value = (LightingOriginEffect::make)(*arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((LightingOriginEffect const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_LightingOriginEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LightingOriginEffect) {
    printf("LightingOriginEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LightingOriginEffect *local_this = (LightingOriginEffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LightingOriginEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderEffect) {
    return (RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LightingOriginEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LightingOriginEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LightingOriginEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderEffect) {
    RenderEffect* other_this = (RenderEffect*)from_this;
    return (LightingOriginEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LightingOriginEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (LightingOriginEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (LightingOriginEffect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class FXAA_Effect
 */
/**
 * Python function wrapper for:
 * static TypeHandle FXAA_Effect::get_class_type(void)
 */
static PyObject *Dtool_FXAA_Effect_get_class_type_453(PyObject *, PyObject *) {
  // 1-static TypeHandle FXAA_Effect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((FXAA_Effect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FXAA_Effect_get_class_type_453_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_FXAA_Effect_get_class_type_453_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * FXAA_Effect::FXAA_Effect(PostProcess *pp)
 */
static int Dtool_Init_FXAA_Effect(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "FXAA_Effect() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "pp")) {
    // 1-FXAA_Effect::FXAA_Effect(PostProcess *pp)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "FXAA_Effect.FXAA_Effect", false, true);
    if (arg_this != nullptr) {
      FXAA_Effect *return_value = new FXAA_Effect(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FXAA_Effect, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FXAA_Effect(PostProcess pp)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_FXAA_Effect(PyObject *args, CPT(FXAA_Effect) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_FXAA_Effect)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-FXAA_Effect::FXAA_Effect(PostProcess *pp)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "FXAA_Effect.FXAA_Effect", false, false);
    if (arg_this != nullptr) {
      FXAA_Effect *return_value = new FXAA_Effect(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_FXAA_Effect(PyObject *args, PT(FXAA_Effect) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_FXAA_Effect)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-FXAA_Effect::FXAA_Effect(PostProcess *pp)
    PostProcess *arg_this = (PostProcess *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PostProcess, 0, "FXAA_Effect.FXAA_Effect", false, false);
    if (arg_this != nullptr) {
      FXAA_Effect *return_value = new FXAA_Effect(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_FXAA_Effect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_FXAA_Effect) {
    printf("FXAA_Effect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  FXAA_Effect *local_this = (FXAA_Effect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_FXAA_Effect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PostProcessEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_PostProcessEffect) {
    return (PostProcessEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(PostProcessEffect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_FXAA_Effect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_FXAA_Effect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (FXAA_Effect*)other_this;
  }
  if (from_type == Dtool_Ptr_PostProcessEffect) {
    PostProcessEffect* other_this = (PostProcessEffect*)from_this;
    return (FXAA_Effect*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (FXAA_Effect*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BloomAttrib
 */
/**
 * Python function wrapper for:
 * static int BloomAttrib::get_class_slot(void)
 */
static PyObject *Dtool_BloomAttrib_get_class_slot_457(PyObject *, PyObject *) {
  // 1-static int BloomAttrib::get_class_slot(void)
  int return_value = (BloomAttrib::get_class_slot)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BloomAttrib_get_class_slot_457_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_BloomAttrib_get_class_slot_457_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BloomAttrib::get_class_type(void)
 */
static PyObject *Dtool_BloomAttrib_get_class_type_459(PyObject *, PyObject *) {
  // 1-static TypeHandle BloomAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BloomAttrib::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BloomAttrib_get_class_type_459_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BloomAttrib_get_class_type_459_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > BloomAttrib::make(bool bloom_enabled = true)
 */
static PyObject *Dtool_BloomAttrib_make_460(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderAttrib > BloomAttrib::make(bool bloom_enabled = true)
  PyObject *param0 = Py_True;
  if (Dtool_ExtractOptionalArg(&param0, args, kwds, "bloom_enabled")) {
    ConstPointerTo< RenderAttrib > return_value = (BloomAttrib::make)((PyObject_IsTrue(param0) != 0));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(bool bloom_enabled)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BloomAttrib_make_460_comment =
  "C++ Interface:\n"
  "make(bool bloom_enabled)\n";
#else
static const char *Dtool_BloomAttrib_make_460_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BloomAttrib::is_bloom_enabled(void) const
 */
static PyObject *Dtool_BloomAttrib_is_bloom_enabled_461(PyObject *self, PyObject *) {
  BloomAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BloomAttrib)) {
    return nullptr;
  }
  // 1-inline bool BloomAttrib::is_bloom_enabled(void) const
  bool return_value = ((*(const BloomAttrib*)local_this).is_bloom_enabled)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BloomAttrib_is_bloom_enabled_461_comment =
  "C++ Interface:\n"
  "is_bloom_enabled(BloomAttrib self)\n";
#else
static const char *Dtool_BloomAttrib_is_bloom_enabled_461_comment = nullptr;
#endif

static PyObject *Dtool_BloomAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int BloomAttrib::get_class_slot(void)
  int return_value = (BloomAttrib::get_class_slot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_BloomAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_BloomAttrib(PyObject *args, CPT(BloomAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BloomAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > BloomAttrib::make(bool bloom_enabled)
    ConstPointerTo< RenderAttrib > return_value = (BloomAttrib::make)((PyObject_IsTrue(arg) != 0));
    if (_PyErr_OCCURRED()) {
      return false;
    } else {
      coerced = std::move((BloomAttrib const *) return_value.p());
      return true;
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_BloomAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BloomAttrib) {
    printf("BloomAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BloomAttrib *local_this = (BloomAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BloomAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BloomAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BloomAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BloomAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (BloomAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BloomAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BloomAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BloomAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PhysicsCharacterController
 */
/**
 * Python function wrapper for:
 * void PhysicsCharacterController::set_max_slope(float degs, bool affect_speed)
 */
static PyObject *Dtool_PhysicsCharacterController_set_max_slope_466(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.set_max_slope")) {
    return nullptr;
  }
  // 1-void PhysicsCharacterController::set_max_slope(float degs, bool affect_speed)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"degs", "affect_speed", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:set_max_slope", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_max_slope)((float)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_slope(const PhysicsCharacterController self, float degs, bool affect_speed)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_set_max_slope_466_comment =
  "C++ Interface:\n"
  "set_max_slope(const PhysicsCharacterController self, float degs, bool affect_speed)\n";
#else
static const char *Dtool_PhysicsCharacterController_set_max_slope_466_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsCharacterController::set_collide_mask(BitMask32 const &mask)
 */
static PyObject *Dtool_PhysicsCharacterController_set_collide_mask_467(PyObject *self, PyObject *arg) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.set_collide_mask")) {
    return nullptr;
  }
  // 1-void PhysicsCharacterController::set_collide_mask(BitMask32 const &mask)
  BitMask< uint32_t, 32 > arg_local;
  BitMask32 const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsCharacterController.set_collide_mask", "BitMask");
  }
  ((*local_this).set_collide_mask)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_mask(const PhysicsCharacterController self, const BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_set_collide_mask_467_comment =
  "C++ Interface:\n"
  "set_collide_mask(const PhysicsCharacterController self, const BitMask mask)\n";
#else
static const char *Dtool_PhysicsCharacterController_set_collide_mask_467_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsCharacterController::set_event_enter_callback(PyObject *callback)
 */
static PyObject *Dtool_PhysicsCharacterController_set_event_enter_callback_468(PyObject *self, PyObject *arg) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.set_event_enter_callback")) {
    return nullptr;
  }
  // 1-inline void PhysicsCharacterController::set_event_enter_callback(PyObject *callback)
  ((*local_this).set_event_enter_callback)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_event_enter_callback(const PhysicsCharacterController self, object callback)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_set_event_enter_callback_468_comment =
  "C++ Interface:\n"
  "set_event_enter_callback(const PhysicsCharacterController self, object callback)\n";
#else
static const char *Dtool_PhysicsCharacterController_set_event_enter_callback_468_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsCharacterController::set_event_exit_callback(PyObject *callback)
 */
static PyObject *Dtool_PhysicsCharacterController_set_event_exit_callback_469(PyObject *self, PyObject *arg) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.set_event_exit_callback")) {
    return nullptr;
  }
  // 1-inline void PhysicsCharacterController::set_event_exit_callback(PyObject *callback)
  ((*local_this).set_event_exit_callback)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_event_exit_callback(const PhysicsCharacterController self, object callback)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_set_event_exit_callback_469_comment =
  "C++ Interface:\n"
  "set_event_exit_callback(const PhysicsCharacterController self, object callback)\n";
#else
static const char *Dtool_PhysicsCharacterController_set_event_exit_callback_469_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsCharacterController::set_active_jump_limiter(bool limiter)
 */
static PyObject *Dtool_PhysicsCharacterController_set_active_jump_limiter_470(PyObject *self, PyObject *arg) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.set_active_jump_limiter")) {
    return nullptr;
  }
  // 1-inline void PhysicsCharacterController::set_active_jump_limiter(bool limiter)
  ((*local_this).set_active_jump_limiter)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active_jump_limiter(const PhysicsCharacterController self, bool limiter)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_set_active_jump_limiter_470_comment =
  "C++ Interface:\n"
  "set_active_jump_limiter(const PhysicsCharacterController self, bool limiter)\n";
#else
static const char *Dtool_PhysicsCharacterController_set_active_jump_limiter_470_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsCharacterController::set_default_material(std::string const &mat)
 */
static PyObject *Dtool_PhysicsCharacterController_set_default_material_471(PyObject *self, PyObject *arg) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.set_default_material")) {
    return nullptr;
  }
  // 1-inline void PhysicsCharacterController::set_default_material(std::string const &mat)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_default_material)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default_material(const PhysicsCharacterController self, str mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_set_default_material_471_comment =
  "C++ Interface:\n"
  "set_default_material(const PhysicsCharacterController self, str mat)\n";
#else
static const char *Dtool_PhysicsCharacterController_set_default_material_471_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsCharacterController::set_touching_water(bool flag)
 */
static PyObject *Dtool_PhysicsCharacterController_set_touching_water_472(PyObject *self, PyObject *arg) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.set_touching_water")) {
    return nullptr;
  }
  // 1-inline void PhysicsCharacterController::set_touching_water(bool flag)
  ((*local_this).set_touching_water)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_touching_water(const PhysicsCharacterController self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_set_touching_water_472_comment =
  "C++ Interface:\n"
  "set_touching_water(const PhysicsCharacterController self, bool flag)\n";
#else
static const char *Dtool_PhysicsCharacterController_set_touching_water_472_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string PhysicsCharacterController::get_current_material(void) const
 */
static PyObject *Dtool_PhysicsCharacterController_get_current_material_473(PyObject *self, PyObject *) {
  PhysicsCharacterController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsCharacterController)) {
    return nullptr;
  }
  // 1-inline std::string PhysicsCharacterController::get_current_material(void) const
  std::string return_value = ((*(const PhysicsCharacterController*)local_this).get_current_material)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_get_current_material_473_comment =
  "C++ Interface:\n"
  "get_current_material(PhysicsCharacterController self)\n";
#else
static const char *Dtool_PhysicsCharacterController_get_current_material_473_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath PhysicsCharacterController::get_walk_capsule(void) const
 */
static PyObject *Dtool_PhysicsCharacterController_get_walk_capsule_474(PyObject *self, PyObject *) {
  PhysicsCharacterController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsCharacterController)) {
    return nullptr;
  }
  // 1-inline NodePath PhysicsCharacterController::get_walk_capsule(void) const
  NodePath *return_value = new NodePath(((*(const PhysicsCharacterController*)local_this).get_walk_capsule)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_get_walk_capsule_474_comment =
  "C++ Interface:\n"
  "get_walk_capsule(PhysicsCharacterController self)\n";
#else
static const char *Dtool_PhysicsCharacterController_get_walk_capsule_474_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath PhysicsCharacterController::get_crouch_capsule(void) const
 */
static PyObject *Dtool_PhysicsCharacterController_get_crouch_capsule_475(PyObject *self, PyObject *) {
  PhysicsCharacterController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsCharacterController)) {
    return nullptr;
  }
  // 1-inline NodePath PhysicsCharacterController::get_crouch_capsule(void) const
  NodePath *return_value = new NodePath(((*(const PhysicsCharacterController*)local_this).get_crouch_capsule)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_get_crouch_capsule_475_comment =
  "C++ Interface:\n"
  "get_crouch_capsule(PhysicsCharacterController self)\n";
#else
static const char *Dtool_PhysicsCharacterController_get_crouch_capsule_475_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath PhysicsCharacterController::get_event_sphere(void) const
 */
static PyObject *Dtool_PhysicsCharacterController_get_event_sphere_476(PyObject *self, PyObject *) {
  PhysicsCharacterController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsCharacterController)) {
    return nullptr;
  }
  // 1-inline NodePath PhysicsCharacterController::get_event_sphere(void) const
  NodePath *return_value = new NodePath(((*(const PhysicsCharacterController*)local_this).get_event_sphere)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_get_event_sphere_476_comment =
  "C++ Interface:\n"
  "get_event_sphere(PhysicsCharacterController self)\n";
#else
static const char *Dtool_PhysicsCharacterController_get_event_sphere_476_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath PhysicsCharacterController::get_capsule(void) const
 */
static PyObject *Dtool_PhysicsCharacterController_get_capsule_477(PyObject *self, PyObject *) {
  PhysicsCharacterController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsCharacterController)) {
    return nullptr;
  }
  // 1-inline NodePath PhysicsCharacterController::get_capsule(void) const
  NodePath *return_value = new NodePath(((*(const PhysicsCharacterController*)local_this).get_capsule)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_get_capsule_477_comment =
  "C++ Interface:\n"
  "get_capsule(PhysicsCharacterController self)\n";
#else
static const char *Dtool_PhysicsCharacterController_get_capsule_477_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath PhysicsCharacterController::get_movement_parent(void) const
 */
static PyObject *Dtool_PhysicsCharacterController_get_movement_parent_478(PyObject *self, PyObject *) {
  PhysicsCharacterController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsCharacterController)) {
    return nullptr;
  }
  // 1-inline NodePath PhysicsCharacterController::get_movement_parent(void) const
  NodePath *return_value = new NodePath(((*(const PhysicsCharacterController*)local_this).get_movement_parent)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_get_movement_parent_478_comment =
  "C++ Interface:\n"
  "get_movement_parent(PhysicsCharacterController self)\n";
#else
static const char *Dtool_PhysicsCharacterController_get_movement_parent_478_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsCharacterController::set_gravity(float grav)
 */
static PyObject *Dtool_PhysicsCharacterController_set_gravity_479(PyObject *self, PyObject *arg) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.set_gravity")) {
    return nullptr;
  }
  // 1-inline void PhysicsCharacterController::set_gravity(float grav)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_gravity)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gravity(const PhysicsCharacterController self, float grav)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_set_gravity_479_comment =
  "C++ Interface:\n"
  "set_gravity(const PhysicsCharacterController self, float grav)\n";
#else
static const char *Dtool_PhysicsCharacterController_set_gravity_479_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsCharacterController::set_movement_state(int state)
 */
static PyObject *Dtool_PhysicsCharacterController_set_movement_state_480(PyObject *self, PyObject *arg) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.set_movement_state")) {
    return nullptr;
  }
  // 1-inline void PhysicsCharacterController::set_movement_state(int state)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_movement_state)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_movement_state(const PhysicsCharacterController self, int state)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_set_movement_state_480_comment =
  "C++ Interface:\n"
  "set_movement_state(const PhysicsCharacterController self, int state)\n";
#else
static const char *Dtool_PhysicsCharacterController_set_movement_state_480_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PhysicsCharacterController::get_movement_state(void) const
 */
static PyObject *Dtool_PhysicsCharacterController_get_movement_state_481(PyObject *self, PyObject *) {
  PhysicsCharacterController *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsCharacterController)) {
    return nullptr;
  }
  // 1-inline int PhysicsCharacterController::get_movement_state(void) const
  int return_value = ((*(const PhysicsCharacterController*)local_this).get_movement_state)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_get_movement_state_481_comment =
  "C++ Interface:\n"
  "get_movement_state(PhysicsCharacterController self)\n";
#else
static const char *Dtool_PhysicsCharacterController_get_movement_state_481_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsCharacterController::set_stand_up_callback(PyObject *callback)
 */
static PyObject *Dtool_PhysicsCharacterController_set_stand_up_callback_482(PyObject *self, PyObject *arg) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.set_stand_up_callback")) {
    return nullptr;
  }
  // 1-inline void PhysicsCharacterController::set_stand_up_callback(PyObject *callback)
  ((*local_this).set_stand_up_callback)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_stand_up_callback(const PhysicsCharacterController self, object callback)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_set_stand_up_callback_482_comment =
  "C++ Interface:\n"
  "set_stand_up_callback(const PhysicsCharacterController self, object callback)\n";
#else
static const char *Dtool_PhysicsCharacterController_set_stand_up_callback_482_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsCharacterController::set_fall_callback(PyObject *callback)
 */
static PyObject *Dtool_PhysicsCharacterController_set_fall_callback_483(PyObject *self, PyObject *arg) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.set_fall_callback")) {
    return nullptr;
  }
  // 1-inline void PhysicsCharacterController::set_fall_callback(PyObject *callback)
  ((*local_this).set_fall_callback)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fall_callback(const PhysicsCharacterController self, object callback)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_set_fall_callback_483_comment =
  "C++ Interface:\n"
  "set_fall_callback(const PhysicsCharacterController self, object callback)\n";
#else
static const char *Dtool_PhysicsCharacterController_set_fall_callback_483_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsCharacterController::start_crouch(void)
 */
static PyObject *Dtool_PhysicsCharacterController_start_crouch_484(PyObject *self, PyObject *) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.start_crouch")) {
    return nullptr;
  }
  // 1-void PhysicsCharacterController::start_crouch(void)
  ((*local_this).start_crouch)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_start_crouch_484_comment =
  "C++ Interface:\n"
  "start_crouch(const PhysicsCharacterController self)\n";
#else
static const char *Dtool_PhysicsCharacterController_start_crouch_484_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsCharacterController::stop_crouch(void)
 */
static PyObject *Dtool_PhysicsCharacterController_stop_crouch_485(PyObject *self, PyObject *) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.stop_crouch")) {
    return nullptr;
  }
  // 1-void PhysicsCharacterController::stop_crouch(void)
  ((*local_this).stop_crouch)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_stop_crouch_485_comment =
  "C++ Interface:\n"
  "stop_crouch(const PhysicsCharacterController self)\n";
#else
static const char *Dtool_PhysicsCharacterController_stop_crouch_485_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PhysicsCharacterController::is_on_ground(void)
 */
static PyObject *Dtool_PhysicsCharacterController_is_on_ground_486(PyObject *self, PyObject *) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.is_on_ground")) {
    return nullptr;
  }
  // 1-bool PhysicsCharacterController::is_on_ground(void)
  bool return_value = ((*local_this).is_on_ground)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_is_on_ground_486_comment =
  "C++ Interface:\n"
  "is_on_ground(const PhysicsCharacterController self)\n";
#else
static const char *Dtool_PhysicsCharacterController_is_on_ground_486_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsCharacterController::start_jump(float max_height = 3.0)
 */
static PyObject *Dtool_PhysicsCharacterController_start_jump_487(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.start_jump")) {
    return nullptr;
  }
  // 1-void PhysicsCharacterController::start_jump(float max_height = 3.0)
  float param1 = 3.0;
  static const char *keyword_list[] = {"max_height", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:start_jump", (char **)keyword_list, &param1)) {
    ((*local_this).start_jump)((float)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "start_jump(const PhysicsCharacterController self, float max_height)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_start_jump_487_comment =
  "C++ Interface:\n"
  "start_jump(const PhysicsCharacterController self, float max_height)\n";
#else
static const char *Dtool_PhysicsCharacterController_start_jump_487_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsCharacterController::set_angular_movement(float omega)
 */
static PyObject *Dtool_PhysicsCharacterController_set_angular_movement_488(PyObject *self, PyObject *arg) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.set_angular_movement")) {
    return nullptr;
  }
  // 1-void PhysicsCharacterController::set_angular_movement(float omega)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_angular_movement)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_angular_movement(const PhysicsCharacterController self, float omega)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_set_angular_movement_488_comment =
  "C++ Interface:\n"
  "set_angular_movement(const PhysicsCharacterController self, float omega)\n";
#else
static const char *Dtool_PhysicsCharacterController_set_angular_movement_488_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsCharacterController::set_linear_movement(LVector3 const &movement)
 */
static PyObject *Dtool_PhysicsCharacterController_set_linear_movement_489(PyObject *self, PyObject *arg) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.set_linear_movement")) {
    return nullptr;
  }
  // 1-void PhysicsCharacterController::set_linear_movement(LVector3 const &movement)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsCharacterController.set_linear_movement", "LVector3f");
  }
  ((*local_this).set_linear_movement)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_linear_movement(const PhysicsCharacterController self, const LVector3f movement)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_set_linear_movement_489_comment =
  "C++ Interface:\n"
  "set_linear_movement(const PhysicsCharacterController self, const LVector3f movement)\n";
#else
static const char *Dtool_PhysicsCharacterController_set_linear_movement_489_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsCharacterController::place_on_ground(void)
 */
static PyObject *Dtool_PhysicsCharacterController_place_on_ground_490(PyObject *self, PyObject *) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.place_on_ground")) {
    return nullptr;
  }
  // 1-void PhysicsCharacterController::place_on_ground(void)
  ((*local_this).place_on_ground)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_place_on_ground_490_comment =
  "C++ Interface:\n"
  "place_on_ground(const PhysicsCharacterController self)\n";
#else
static const char *Dtool_PhysicsCharacterController_place_on_ground_490_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsCharacterController::update(float frametime)
 */
static PyObject *Dtool_PhysicsCharacterController_update_491(PyObject *self, PyObject *arg) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.update")) {
    return nullptr;
  }
  // 1-void PhysicsCharacterController::update(float frametime)
  if (PyNumber_Check(arg)) {
    ((*local_this).update)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "update(const PhysicsCharacterController self, float frametime)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_update_491_comment =
  "C++ Interface:\n"
  "update(const PhysicsCharacterController self, float frametime)\n";
#else
static const char *Dtool_PhysicsCharacterController_update_491_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsCharacterController::remove_capsules(void)
 */
static PyObject *Dtool_PhysicsCharacterController_remove_capsules_492(PyObject *self, PyObject *) {
  PhysicsCharacterController *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCharacterController, (void **)&local_this, "PhysicsCharacterController.remove_capsules")) {
    return nullptr;
  }
  // 1-void PhysicsCharacterController::remove_capsules(void)
  ((*local_this).remove_capsules)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCharacterController_remove_capsules_492_comment =
  "C++ Interface:\n"
  "remove_capsules(const PhysicsCharacterController self)\n";
#else
static const char *Dtool_PhysicsCharacterController_remove_capsules_492_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PhysicsCharacterController::PhysicsCharacterController(BSPLoader *loader, BulletWorld *world, NodePath const &render, NodePath const &parent, float walk_height, float crouch_height, float step_height, float radius, float gravity, BitMask32 const &wall_mask, BitMask32 const &floor_mask, BitMask32 const &event_mask)
 * inline PhysicsCharacterController::PhysicsCharacterController(PhysicsCharacterController const &) = default
 */
static int Dtool_Init_PhysicsCharacterController(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PhysicsCharacterController::PhysicsCharacterController(PhysicsCharacterController const &) = default
      CPT(PhysicsCharacterController) arg_this;
      if (!Dtool_ConstCoerce_PhysicsCharacterController(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "PhysicsCharacterController.PhysicsCharacterController", "PhysicsCharacterController");
        return -1;
      }
      PhysicsCharacterController *return_value = new PhysicsCharacterController(*std::move(arg_this));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsCharacterController, true, false);
    }
    break;
  case 12:
    {
      // 1-PhysicsCharacterController::PhysicsCharacterController(BSPLoader *loader, BulletWorld *world, NodePath const &render, NodePath const &parent, float walk_height, float crouch_height, float step_height, float radius, float gravity, BitMask32 const &wall_mask, BitMask32 const &floor_mask, BitMask32 const &event_mask)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      float param4;
      float param5;
      float param6;
      float param7;
      float param8;
      PyObject *param9;
      PyObject *param10;
      PyObject *param11;
      static const char *keyword_list[] = {"loader", "world", "render", "parent", "walk_height", "crouch_height", "step_height", "radius", "gravity", "wall_mask", "floor_mask", "event_mask", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOfffffOOO:PhysicsCharacterController", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11)) {
        BSPLoader *param0_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_BSPLoader, 0, "PhysicsCharacterController.PhysicsCharacterController", false, true);
        BulletWorld *param1_this = (BulletWorld *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BulletWorld, 1, "PhysicsCharacterController.PhysicsCharacterController", false, true);
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "PhysicsCharacterController.PhysicsCharacterController", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "PhysicsCharacterController.PhysicsCharacterController", true, true);
        BitMask< uint32_t, 32 > param9_local;
        BitMask32 const *param9_this = Dtool_Coerce_BitMask_uint32_t_32(param9, param9_local);
        if (!(param9_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param9, 9, "PhysicsCharacterController.PhysicsCharacterController", "BitMask");
          return -1;
        }
        BitMask< uint32_t, 32 > param10_local;
        BitMask32 const *param10_this = Dtool_Coerce_BitMask_uint32_t_32(param10, param10_local);
        if (!(param10_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param10, 10, "PhysicsCharacterController.PhysicsCharacterController", "BitMask");
          return -1;
        }
        BitMask< uint32_t, 32 > param11_local;
        BitMask32 const *param11_this = Dtool_Coerce_BitMask_uint32_t_32(param11, param11_local);
        if (!(param11_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param11, 11, "PhysicsCharacterController.PhysicsCharacterController", "BitMask");
          return -1;
        }
        if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
          PhysicsCharacterController *return_value = new PhysicsCharacterController(param0_this, param1_this, *param2_this, *param3_this, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, *param9_this, *param10_this, *param11_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsCharacterController, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PhysicsCharacterController() takes 1 or 12 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PhysicsCharacterController(const PhysicsCharacterController param0)\n"
      "PhysicsCharacterController(BSPLoader loader, BulletWorld world, const NodePath render, const NodePath parent, float walk_height, float crouch_height, float step_height, float radius, float gravity, const BitMask wall_mask, const BitMask floor_mask, const BitMask event_mask)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PhysicsCharacterController(PyObject *args, CPT(PhysicsCharacterController) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PhysicsCharacterController)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 12) {
      // 1-PhysicsCharacterController::PhysicsCharacterController(BSPLoader *loader, BulletWorld *world, NodePath const &render, NodePath const &parent, float walk_height, float crouch_height, float step_height, float radius, float gravity, BitMask32 const &wall_mask, BitMask32 const &floor_mask, BitMask32 const &event_mask)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      float param4;
      float param5;
      float param6;
      float param7;
      float param8;
      PyObject *param9;
      PyObject *param10;
      PyObject *param11;
      if (PyArg_ParseTuple(args, "OOOOfffffOOO:PhysicsCharacterController", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11)) {
        BSPLoader *param0_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_BSPLoader, 0, "PhysicsCharacterController.PhysicsCharacterController", false, false);
        BulletWorld *param1_this = (BulletWorld *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BulletWorld, 1, "PhysicsCharacterController.PhysicsCharacterController", false, false);
        NodePath const *param2_this = nullptr;
        DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_NodePath);
        NodePath const *param3_this = nullptr;
        DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_NodePath);
        BitMask32 const *param9_this = nullptr;
        DtoolInstance_GetPointer(param9, param9_this, *Dtool_Ptr_BitMask_uint32_t_32);
        BitMask32 const *param10_this = nullptr;
        DtoolInstance_GetPointer(param10, param10_this, *Dtool_Ptr_BitMask_uint32_t_32);
        BitMask32 const *param11_this = nullptr;
        DtoolInstance_GetPointer(param11, param11_this, *Dtool_Ptr_BitMask_uint32_t_32);
        if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr && param9_this != nullptr && param10_this != nullptr && param11_this != nullptr) {
          PhysicsCharacterController *return_value = new PhysicsCharacterController(param0_this, param1_this, *param2_this, *param3_this, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, *param9_this, *param10_this, *param11_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_PhysicsCharacterController(PyObject *args, PT(PhysicsCharacterController) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PhysicsCharacterController)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 12) {
      // 1-PhysicsCharacterController::PhysicsCharacterController(BSPLoader *loader, BulletWorld *world, NodePath const &render, NodePath const &parent, float walk_height, float crouch_height, float step_height, float radius, float gravity, BitMask32 const &wall_mask, BitMask32 const &floor_mask, BitMask32 const &event_mask)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      float param4;
      float param5;
      float param6;
      float param7;
      float param8;
      PyObject *param9;
      PyObject *param10;
      PyObject *param11;
      if (PyArg_ParseTuple(args, "OOOOfffffOOO:PhysicsCharacterController", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11)) {
        BSPLoader *param0_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_BSPLoader, 0, "PhysicsCharacterController.PhysicsCharacterController", false, false);
        BulletWorld *param1_this = (BulletWorld *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BulletWorld, 1, "PhysicsCharacterController.PhysicsCharacterController", false, false);
        NodePath const *param2_this = nullptr;
        DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_NodePath);
        NodePath const *param3_this = nullptr;
        DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_NodePath);
        BitMask32 const *param9_this = nullptr;
        DtoolInstance_GetPointer(param9, param9_this, *Dtool_Ptr_BitMask_uint32_t_32);
        BitMask32 const *param10_this = nullptr;
        DtoolInstance_GetPointer(param10, param10_this, *Dtool_Ptr_BitMask_uint32_t_32);
        BitMask32 const *param11_this = nullptr;
        DtoolInstance_GetPointer(param11, param11_this, *Dtool_Ptr_BitMask_uint32_t_32);
        if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr && param9_this != nullptr && param10_this != nullptr && param11_this != nullptr) {
          PhysicsCharacterController *return_value = new PhysicsCharacterController(param0_this, param1_this, *param2_this, *param3_this, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, *param9_this, *param10_this, *param11_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_PhysicsCharacterController(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PhysicsCharacterController) {
    printf("PhysicsCharacterController ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PhysicsCharacterController *local_this = (PhysicsCharacterController *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PhysicsCharacterController) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PhysicsCharacterController(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PhysicsCharacterController) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PhysicsCharacterController*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Py_BSPLoader
 */
/**
 * Python function wrapper for:
 * PyObject *Py_BSPLoader::find_all_entities(std::string const &classname)
 */
static PyObject *Dtool_Py_BSPLoader_find_all_entities_495(PyObject *self, PyObject *arg) {
  Py_BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Py_BSPLoader, (void **)&local_this, "Py_BSPLoader.find_all_entities")) {
    return nullptr;
  }
  // 1-PyObject *Py_BSPLoader::find_all_entities(std::string const &classname)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PyObject *return_value = ((*local_this).find_all_entities)(std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_entities(const Py_BSPLoader self, str classname)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_BSPLoader_find_all_entities_495_comment =
  "C++ Interface:\n"
  "find_all_entities(const Py_BSPLoader self, str classname)\n";
#else
static const char *Dtool_Py_BSPLoader_find_all_entities_495_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Py_BSPLoader::get_num_entities(void) const
 */
static PyObject *Dtool_Py_BSPLoader_get_num_entities_496(PyObject *self, PyObject *) {
  Py_BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Py_BSPLoader)) {
    return nullptr;
  }
  // 1-int Py_BSPLoader::get_num_entities(void) const
  int return_value = ((*(const Py_BSPLoader*)local_this).get_num_entities)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Py_BSPLoader_get_num_entities_496_comment =
  "C++ Interface:\n"
  "get_num_entities(Py_BSPLoader self)\n";
#else
static const char *Dtool_Py_BSPLoader_get_num_entities_496_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *Py_BSPLoader::get_entity(int n) const
 */
static PyObject *Dtool_Py_BSPLoader_get_entity_497(PyObject *self, PyObject *arg) {
  Py_BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Py_BSPLoader)) {
    return nullptr;
  }
  // 1-PyObject *Py_BSPLoader::get_entity(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PyObject *return_value = ((*(const Py_BSPLoader*)local_this).get_entity)((int)arg_val);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity(Py_BSPLoader self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_BSPLoader_get_entity_497_comment =
  "C++ Interface:\n"
  "get_entity(Py_BSPLoader self, int n)\n";
#else
static const char *Dtool_Py_BSPLoader_get_entity_497_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CBaseEntity *Py_BSPLoader::get_c_entity(int const entnum) const
 */
static PyObject *Dtool_Py_BSPLoader_get_c_entity_498(PyObject *self, PyObject *arg) {
  Py_BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Py_BSPLoader)) {
    return nullptr;
  }
  // 1-CBaseEntity *Py_BSPLoader::get_c_entity(int const entnum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    CBaseEntity *return_value = ((*(const Py_BSPLoader*)local_this).get_c_entity)((int const)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CBaseEntity, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_c_entity(Py_BSPLoader self, int entnum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_BSPLoader_get_c_entity_498_comment =
  "C++ Interface:\n"
  "get_c_entity(Py_BSPLoader self, int entnum)\n";
#else
static const char *Dtool_Py_BSPLoader_get_c_entity_498_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Py_BSPLoader::get_entity_keyvalues(PyObject *list, int const entnum)
 */
static PyObject *Dtool_Py_BSPLoader_get_entity_keyvalues_499(PyObject *self, PyObject *args, PyObject *kwds) {
  Py_BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Py_BSPLoader, (void **)&local_this, "Py_BSPLoader.get_entity_keyvalues")) {
    return nullptr;
  }
  // 1-void Py_BSPLoader::get_entity_keyvalues(PyObject *list, int const entnum)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"list", "entnum", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_entity_keyvalues", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).get_entity_keyvalues)(param1, (int const)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_keyvalues(const Py_BSPLoader self, object list, int entnum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_BSPLoader_get_entity_keyvalues_499_comment =
  "C++ Interface:\n"
  "get_entity_keyvalues(const Py_BSPLoader self, object list, int entnum)\n";
#else
static const char *Dtool_Py_BSPLoader_get_entity_keyvalues_499_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Py_BSPLoader::link_cent_to_pyent(int entum, PyObject *pyent)
 */
static PyObject *Dtool_Py_BSPLoader_link_cent_to_pyent_500(PyObject *self, PyObject *args, PyObject *kwds) {
  Py_BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Py_BSPLoader, (void **)&local_this, "Py_BSPLoader.link_cent_to_pyent")) {
    return nullptr;
  }
  // 1-void Py_BSPLoader::link_cent_to_pyent(int entum, PyObject *pyent)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"entum", "pyent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:link_cent_to_pyent", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).link_cent_to_pyent)((int)param1, param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "link_cent_to_pyent(const Py_BSPLoader self, int entum, object pyent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_BSPLoader_link_cent_to_pyent_500_comment =
  "C++ Interface:\n"
  "link_cent_to_pyent(const Py_BSPLoader self, int entum, object pyent)\n";
#else
static const char *Dtool_Py_BSPLoader_link_cent_to_pyent_500_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *Py_BSPLoader::get_py_entity_by_target_name(std::string const &targetname) const
 */
static PyObject *Dtool_Py_BSPLoader_get_py_entity_by_target_name_501(PyObject *self, PyObject *arg) {
  Py_BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Py_BSPLoader)) {
    return nullptr;
  }
  // 1-PyObject *Py_BSPLoader::get_py_entity_by_target_name(std::string const &targetname) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PyObject *return_value = ((*(const Py_BSPLoader*)local_this).get_py_entity_by_target_name)(std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_py_entity_by_target_name(Py_BSPLoader self, str targetname)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_BSPLoader_get_py_entity_by_target_name_501_comment =
  "C++ Interface:\n"
  "get_py_entity_by_target_name(Py_BSPLoader self, str targetname)\n";
#else
static const char *Dtool_Py_BSPLoader_get_py_entity_by_target_name_501_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Py_BSPLoader::spawn_entities(void)
 */
static PyObject *Dtool_Py_BSPLoader_spawn_entities_502(PyObject *self, PyObject *) {
  Py_BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Py_BSPLoader, (void **)&local_this, "Py_BSPLoader.spawn_entities")) {
    return nullptr;
  }
  // 1-void Py_BSPLoader::spawn_entities(void)
  ((*local_this).spawn_entities)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Py_BSPLoader_spawn_entities_502_comment =
  "C++ Interface:\n"
  "spawn_entities(const Py_BSPLoader self)\n";
#else
static const char *Dtool_Py_BSPLoader_spawn_entities_502_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Py_BSPLoader::remove_py_entity(PyObject *ent)
 */
static PyObject *Dtool_Py_BSPLoader_remove_py_entity_503(PyObject *self, PyObject *arg) {
  Py_BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Py_BSPLoader, (void **)&local_this, "Py_BSPLoader.remove_py_entity")) {
    return nullptr;
  }
  // 1-void Py_BSPLoader::remove_py_entity(PyObject *ent)
  ((*local_this).remove_py_entity)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_py_entity(const Py_BSPLoader self, object ent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_BSPLoader_remove_py_entity_503_comment =
  "C++ Interface:\n"
  "remove_py_entity(const Py_BSPLoader self, object ent)\n";
#else
static const char *Dtool_Py_BSPLoader_remove_py_entity_503_comment = nullptr;
#endif

static int Dtool_Init_Py_BSPLoader(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_Py_BSPLoader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Py_BSPLoader) {
    printf("Py_BSPLoader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Py_BSPLoader *local_this = (Py_BSPLoader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Py_BSPLoader) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BSPLoader) {
    return (BSPLoader *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Py_BSPLoader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Py_BSPLoader) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BSPLoader) {
    BSPLoader* other_this = (BSPLoader*)from_this;
    return (Py_BSPLoader*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Py_CL_BSPLoader
 */
/**
 * Python function wrapper for:
 * void Py_CL_BSPLoader::link_entity_to_class(std::string const &entname, PyTypeObject *type)
 */
static PyObject *Dtool_Py_CL_BSPLoader_link_entity_to_class_507(PyObject *self, PyObject *args, PyObject *kwds) {
  Py_CL_BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Py_CL_BSPLoader, (void **)&local_this, "Py_CL_BSPLoader.link_entity_to_class")) {
    return nullptr;
  }
  // 1-void Py_CL_BSPLoader::link_entity_to_class(std::string const &entname, PyTypeObject *type)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"entname", "type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:link_entity_to_class", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    if (PyType_Check(param2)) {
      ((*local_this).link_entity_to_class)(std::string(param1_str, param1_len), (PyTypeObject *)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "link_entity_to_class(const Py_CL_BSPLoader self, str entname, type type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_CL_BSPLoader_link_entity_to_class_507_comment =
  "C++ Interface:\n"
  "link_entity_to_class(const Py_CL_BSPLoader self, str entname, type type)\n";
#else
static const char *Dtool_Py_CL_BSPLoader_link_entity_to_class_507_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *Py_CL_BSPLoader::make_pyent(PyObject *pyent, std::string const &classname)
 */
static PyObject *Dtool_Py_CL_BSPLoader_make_pyent_508(PyObject *self, PyObject *args, PyObject *kwds) {
  Py_CL_BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Py_CL_BSPLoader, (void **)&local_this, "Py_CL_BSPLoader.make_pyent")) {
    return nullptr;
  }
  // 1-PyObject *Py_CL_BSPLoader::make_pyent(PyObject *pyent, std::string const &classname)
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"pyent", "classname", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:make_pyent", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    PyObject *return_value = ((*local_this).make_pyent)(param1, std::string(param2_str, param2_len));
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_pyent(const Py_CL_BSPLoader self, object pyent, str classname)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_CL_BSPLoader_make_pyent_508_comment =
  "C++ Interface:\n"
  "make_pyent(const Py_CL_BSPLoader self, object pyent, str classname)\n";
#else
static const char *Dtool_Py_CL_BSPLoader_make_pyent_508_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Py_CL_BSPLoader::Py_CL_BSPLoader(void)
 */
static int Dtool_Init_Py_CL_BSPLoader(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Py_CL_BSPLoader() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Py_CL_BSPLoader() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-Py_CL_BSPLoader::Py_CL_BSPLoader(void)
  Py_CL_BSPLoader *return_value = new Py_CL_BSPLoader();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Py_CL_BSPLoader, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Py_CL_BSPLoader()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Py_CL_BSPLoader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Py_CL_BSPLoader) {
    printf("Py_CL_BSPLoader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Py_CL_BSPLoader *local_this = (Py_CL_BSPLoader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Py_CL_BSPLoader) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BSPLoader) {
    return (BSPLoader *)(Py_BSPLoader *) local_this;
  }
  if (requested_type == Dtool_Ptr_Py_BSPLoader) {
    return (Py_BSPLoader *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Py_CL_BSPLoader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Py_CL_BSPLoader) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BSPLoader) {
    BSPLoader* other_this = (BSPLoader*)from_this;
    return (Py_CL_BSPLoader*)other_this;
  }
  if (from_type == Dtool_Ptr_Py_BSPLoader) {
    Py_BSPLoader* other_this = (Py_BSPLoader*)from_this;
    return (Py_CL_BSPLoader*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Py_AI_BSPLoader
 */
/**
 * Python function wrapper for:
 * void Py_AI_BSPLoader::add_dynamic_entity(PyObject *pyent)
 */
static PyObject *Dtool_Py_AI_BSPLoader_add_dynamic_entity_512(PyObject *self, PyObject *arg) {
  Py_AI_BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Py_AI_BSPLoader, (void **)&local_this, "Py_AI_BSPLoader.add_dynamic_entity")) {
    return nullptr;
  }
  // 1-void Py_AI_BSPLoader::add_dynamic_entity(PyObject *pyent)
  ((*local_this).add_dynamic_entity)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_dynamic_entity(const Py_AI_BSPLoader self, object pyent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_AI_BSPLoader_add_dynamic_entity_512_comment =
  "C++ Interface:\n"
  "add_dynamic_entity(const Py_AI_BSPLoader self, object pyent)\n";
#else
static const char *Dtool_Py_AI_BSPLoader_add_dynamic_entity_512_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Py_AI_BSPLoader::remove_dynamic_entity(PyObject *pyent)
 */
static PyObject *Dtool_Py_AI_BSPLoader_remove_dynamic_entity_513(PyObject *self, PyObject *arg) {
  Py_AI_BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Py_AI_BSPLoader, (void **)&local_this, "Py_AI_BSPLoader.remove_dynamic_entity")) {
    return nullptr;
  }
  // 1-void Py_AI_BSPLoader::remove_dynamic_entity(PyObject *pyent)
  ((*local_this).remove_dynamic_entity)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_dynamic_entity(const Py_AI_BSPLoader self, object pyent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_AI_BSPLoader_remove_dynamic_entity_513_comment =
  "C++ Interface:\n"
  "remove_dynamic_entity(const Py_AI_BSPLoader self, object pyent)\n";
#else
static const char *Dtool_Py_AI_BSPLoader_remove_dynamic_entity_513_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Py_AI_BSPLoader::mark_entity_preserved(int n, bool preserved = true)
 */
static PyObject *Dtool_Py_AI_BSPLoader_mark_entity_preserved_514(PyObject *self, PyObject *args, PyObject *kwds) {
  Py_AI_BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Py_AI_BSPLoader, (void **)&local_this, "Py_AI_BSPLoader.mark_entity_preserved")) {
    return nullptr;
  }
  // 1-void Py_AI_BSPLoader::mark_entity_preserved(int n, bool preserved = true)
  int param1;
  PyObject *param2 = Py_True;
  static const char *keyword_list[] = {"n", "preserved", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:mark_entity_preserved", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).mark_entity_preserved)((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mark_entity_preserved(const Py_AI_BSPLoader self, int n, bool preserved)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_AI_BSPLoader_mark_entity_preserved_514_comment =
  "C++ Interface:\n"
  "mark_entity_preserved(const Py_AI_BSPLoader self, int n, bool preserved)\n";
#else
static const char *Dtool_Py_AI_BSPLoader_mark_entity_preserved_514_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Py_AI_BSPLoader::set_server_entity_dispatcher(PyObject *dispatcher)
 */
static PyObject *Dtool_Py_AI_BSPLoader_set_server_entity_dispatcher_515(PyObject *self, PyObject *arg) {
  Py_AI_BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Py_AI_BSPLoader, (void **)&local_this, "Py_AI_BSPLoader.set_server_entity_dispatcher")) {
    return nullptr;
  }
  // 1-void Py_AI_BSPLoader::set_server_entity_dispatcher(PyObject *dispatcher)
  ((*local_this).set_server_entity_dispatcher)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_server_entity_dispatcher(const Py_AI_BSPLoader self, object dispatcher)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_AI_BSPLoader_set_server_entity_dispatcher_515_comment =
  "C++ Interface:\n"
  "set_server_entity_dispatcher(const Py_AI_BSPLoader self, object dispatcher)\n";
#else
static const char *Dtool_Py_AI_BSPLoader_set_server_entity_dispatcher_515_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Py_AI_BSPLoader::link_server_entity_to_class(std::string const &name, PyTypeObject *type)
 */
static PyObject *Dtool_Py_AI_BSPLoader_link_server_entity_to_class_516(PyObject *self, PyObject *args, PyObject *kwds) {
  Py_AI_BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Py_AI_BSPLoader, (void **)&local_this, "Py_AI_BSPLoader.link_server_entity_to_class")) {
    return nullptr;
  }
  // 1-void Py_AI_BSPLoader::link_server_entity_to_class(std::string const &name, PyTypeObject *type)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"name", "type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:link_server_entity_to_class", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    if (PyType_Check(param2)) {
      ((*local_this).link_server_entity_to_class)(std::string(param1_str, param1_len), (PyTypeObject *)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "link_server_entity_to_class(const Py_AI_BSPLoader self, str name, type type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_AI_BSPLoader_link_server_entity_to_class_516_comment =
  "C++ Interface:\n"
  "link_server_entity_to_class(const Py_AI_BSPLoader self, str name, type type)\n";
#else
static const char *Dtool_Py_AI_BSPLoader_link_server_entity_to_class_516_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Py_AI_BSPLoader::set_transition_landmark(std::string const &name, LVector3 const &origin, LVector3 const &angles)
 */
static PyObject *Dtool_Py_AI_BSPLoader_set_transition_landmark_517(PyObject *self, PyObject *args, PyObject *kwds) {
  Py_AI_BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Py_AI_BSPLoader, (void **)&local_this, "Py_AI_BSPLoader.set_transition_landmark")) {
    return nullptr;
  }
  // 1-inline void Py_AI_BSPLoader::set_transition_landmark(std::string const &name, LVector3 const &origin, LVector3 const &angles)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"name", "origin", "angles", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#OO:set_transition_landmark", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
    LVector3f param2_local;
    LVector3 const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Py_AI_BSPLoader.set_transition_landmark", "LVector3f");
    }
    LVector3f param3_local;
    LVector3 const *param3_this = Dtool_Coerce_LVector3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "Py_AI_BSPLoader.set_transition_landmark", "LVector3f");
    }
    ((*local_this).set_transition_landmark)(std::string(param1_str, param1_len), *param2_this, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transition_landmark(const Py_AI_BSPLoader self, str name, const LVector3f origin, const LVector3f angles)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Py_AI_BSPLoader_set_transition_landmark_517_comment =
  "C++ Interface:\n"
  "set_transition_landmark(const Py_AI_BSPLoader self, str name, const LVector3f origin, const LVector3f angles)\n";
#else
static const char *Dtool_Py_AI_BSPLoader_set_transition_landmark_517_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Py_AI_BSPLoader::clear_transition_landmark(void)
 */
static PyObject *Dtool_Py_AI_BSPLoader_clear_transition_landmark_518(PyObject *self, PyObject *) {
  Py_AI_BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Py_AI_BSPLoader, (void **)&local_this, "Py_AI_BSPLoader.clear_transition_landmark")) {
    return nullptr;
  }
  // 1-inline void Py_AI_BSPLoader::clear_transition_landmark(void)
  ((*local_this).clear_transition_landmark)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Py_AI_BSPLoader_clear_transition_landmark_518_comment =
  "C++ Interface:\n"
  "clear_transition_landmark(const Py_AI_BSPLoader self)\n";
#else
static const char *Dtool_Py_AI_BSPLoader_clear_transition_landmark_518_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Py_AI_BSPLoader::Py_AI_BSPLoader(void)
 */
static int Dtool_Init_Py_AI_BSPLoader(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Py_AI_BSPLoader() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Py_AI_BSPLoader() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-Py_AI_BSPLoader::Py_AI_BSPLoader(void)
  Py_AI_BSPLoader *return_value = new Py_AI_BSPLoader();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Py_AI_BSPLoader, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Py_AI_BSPLoader()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Py_AI_BSPLoader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Py_AI_BSPLoader) {
    printf("Py_AI_BSPLoader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Py_AI_BSPLoader *local_this = (Py_AI_BSPLoader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Py_AI_BSPLoader) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BSPLoader) {
    return (BSPLoader *)(Py_BSPLoader *) local_this;
  }
  if (requested_type == Dtool_Ptr_Py_BSPLoader) {
    return (Py_BSPLoader *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Py_AI_BSPLoader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Py_AI_BSPLoader) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BSPLoader) {
    BSPLoader* other_this = (BSPLoader*)from_this;
    return (Py_AI_BSPLoader*)other_this;
  }
  if (from_type == Dtool_Ptr_Py_BSPLoader) {
    Py_BSPLoader* other_this = (Py_BSPLoader*)from_this;
    return (Py_AI_BSPLoader*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CInterpolationContext
 */
/**
 * Python function wrapper for:
 * static void CInterpolationContext::EnableExtrapolation(bool state)
 */
static PyObject *Dtool_CInterpolationContext_EnableExtrapolation_524(PyObject *, PyObject *arg) {
  // 1-static void CInterpolationContext::EnableExtrapolation(bool state)
  (CInterpolationContext::EnableExtrapolation)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "EnableExtrapolation(bool state)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolationContext_EnableExtrapolation_524_comment =
  "C++ Interface:\n"
  "EnableExtrapolation(bool state)\n";
#else
static const char *Dtool_CInterpolationContext_EnableExtrapolation_524_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool CInterpolationContext::IsThereAContext(void)
 */
static PyObject *Dtool_CInterpolationContext_IsThereAContext_525(PyObject *, PyObject *) {
  // 1-static bool CInterpolationContext::IsThereAContext(void)
  bool return_value = (CInterpolationContext::IsThereAContext)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolationContext_IsThereAContext_525_comment =
  "C++ Interface:\n"
  "IsThereAContext()\n";
#else
static const char *Dtool_CInterpolationContext_IsThereAContext_525_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool CInterpolationContext::IsExtrapolationAllowed(void)
 */
static PyObject *Dtool_CInterpolationContext_IsExtrapolationAllowed_526(PyObject *, PyObject *) {
  // 1-static bool CInterpolationContext::IsExtrapolationAllowed(void)
  bool return_value = (CInterpolationContext::IsExtrapolationAllowed)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolationContext_IsExtrapolationAllowed_526_comment =
  "C++ Interface:\n"
  "IsExtrapolationAllowed()\n";
#else
static const char *Dtool_CInterpolationContext_IsExtrapolationAllowed_526_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void CInterpolationContext::SetLastTimeStamp(float timestamp)
 */
static PyObject *Dtool_CInterpolationContext_SetLastTimeStamp_527(PyObject *, PyObject *arg) {
  // 1-static void CInterpolationContext::SetLastTimeStamp(float timestamp)
  if (PyNumber_Check(arg)) {
    (CInterpolationContext::SetLastTimeStamp)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetLastTimeStamp(float timestamp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolationContext_SetLastTimeStamp_527_comment =
  "C++ Interface:\n"
  "SetLastTimeStamp(float timestamp)\n";
#else
static const char *Dtool_CInterpolationContext_SetLastTimeStamp_527_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static float CInterpolationContext::GetLastTimeStamp(void)
 */
static PyObject *Dtool_CInterpolationContext_GetLastTimeStamp_528(PyObject *, PyObject *) {
  // 1-static float CInterpolationContext::GetLastTimeStamp(void)
  float return_value = (CInterpolationContext::GetLastTimeStamp)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolationContext_GetLastTimeStamp_528_comment =
  "C++ Interface:\n"
  "GetLastTimeStamp()\n";
#else
static const char *Dtool_CInterpolationContext_GetLastTimeStamp_528_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CInterpolationContext::CInterpolationContext(void)
 * inline CInterpolationContext::CInterpolationContext(CInterpolationContext const &) = default
 */
static int Dtool_Init_CInterpolationContext(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CInterpolationContext() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CInterpolationContext::CInterpolationContext(void)
      CInterpolationContext *return_value = new CInterpolationContext();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CInterpolationContext, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CInterpolationContext::CInterpolationContext(CInterpolationContext const &) = default
      CInterpolationContext const *arg_this = (CInterpolationContext *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CInterpolationContext, 0, "CInterpolationContext.CInterpolationContext", true, true);
      if (arg_this != nullptr) {
        CInterpolationContext *return_value = new CInterpolationContext(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CInterpolationContext, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CInterpolationContext() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CInterpolationContext()\n"
      "CInterpolationContext(const CInterpolationContext param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CInterpolationContext(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CInterpolationContext) {
    printf("CInterpolationContext ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CInterpolationContext *local_this = (CInterpolationContext *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CInterpolationContext) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CInterpolationContext(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CInterpolationContext) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class IInterpolatedVar
 */
/**
 * Python function wrapper for:
 * virtual void IInterpolatedVar::SetInterpolationAmount(float seconds) = 0
 */
static PyObject *Dtool_IInterpolatedVar_SetInterpolationAmount_531(PyObject *self, PyObject *arg) {
  IInterpolatedVar *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IInterpolatedVar, (void **)&local_this, "IInterpolatedVar.SetInterpolationAmount")) {
    return nullptr;
  }
  // 1-virtual void IInterpolatedVar::SetInterpolationAmount(float seconds) = 0
  if (PyNumber_Check(arg)) {
    ((*local_this).SetInterpolationAmount)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetInterpolationAmount(const IInterpolatedVar self, float seconds)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_IInterpolatedVar_SetInterpolationAmount_531_comment =
  "C++ Interface:\n"
  "SetInterpolationAmount(const IInterpolatedVar self, float seconds)\n";
#else
static const char *Dtool_IInterpolatedVar_SetInterpolationAmount_531_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void IInterpolatedVar::NoteLastNetworkedValue(void) = 0
 */
static PyObject *Dtool_IInterpolatedVar_NoteLastNetworkedValue_532(PyObject *self, PyObject *) {
  IInterpolatedVar *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IInterpolatedVar, (void **)&local_this, "IInterpolatedVar.NoteLastNetworkedValue")) {
    return nullptr;
  }
  // 1-virtual void IInterpolatedVar::NoteLastNetworkedValue(void) = 0
  ((*local_this).NoteLastNetworkedValue)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_IInterpolatedVar_NoteLastNetworkedValue_532_comment =
  "C++ Interface:\n"
  "NoteLastNetworkedValue(const IInterpolatedVar self)\n"
  "\n"
  "// Returns true if the new value is different from the prior most recent\n"
  "// value.";
#else
static const char *Dtool_IInterpolatedVar_NoteLastNetworkedValue_532_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool IInterpolatedVar::NoteChanged(float changetime, bool bUpdateLastNetworkedValue) = 0
 */
static PyObject *Dtool_IInterpolatedVar_NoteChanged_533(PyObject *self, PyObject *args, PyObject *kwds) {
  IInterpolatedVar *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IInterpolatedVar, (void **)&local_this, "IInterpolatedVar.NoteChanged")) {
    return nullptr;
  }
  // 1-virtual bool IInterpolatedVar::NoteChanged(float changetime, bool bUpdateLastNetworkedValue) = 0
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"changetime", "bUpdateLastNetworkedValue", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:NoteChanged", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*local_this).NoteChanged)((float)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "NoteChanged(const IInterpolatedVar self, float changetime, bool bUpdateLastNetworkedValue)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_IInterpolatedVar_NoteChanged_533_comment =
  "C++ Interface:\n"
  "NoteChanged(const IInterpolatedVar self, float changetime, bool bUpdateLastNetworkedValue)\n";
#else
static const char *Dtool_IInterpolatedVar_NoteChanged_533_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void IInterpolatedVar::Reset(void) = 0
 */
static PyObject *Dtool_IInterpolatedVar_Reset_534(PyObject *self, PyObject *) {
  IInterpolatedVar *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IInterpolatedVar, (void **)&local_this, "IInterpolatedVar.Reset")) {
    return nullptr;
  }
  // 1-virtual void IInterpolatedVar::Reset(void) = 0
  ((*local_this).Reset)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_IInterpolatedVar_Reset_534_comment =
  "C++ Interface:\n"
  "Reset(const IInterpolatedVar self)\n";
#else
static const char *Dtool_IInterpolatedVar_Reset_534_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int IInterpolatedVar::Interpolate(float currentTime) = 0
 */
static PyObject *Dtool_IInterpolatedVar_Interpolate_535(PyObject *self, PyObject *arg) {
  IInterpolatedVar *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IInterpolatedVar, (void **)&local_this, "IInterpolatedVar.Interpolate")) {
    return nullptr;
  }
  // 1-virtual int IInterpolatedVar::Interpolate(float currentTime) = 0
  if (PyNumber_Check(arg)) {
    int return_value = ((*local_this).Interpolate)((float)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Interpolate(const IInterpolatedVar self, float currentTime)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_IInterpolatedVar_Interpolate_535_comment =
  "C++ Interface:\n"
  "Interpolate(const IInterpolatedVar self, float currentTime)\n"
  "\n"
  "// Returns 1 if the value will always be the same if currentTime is always\n"
  "// increasing.";
#else
static const char *Dtool_IInterpolatedVar_Interpolate_535_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int IInterpolatedVar::GetType(void) const = 0
 */
static PyObject *Dtool_IInterpolatedVar_GetType_536(PyObject *self, PyObject *) {
  IInterpolatedVar *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_IInterpolatedVar)) {
    return nullptr;
  }
  // 1-virtual int IInterpolatedVar::GetType(void) const = 0
  int return_value = ((*(const IInterpolatedVar*)local_this).GetType)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_IInterpolatedVar_GetType_536_comment =
  "C++ Interface:\n"
  "GetType(IInterpolatedVar self)\n";
#else
static const char *Dtool_IInterpolatedVar_GetType_536_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void IInterpolatedVar::RestoreToLastNetworked(void) = 0
 */
static PyObject *Dtool_IInterpolatedVar_RestoreToLastNetworked_537(PyObject *self, PyObject *) {
  IInterpolatedVar *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IInterpolatedVar, (void **)&local_this, "IInterpolatedVar.RestoreToLastNetworked")) {
    return nullptr;
  }
  // 1-virtual void IInterpolatedVar::RestoreToLastNetworked(void) = 0
  ((*local_this).RestoreToLastNetworked)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_IInterpolatedVar_RestoreToLastNetworked_537_comment =
  "C++ Interface:\n"
  "RestoreToLastNetworked(const IInterpolatedVar self)\n";
#else
static const char *Dtool_IInterpolatedVar_RestoreToLastNetworked_537_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void IInterpolatedVar::Copy(IInterpolatedVar *pSrc) = 0
 */
static PyObject *Dtool_IInterpolatedVar_Copy_538(PyObject *self, PyObject *arg) {
  IInterpolatedVar *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IInterpolatedVar, (void **)&local_this, "IInterpolatedVar.Copy")) {
    return nullptr;
  }
  // 1-virtual void IInterpolatedVar::Copy(IInterpolatedVar *pSrc) = 0
  IInterpolatedVar *arg_this = (IInterpolatedVar *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_IInterpolatedVar, 1, "IInterpolatedVar.Copy", false, true);
  if (arg_this != nullptr) {
    ((*local_this).Copy)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Copy(const IInterpolatedVar self, IInterpolatedVar pSrc)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_IInterpolatedVar_Copy_538_comment =
  "C++ Interface:\n"
  "Copy(const IInterpolatedVar self, IInterpolatedVar pSrc)\n";
#else
static const char *Dtool_IInterpolatedVar_Copy_538_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual char const *IInterpolatedVar::GetDebugName(void) = 0
 */
static PyObject *Dtool_IInterpolatedVar_GetDebugName_539(PyObject *self, PyObject *) {
  IInterpolatedVar *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IInterpolatedVar, (void **)&local_this, "IInterpolatedVar.GetDebugName")) {
    return nullptr;
  }
  // 1-virtual char const *IInterpolatedVar::GetDebugName(void) = 0
  char const *return_value = ((*local_this).GetDebugName)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_IInterpolatedVar_GetDebugName_539_comment =
  "C++ Interface:\n"
  "GetDebugName(const IInterpolatedVar self)\n";
#else
static const char *Dtool_IInterpolatedVar_GetDebugName_539_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void IInterpolatedVar::SetDebugName(char const *pName) = 0
 */
static PyObject *Dtool_IInterpolatedVar_SetDebugName_540(PyObject *self, PyObject *arg) {
  IInterpolatedVar *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IInterpolatedVar, (void **)&local_this, "IInterpolatedVar.SetDebugName")) {
    return nullptr;
  }
  // 1-virtual void IInterpolatedVar::SetDebugName(char const *pName) = 0
  char const *param1;
  if (PyArg_Parse(arg, "z:SetDebugName", &param1)) {
    ((*local_this).SetDebugName)((char const *)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetDebugName(const IInterpolatedVar self, str pName)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_IInterpolatedVar_SetDebugName_540_comment =
  "C++ Interface:\n"
  "SetDebugName(const IInterpolatedVar self, str pName)\n";
#else
static const char *Dtool_IInterpolatedVar_SetDebugName_540_comment = nullptr;
#endif

static int Dtool_Init_IInterpolatedVar(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_IInterpolatedVar(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_IInterpolatedVar) {
    printf("IInterpolatedVar ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  IInterpolatedVar *local_this = (IInterpolatedVar *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_IInterpolatedVar) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_IInterpolatedVar(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_IInterpolatedVar) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CInterpolatedVar< LVector2f >
 */
/**
 * Python function wrapper for:
 * CInterpolatedVar< LVector2f >::CInterpolatedVar(char const *pDebugName = 0)
 */
static int Dtool_Init_CInterpolatedVar_LVector2f(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-CInterpolatedVar< LVector2f >::CInterpolatedVar(char const *pDebugName = 0)
  char const *param0 = 0;
  static const char *keyword_list[] = {"pDebugName", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|z:CInterpolatedVar", (char **)keyword_list, &param0)) {
    CInterpolatedVar< LVector2f > *return_value = new CInterpolatedVar< LVector2f >((char const *)param0);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CInterpolatedVar_LVector2f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CInterpolatedVar(str pDebugName)\n");
  }
  return -1;
}

CInterpolatedVar< LVector2f > *Dtool_Coerce_CInterpolatedVar_LVector2f(PyObject *args, CInterpolatedVar< LVector2f > &coerced) {
  CInterpolatedVar< LVector2f > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_CInterpolatedVar_LVector2f)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const CInterpolatedVar< LVector2f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CInterpolatedVar< LVector2f >::CInterpolatedVar(char const *pDebugName)
    char const *param0;
    if (PyArg_Parse(arg, "z:CInterpolatedVar", &param0)) {
      coerced = CInterpolatedVar< LVector2f >((char const *)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
    PyErr_Clear();
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_CInterpolatedVar_LVector2f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CInterpolatedVar_LVector2f) {
    printf("CInterpolatedVar_LVector2f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CInterpolatedVar< LVector2f > *local_this = (CInterpolatedVar< LVector2f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CInterpolatedVar_LVector2f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterpolatedVarArrayBase_LVector2f_false) {
    return (CInterpolatedVarArrayBase< LVector2f, false > *) local_this;
  }
  if (requested_type == Dtool_Ptr_IInterpolatedVar) {
    return (IInterpolatedVar *)(CInterpolatedVarArrayBase< LVector2f, false > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CInterpolatedVar_LVector2f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CInterpolatedVar_LVector2f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterpolatedVarArrayBase_LVector2f_false) {
    CInterpolatedVarArrayBase< LVector2f, false >* other_this = (CInterpolatedVarArrayBase< LVector2f, false >*)from_this;
    return (CInterpolatedVar< LVector2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_IInterpolatedVar) {
    IInterpolatedVar* other_this = (IInterpolatedVar*)from_this;
    return (CInterpolatedVar< LVector2f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CInterpolatedVarArrayBase< LVector2f, false >
 */
/**
 * Python function wrapper for:
 * virtual void CInterpolatedVarArrayBase< LVector2f, false >::Setup(LVector2f *pValue, int type)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_Setup_544(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.Setup")) {
    return nullptr;
  }
  // 1-virtual void CInterpolatedVarArrayBase< LVector2f, false >::Setup(LVector2f *pValue, int type)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"pValue", "type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:Setup", (char **)keyword_list, &param1, &param2)) {
    LVector2f param1_local;
    LVector2f *param1_this = Dtool_Coerce_LVector2f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CInterpolatedVarArrayBase.Setup", "LVector2f");
    }
    ((*local_this).Setup)(param1_this, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Setup(const CInterpolatedVarArrayBase self, LVector2f pValue, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_Setup_544_comment =
  "C++ Interface:\n"
  "Setup(const CInterpolatedVarArrayBase self, LVector2f pValue, int type)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_Setup_544_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CInterpolatedVarArrayBase< LVector2f, false >::NoteChanged(float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_NoteChanged_545(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.NoteChanged")) {
    return nullptr;
  }
  // 1-bool CInterpolatedVarArrayBase< LVector2f, false >::NoteChanged(float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)
  float param1;
  float param2;
  PyObject *param3;
  static const char *keyword_list[] = {"changetime", "interpolation_amount", "bUpdateLastNetworkedValue", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:NoteChanged", (char **)keyword_list, &param1, &param2, &param3)) {
    bool return_value = ((*local_this).NoteChanged)((float)param1, (float)param2, (PyObject_IsTrue(param3) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "NoteChanged(const CInterpolatedVarArrayBase self, float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_NoteChanged_545_comment =
  "C++ Interface:\n"
  "NoteChanged(const CInterpolatedVarArrayBase self, float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)\n"
  "\n"
  "// Just like the IInterpolatedVar functions, but you can specify an\n"
  "// interpolation amount.";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_NoteChanged_545_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< LVector2f, false >::Interpolate(float currentTime, float interpolation_amount)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_Interpolate_546(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.Interpolate")) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< LVector2f, false >::Interpolate(float currentTime, float interpolation_amount)
  float param1;
  float param2;
  static const char *keyword_list[] = {"currentTime", "interpolation_amount", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:Interpolate", (char **)keyword_list, &param1, &param2)) {
    int return_value = ((*local_this).Interpolate)((float)param1, (float)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Interpolate(const CInterpolatedVarArrayBase self, float currentTime, float interpolation_amount)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_Interpolate_546_comment =
  "C++ Interface:\n"
  "Interpolate(const CInterpolatedVarArrayBase self, float currentTime, float interpolation_amount)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_Interpolate_546_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector2f, false >::DebugInterpolate(LVector2f *pOut, float currentTime)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_DebugInterpolate_547(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.DebugInterpolate")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector2f, false >::DebugInterpolate(LVector2f *pOut, float currentTime)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"pOut", "currentTime", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:DebugInterpolate", (char **)keyword_list, &param1, &param2)) {
    LVector2f param1_local;
    LVector2f *param1_this = Dtool_Coerce_LVector2f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CInterpolatedVarArrayBase.DebugInterpolate", "LVector2f");
    }
    ((*local_this).DebugInterpolate)(param1_this, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "DebugInterpolate(const CInterpolatedVarArrayBase self, LVector2f pOut, float currentTime)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_DebugInterpolate_547_comment =
  "C++ Interface:\n"
  "DebugInterpolate(const CInterpolatedVarArrayBase self, LVector2f pOut, float currentTime)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_DebugInterpolate_547_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector2f, false >::GetDerivative(LVector2f *pOut, float currentTime)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetDerivative_548(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.GetDerivative")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector2f, false >::GetDerivative(LVector2f *pOut, float currentTime)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"pOut", "currentTime", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:GetDerivative", (char **)keyword_list, &param1, &param2)) {
    LVector2f param1_local;
    LVector2f *param1_this = Dtool_Coerce_LVector2f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CInterpolatedVarArrayBase.GetDerivative", "LVector2f");
    }
    ((*local_this).GetDerivative)(param1_this, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetDerivative(const CInterpolatedVarArrayBase self, LVector2f pOut, float currentTime)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetDerivative_548_comment =
  "C++ Interface:\n"
  "GetDerivative(const CInterpolatedVarArrayBase self, LVector2f pOut, float currentTime)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetDerivative_548_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector2f, false >::GetDerivative_SmoothVelocity(LVector2f *pOut, float currentTime)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetDerivative_SmoothVelocity_549(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.GetDerivative_SmoothVelocity")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector2f, false >::GetDerivative_SmoothVelocity(LVector2f *pOut, float currentTime)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"pOut", "currentTime", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:GetDerivative_SmoothVelocity", (char **)keyword_list, &param1, &param2)) {
    LVector2f param1_local;
    LVector2f *param1_this = Dtool_Coerce_LVector2f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CInterpolatedVarArrayBase.GetDerivative_SmoothVelocity", "LVector2f");
    }
    ((*local_this).GetDerivative_SmoothVelocity)(param1_this, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetDerivative_SmoothVelocity(const CInterpolatedVarArrayBase self, LVector2f pOut, float currentTime)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetDerivative_SmoothVelocity_549_comment =
  "C++ Interface:\n"
  "GetDerivative_SmoothVelocity(const CInterpolatedVarArrayBase self, LVector2f pOut, float currentTime)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetDerivative_SmoothVelocity_549_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector2f, false >::ClearHistory(void)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_ClearHistory_550(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.ClearHistory")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector2f, false >::ClearHistory(void)
  ((*local_this).ClearHistory)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_ClearHistory_550_comment =
  "C++ Interface:\n"
  "ClearHistory(const CInterpolatedVarArrayBase self)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_ClearHistory_550_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector2f, false >::AddToHead(float changeTime, LVector2f const *values, bool bFlushNewer)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_AddToHead_551(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.AddToHead")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector2f, false >::AddToHead(float changeTime, LVector2f const *values, bool bFlushNewer)
  float param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"changeTime", "values", "bFlushNewer", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fOO:AddToHead", (char **)keyword_list, &param1, &param2, &param3)) {
    LVector2f param2_local;
    LVector2f const *param2_this = Dtool_Coerce_LVector2f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CInterpolatedVarArrayBase.AddToHead", "LVector2f");
    }
    ((*local_this).AddToHead)((float)param1, param2_this, (PyObject_IsTrue(param3) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "AddToHead(const CInterpolatedVarArrayBase self, float changeTime, const LVector2f values, bool bFlushNewer)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_AddToHead_551_comment =
  "C++ Interface:\n"
  "AddToHead(const CInterpolatedVarArrayBase self, float changeTime, const LVector2f values, bool bFlushNewer)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_AddToHead_551_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector2f const &CInterpolatedVarArrayBase< LVector2f, false >::GetPrev(int iArrayIndex = 0) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetPrev_552(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_LVector2f_false)) {
    return nullptr;
  }
  // 1-LVector2f const &CInterpolatedVarArrayBase< LVector2f, false >::GetPrev(int iArrayIndex = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"iArrayIndex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:GetPrev", (char **)keyword_list, &param1)) {
    LVector2f const *return_value = &(((*(const CInterpolatedVarArrayBase< LVector2f, false >*)local_this).GetPrev)((int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetPrev(CInterpolatedVarArrayBase self, int iArrayIndex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetPrev_552_comment =
  "C++ Interface:\n"
  "GetPrev(CInterpolatedVarArrayBase self, int iArrayIndex)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetPrev_552_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector2f const &CInterpolatedVarArrayBase< LVector2f, false >::GetCurrent(int iArrayIndex = 0) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetCurrent_553(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_LVector2f_false)) {
    return nullptr;
  }
  // 1-LVector2f const &CInterpolatedVarArrayBase< LVector2f, false >::GetCurrent(int iArrayIndex = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"iArrayIndex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:GetCurrent", (char **)keyword_list, &param1)) {
    LVector2f const *return_value = &(((*(const CInterpolatedVarArrayBase< LVector2f, false >*)local_this).GetCurrent)((int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetCurrent(CInterpolatedVarArrayBase self, int iArrayIndex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetCurrent_553_comment =
  "C++ Interface:\n"
  "GetCurrent(CInterpolatedVarArrayBase self, int iArrayIndex)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetCurrent_553_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float CInterpolatedVarArrayBase< LVector2f, false >::GetInterval(void) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetInterval_554(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_LVector2f_false)) {
    return nullptr;
  }
  // 1-float CInterpolatedVarArrayBase< LVector2f, false >::GetInterval(void) const
  float return_value = ((*(const CInterpolatedVarArrayBase< LVector2f, false >*)local_this).GetInterval)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetInterval_554_comment =
  "C++ Interface:\n"
  "GetInterval(CInterpolatedVarArrayBase self)\n"
  "\n"
  "// Returns the time difference betweem the most recent sample and its previous\n"
  "// sample.";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetInterval_554_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CInterpolatedVarArrayBase< LVector2f, false >::IsValidIndex(int i)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_IsValidIndex_555(PyObject *self, PyObject *arg) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.IsValidIndex")) {
    return nullptr;
  }
  // 1-bool CInterpolatedVarArrayBase< LVector2f, false >::IsValidIndex(int i)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).IsValidIndex)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "IsValidIndex(const CInterpolatedVarArrayBase self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_IsValidIndex_555_comment =
  "C++ Interface:\n"
  "IsValidIndex(const CInterpolatedVarArrayBase self, int i)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_IsValidIndex_555_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< LVector2f, false >::GetHead(void)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetHead_557(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.GetHead")) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< LVector2f, false >::GetHead(void)
  int return_value = ((*local_this).GetHead)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetHead_557_comment =
  "C++ Interface:\n"
  "GetHead(const CInterpolatedVarArrayBase self)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetHead_557_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< LVector2f, false >::GetNext(int i)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetNext_558(PyObject *self, PyObject *arg) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.GetNext")) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< LVector2f, false >::GetNext(int i)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).GetNext)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetNext(const CInterpolatedVarArrayBase self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetNext_558_comment =
  "C++ Interface:\n"
  "GetNext(const CInterpolatedVarArrayBase self, int i)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetNext_558_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector2f, false >::SetHistoryValuesForItem(int item, LVector2f &value)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetHistoryValuesForItem_559(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.SetHistoryValuesForItem")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector2f, false >::SetHistoryValuesForItem(int item, LVector2f &value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"item", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:SetHistoryValuesForItem", (char **)keyword_list, &param1, &param2)) {
    LVector2f param2_local;
    LVector2f *param2_this = Dtool_Coerce_LVector2f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CInterpolatedVarArrayBase.SetHistoryValuesForItem", "LVector2f");
    }
    ((*local_this).SetHistoryValuesForItem)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetHistoryValuesForItem(const CInterpolatedVarArrayBase self, int item, LVector2f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetHistoryValuesForItem_559_comment =
  "C++ Interface:\n"
  "SetHistoryValuesForItem(const CInterpolatedVarArrayBase self, int item, LVector2f value)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetHistoryValuesForItem_559_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector2f, false >::SetLooping(bool looping, int iArrayIndex = 0)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetLooping_560(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.SetLooping")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector2f, false >::SetLooping(bool looping, int iArrayIndex = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"looping", "iArrayIndex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:SetLooping", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).SetLooping)((PyObject_IsTrue(param1) != 0), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetLooping(const CInterpolatedVarArrayBase self, bool looping, int iArrayIndex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetLooping_560_comment =
  "C++ Interface:\n"
  "SetLooping(const CInterpolatedVarArrayBase self, bool looping, int iArrayIndex)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetLooping_560_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector2f, false >::SetMaxCount(int newmax)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetMaxCount_561(PyObject *self, PyObject *arg) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.SetMaxCount")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector2f, false >::SetMaxCount(int newmax)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).SetMaxCount)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetMaxCount(const CInterpolatedVarArrayBase self, int newmax)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetMaxCount_561_comment =
  "C++ Interface:\n"
  "SetMaxCount(const CInterpolatedVarArrayBase self, int newmax)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetMaxCount_561_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< LVector2f, false >::GetMaxCount(void) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetMaxCount_562(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_LVector2f_false)) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< LVector2f, false >::GetMaxCount(void) const
  int return_value = ((*(const CInterpolatedVarArrayBase< LVector2f, false >*)local_this).GetMaxCount)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetMaxCount_562_comment =
  "C++ Interface:\n"
  "GetMaxCount(CInterpolatedVarArrayBase self)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetMaxCount_562_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float CInterpolatedVarArrayBase< LVector2f, false >::GetOldestEntry(void)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetOldestEntry_563(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector2f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector2f_false.GetOldestEntry")) {
    return nullptr;
  }
  // 1-float CInterpolatedVarArrayBase< LVector2f, false >::GetOldestEntry(void)
  float return_value = ((*local_this).GetOldestEntry)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetOldestEntry_563_comment =
  "C++ Interface:\n"
  "GetOldestEntry(const CInterpolatedVarArrayBase self)\n"
  "\n"
  "// Get the time of the oldest entry.";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetOldestEntry_563_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CInterpolatedVarArrayBase< LVector2f, false >::CInterpolatedVarArrayBase(char const *pDebugName = "no debug name")
 */
static int Dtool_Init_CInterpolatedVarArrayBase_LVector2f_false(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-CInterpolatedVarArrayBase< LVector2f, false >::CInterpolatedVarArrayBase(char const *pDebugName = "no debug name")
  char const *param0 = "no debug name";
  static const char *keyword_list[] = {"pDebugName", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|z:CInterpolatedVarArrayBase", (char **)keyword_list, &param0)) {
    CInterpolatedVarArrayBase< LVector2f, false > *return_value = new CInterpolatedVarArrayBase< LVector2f, false >((char const *)param0);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CInterpolatedVarArrayBase_LVector2f_false, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CInterpolatedVarArrayBase(str pDebugName)\n");
  }
  return -1;
}

CInterpolatedVarArrayBase< LVector2f, false > *Dtool_Coerce_CInterpolatedVarArrayBase_LVector2f_false(PyObject *args, CInterpolatedVarArrayBase< LVector2f, false > &coerced) {
  CInterpolatedVarArrayBase< LVector2f, false > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_CInterpolatedVarArrayBase_LVector2f_false)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const CInterpolatedVarArrayBase< LVector2f, false > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CInterpolatedVarArrayBase< LVector2f, false >::CInterpolatedVarArrayBase(char const *pDebugName)
    char const *param0;
    if (PyArg_Parse(arg, "z:CInterpolatedVarArrayBase", &param0)) {
      coerced = CInterpolatedVarArrayBase< LVector2f, false >((char const *)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
    PyErr_Clear();
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_CInterpolatedVarArrayBase_LVector2f_false(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CInterpolatedVarArrayBase_LVector2f_false) {
    printf("CInterpolatedVarArrayBase_LVector2f_false ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CInterpolatedVarArrayBase< LVector2f, false > *local_this = (CInterpolatedVarArrayBase< LVector2f, false > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CInterpolatedVarArrayBase_LVector2f_false) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_IInterpolatedVar) {
    return (IInterpolatedVar *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CInterpolatedVarArrayBase_LVector2f_false(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CInterpolatedVarArrayBase_LVector2f_false) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_IInterpolatedVar) {
    IInterpolatedVar* other_this = (IInterpolatedVar*)from_this;
    return (CInterpolatedVarArrayBase< LVector2f, false >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CInterpolatedVar< LVector3f >
 */
/**
 * Python function wrapper for:
 * CInterpolatedVar< LVector3f >::CInterpolatedVar(char const *pDebugName = 0)
 */
static int Dtool_Init_CInterpolatedVar_LVector3f(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-CInterpolatedVar< LVector3f >::CInterpolatedVar(char const *pDebugName = 0)
  char const *param0 = 0;
  static const char *keyword_list[] = {"pDebugName", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|z:CInterpolatedVar", (char **)keyword_list, &param0)) {
    CInterpolatedVar< LVector3f > *return_value = new CInterpolatedVar< LVector3f >((char const *)param0);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CInterpolatedVar_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CInterpolatedVar(str pDebugName)\n");
  }
  return -1;
}

CInterpolatedVar< LVector3f > *Dtool_Coerce_CInterpolatedVar_LVector3f(PyObject *args, CInterpolatedVar< LVector3f > &coerced) {
  CInterpolatedVar< LVector3f > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_CInterpolatedVar_LVector3f)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const CInterpolatedVar< LVector3f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CInterpolatedVar< LVector3f >::CInterpolatedVar(char const *pDebugName)
    char const *param0;
    if (PyArg_Parse(arg, "z:CInterpolatedVar", &param0)) {
      coerced = CInterpolatedVar< LVector3f >((char const *)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
    PyErr_Clear();
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_CInterpolatedVar_LVector3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CInterpolatedVar_LVector3f) {
    printf("CInterpolatedVar_LVector3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CInterpolatedVar< LVector3f > *local_this = (CInterpolatedVar< LVector3f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CInterpolatedVar_LVector3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterpolatedVarArrayBase_LVector3f_false) {
    return (CInterpolatedVarArrayBase< LVector3f, false > *) local_this;
  }
  if (requested_type == Dtool_Ptr_IInterpolatedVar) {
    return (IInterpolatedVar *)(CInterpolatedVarArrayBase< LVector3f, false > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CInterpolatedVar_LVector3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CInterpolatedVar_LVector3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterpolatedVarArrayBase_LVector3f_false) {
    CInterpolatedVarArrayBase< LVector3f, false >* other_this = (CInterpolatedVarArrayBase< LVector3f, false >*)from_this;
    return (CInterpolatedVar< LVector3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_IInterpolatedVar) {
    IInterpolatedVar* other_this = (IInterpolatedVar*)from_this;
    return (CInterpolatedVar< LVector3f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CInterpolatedVarArrayBase< LVector3f, false >
 */
/**
 * Python function wrapper for:
 * virtual void CInterpolatedVarArrayBase< LVector3f, false >::Setup(LVector3f *pValue, int type)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_Setup_571(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.Setup")) {
    return nullptr;
  }
  // 1-virtual void CInterpolatedVarArrayBase< LVector3f, false >::Setup(LVector3f *pValue, int type)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"pValue", "type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:Setup", (char **)keyword_list, &param1, &param2)) {
    LVector3f param1_local;
    LVector3f *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CInterpolatedVarArrayBase.Setup", "LVector3f");
    }
    ((*local_this).Setup)(param1_this, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Setup(const CInterpolatedVarArrayBase self, LVector3f pValue, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_Setup_571_comment =
  "C++ Interface:\n"
  "Setup(const CInterpolatedVarArrayBase self, LVector3f pValue, int type)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_Setup_571_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CInterpolatedVarArrayBase< LVector3f, false >::NoteChanged(float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_NoteChanged_572(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.NoteChanged")) {
    return nullptr;
  }
  // 1-bool CInterpolatedVarArrayBase< LVector3f, false >::NoteChanged(float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)
  float param1;
  float param2;
  PyObject *param3;
  static const char *keyword_list[] = {"changetime", "interpolation_amount", "bUpdateLastNetworkedValue", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:NoteChanged", (char **)keyword_list, &param1, &param2, &param3)) {
    bool return_value = ((*local_this).NoteChanged)((float)param1, (float)param2, (PyObject_IsTrue(param3) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "NoteChanged(const CInterpolatedVarArrayBase self, float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_NoteChanged_572_comment =
  "C++ Interface:\n"
  "NoteChanged(const CInterpolatedVarArrayBase self, float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)\n"
  "\n"
  "// Just like the IInterpolatedVar functions, but you can specify an\n"
  "// interpolation amount.";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_NoteChanged_572_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< LVector3f, false >::Interpolate(float currentTime, float interpolation_amount)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_Interpolate_573(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.Interpolate")) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< LVector3f, false >::Interpolate(float currentTime, float interpolation_amount)
  float param1;
  float param2;
  static const char *keyword_list[] = {"currentTime", "interpolation_amount", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:Interpolate", (char **)keyword_list, &param1, &param2)) {
    int return_value = ((*local_this).Interpolate)((float)param1, (float)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Interpolate(const CInterpolatedVarArrayBase self, float currentTime, float interpolation_amount)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_Interpolate_573_comment =
  "C++ Interface:\n"
  "Interpolate(const CInterpolatedVarArrayBase self, float currentTime, float interpolation_amount)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_Interpolate_573_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector3f, false >::DebugInterpolate(LVector3f *pOut, float currentTime)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_DebugInterpolate_574(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.DebugInterpolate")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector3f, false >::DebugInterpolate(LVector3f *pOut, float currentTime)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"pOut", "currentTime", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:DebugInterpolate", (char **)keyword_list, &param1, &param2)) {
    LVector3f param1_local;
    LVector3f *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CInterpolatedVarArrayBase.DebugInterpolate", "LVector3f");
    }
    ((*local_this).DebugInterpolate)(param1_this, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "DebugInterpolate(const CInterpolatedVarArrayBase self, LVector3f pOut, float currentTime)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_DebugInterpolate_574_comment =
  "C++ Interface:\n"
  "DebugInterpolate(const CInterpolatedVarArrayBase self, LVector3f pOut, float currentTime)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_DebugInterpolate_574_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector3f, false >::GetDerivative(LVector3f *pOut, float currentTime)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetDerivative_575(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.GetDerivative")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector3f, false >::GetDerivative(LVector3f *pOut, float currentTime)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"pOut", "currentTime", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:GetDerivative", (char **)keyword_list, &param1, &param2)) {
    LVector3f param1_local;
    LVector3f *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CInterpolatedVarArrayBase.GetDerivative", "LVector3f");
    }
    ((*local_this).GetDerivative)(param1_this, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetDerivative(const CInterpolatedVarArrayBase self, LVector3f pOut, float currentTime)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetDerivative_575_comment =
  "C++ Interface:\n"
  "GetDerivative(const CInterpolatedVarArrayBase self, LVector3f pOut, float currentTime)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetDerivative_575_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector3f, false >::GetDerivative_SmoothVelocity(LVector3f *pOut, float currentTime)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetDerivative_SmoothVelocity_576(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.GetDerivative_SmoothVelocity")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector3f, false >::GetDerivative_SmoothVelocity(LVector3f *pOut, float currentTime)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"pOut", "currentTime", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:GetDerivative_SmoothVelocity", (char **)keyword_list, &param1, &param2)) {
    LVector3f param1_local;
    LVector3f *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CInterpolatedVarArrayBase.GetDerivative_SmoothVelocity", "LVector3f");
    }
    ((*local_this).GetDerivative_SmoothVelocity)(param1_this, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetDerivative_SmoothVelocity(const CInterpolatedVarArrayBase self, LVector3f pOut, float currentTime)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetDerivative_SmoothVelocity_576_comment =
  "C++ Interface:\n"
  "GetDerivative_SmoothVelocity(const CInterpolatedVarArrayBase self, LVector3f pOut, float currentTime)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetDerivative_SmoothVelocity_576_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector3f, false >::ClearHistory(void)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_ClearHistory_577(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.ClearHistory")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector3f, false >::ClearHistory(void)
  ((*local_this).ClearHistory)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_ClearHistory_577_comment =
  "C++ Interface:\n"
  "ClearHistory(const CInterpolatedVarArrayBase self)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_ClearHistory_577_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector3f, false >::AddToHead(float changeTime, LVector3f const *values, bool bFlushNewer)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_AddToHead_578(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.AddToHead")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector3f, false >::AddToHead(float changeTime, LVector3f const *values, bool bFlushNewer)
  float param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"changeTime", "values", "bFlushNewer", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fOO:AddToHead", (char **)keyword_list, &param1, &param2, &param3)) {
    LVector3f param2_local;
    LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CInterpolatedVarArrayBase.AddToHead", "LVector3f");
    }
    ((*local_this).AddToHead)((float)param1, param2_this, (PyObject_IsTrue(param3) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "AddToHead(const CInterpolatedVarArrayBase self, float changeTime, const LVector3f values, bool bFlushNewer)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_AddToHead_578_comment =
  "C++ Interface:\n"
  "AddToHead(const CInterpolatedVarArrayBase self, float changeTime, const LVector3f values, bool bFlushNewer)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_AddToHead_578_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3f const &CInterpolatedVarArrayBase< LVector3f, false >::GetPrev(int iArrayIndex = 0) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetPrev_579(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_LVector3f_false)) {
    return nullptr;
  }
  // 1-LVector3f const &CInterpolatedVarArrayBase< LVector3f, false >::GetPrev(int iArrayIndex = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"iArrayIndex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:GetPrev", (char **)keyword_list, &param1)) {
    LVector3f const *return_value = &(((*(const CInterpolatedVarArrayBase< LVector3f, false >*)local_this).GetPrev)((int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetPrev(CInterpolatedVarArrayBase self, int iArrayIndex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetPrev_579_comment =
  "C++ Interface:\n"
  "GetPrev(CInterpolatedVarArrayBase self, int iArrayIndex)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetPrev_579_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3f const &CInterpolatedVarArrayBase< LVector3f, false >::GetCurrent(int iArrayIndex = 0) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetCurrent_580(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_LVector3f_false)) {
    return nullptr;
  }
  // 1-LVector3f const &CInterpolatedVarArrayBase< LVector3f, false >::GetCurrent(int iArrayIndex = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"iArrayIndex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:GetCurrent", (char **)keyword_list, &param1)) {
    LVector3f const *return_value = &(((*(const CInterpolatedVarArrayBase< LVector3f, false >*)local_this).GetCurrent)((int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetCurrent(CInterpolatedVarArrayBase self, int iArrayIndex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetCurrent_580_comment =
  "C++ Interface:\n"
  "GetCurrent(CInterpolatedVarArrayBase self, int iArrayIndex)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetCurrent_580_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float CInterpolatedVarArrayBase< LVector3f, false >::GetInterval(void) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetInterval_581(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_LVector3f_false)) {
    return nullptr;
  }
  // 1-float CInterpolatedVarArrayBase< LVector3f, false >::GetInterval(void) const
  float return_value = ((*(const CInterpolatedVarArrayBase< LVector3f, false >*)local_this).GetInterval)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetInterval_581_comment =
  "C++ Interface:\n"
  "GetInterval(CInterpolatedVarArrayBase self)\n"
  "\n"
  "// Returns the time difference betweem the most recent sample and its previous\n"
  "// sample.";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetInterval_581_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CInterpolatedVarArrayBase< LVector3f, false >::IsValidIndex(int i)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_IsValidIndex_582(PyObject *self, PyObject *arg) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.IsValidIndex")) {
    return nullptr;
  }
  // 1-bool CInterpolatedVarArrayBase< LVector3f, false >::IsValidIndex(int i)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).IsValidIndex)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "IsValidIndex(const CInterpolatedVarArrayBase self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_IsValidIndex_582_comment =
  "C++ Interface:\n"
  "IsValidIndex(const CInterpolatedVarArrayBase self, int i)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_IsValidIndex_582_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< LVector3f, false >::GetHead(void)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetHead_584(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.GetHead")) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< LVector3f, false >::GetHead(void)
  int return_value = ((*local_this).GetHead)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetHead_584_comment =
  "C++ Interface:\n"
  "GetHead(const CInterpolatedVarArrayBase self)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetHead_584_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< LVector3f, false >::GetNext(int i)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetNext_585(PyObject *self, PyObject *arg) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.GetNext")) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< LVector3f, false >::GetNext(int i)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).GetNext)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetNext(const CInterpolatedVarArrayBase self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetNext_585_comment =
  "C++ Interface:\n"
  "GetNext(const CInterpolatedVarArrayBase self, int i)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetNext_585_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector3f, false >::SetHistoryValuesForItem(int item, LVector3f &value)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetHistoryValuesForItem_586(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.SetHistoryValuesForItem")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector3f, false >::SetHistoryValuesForItem(int item, LVector3f &value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"item", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:SetHistoryValuesForItem", (char **)keyword_list, &param1, &param2)) {
    LVector3f param2_local;
    LVector3f *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CInterpolatedVarArrayBase.SetHistoryValuesForItem", "LVector3f");
    }
    ((*local_this).SetHistoryValuesForItem)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetHistoryValuesForItem(const CInterpolatedVarArrayBase self, int item, LVector3f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetHistoryValuesForItem_586_comment =
  "C++ Interface:\n"
  "SetHistoryValuesForItem(const CInterpolatedVarArrayBase self, int item, LVector3f value)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetHistoryValuesForItem_586_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector3f, false >::SetLooping(bool looping, int iArrayIndex = 0)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetLooping_587(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.SetLooping")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector3f, false >::SetLooping(bool looping, int iArrayIndex = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"looping", "iArrayIndex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:SetLooping", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).SetLooping)((PyObject_IsTrue(param1) != 0), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetLooping(const CInterpolatedVarArrayBase self, bool looping, int iArrayIndex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetLooping_587_comment =
  "C++ Interface:\n"
  "SetLooping(const CInterpolatedVarArrayBase self, bool looping, int iArrayIndex)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetLooping_587_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector3f, false >::SetMaxCount(int newmax)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetMaxCount_588(PyObject *self, PyObject *arg) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.SetMaxCount")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector3f, false >::SetMaxCount(int newmax)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).SetMaxCount)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetMaxCount(const CInterpolatedVarArrayBase self, int newmax)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetMaxCount_588_comment =
  "C++ Interface:\n"
  "SetMaxCount(const CInterpolatedVarArrayBase self, int newmax)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetMaxCount_588_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< LVector3f, false >::GetMaxCount(void) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetMaxCount_589(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_LVector3f_false)) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< LVector3f, false >::GetMaxCount(void) const
  int return_value = ((*(const CInterpolatedVarArrayBase< LVector3f, false >*)local_this).GetMaxCount)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetMaxCount_589_comment =
  "C++ Interface:\n"
  "GetMaxCount(CInterpolatedVarArrayBase self)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetMaxCount_589_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float CInterpolatedVarArrayBase< LVector3f, false >::GetOldestEntry(void)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetOldestEntry_590(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector3f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector3f_false.GetOldestEntry")) {
    return nullptr;
  }
  // 1-float CInterpolatedVarArrayBase< LVector3f, false >::GetOldestEntry(void)
  float return_value = ((*local_this).GetOldestEntry)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetOldestEntry_590_comment =
  "C++ Interface:\n"
  "GetOldestEntry(const CInterpolatedVarArrayBase self)\n"
  "\n"
  "// Get the time of the oldest entry.";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetOldestEntry_590_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CInterpolatedVarArrayBase< LVector3f, false >::CInterpolatedVarArrayBase(char const *pDebugName = "no debug name")
 */
static int Dtool_Init_CInterpolatedVarArrayBase_LVector3f_false(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-CInterpolatedVarArrayBase< LVector3f, false >::CInterpolatedVarArrayBase(char const *pDebugName = "no debug name")
  char const *param0 = "no debug name";
  static const char *keyword_list[] = {"pDebugName", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|z:CInterpolatedVarArrayBase", (char **)keyword_list, &param0)) {
    CInterpolatedVarArrayBase< LVector3f, false > *return_value = new CInterpolatedVarArrayBase< LVector3f, false >((char const *)param0);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CInterpolatedVarArrayBase_LVector3f_false, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CInterpolatedVarArrayBase(str pDebugName)\n");
  }
  return -1;
}

CInterpolatedVarArrayBase< LVector3f, false > *Dtool_Coerce_CInterpolatedVarArrayBase_LVector3f_false(PyObject *args, CInterpolatedVarArrayBase< LVector3f, false > &coerced) {
  CInterpolatedVarArrayBase< LVector3f, false > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_CInterpolatedVarArrayBase_LVector3f_false)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const CInterpolatedVarArrayBase< LVector3f, false > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CInterpolatedVarArrayBase< LVector3f, false >::CInterpolatedVarArrayBase(char const *pDebugName)
    char const *param0;
    if (PyArg_Parse(arg, "z:CInterpolatedVarArrayBase", &param0)) {
      coerced = CInterpolatedVarArrayBase< LVector3f, false >((char const *)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
    PyErr_Clear();
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_CInterpolatedVarArrayBase_LVector3f_false(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CInterpolatedVarArrayBase_LVector3f_false) {
    printf("CInterpolatedVarArrayBase_LVector3f_false ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CInterpolatedVarArrayBase< LVector3f, false > *local_this = (CInterpolatedVarArrayBase< LVector3f, false > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CInterpolatedVarArrayBase_LVector3f_false) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_IInterpolatedVar) {
    return (IInterpolatedVar *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CInterpolatedVarArrayBase_LVector3f_false(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CInterpolatedVarArrayBase_LVector3f_false) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_IInterpolatedVar) {
    IInterpolatedVar* other_this = (IInterpolatedVar*)from_this;
    return (CInterpolatedVarArrayBase< LVector3f, false >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CInterpolatedVar< LVector4f >
 */
/**
 * Python function wrapper for:
 * CInterpolatedVar< LVector4f >::CInterpolatedVar(char const *pDebugName = 0)
 */
static int Dtool_Init_CInterpolatedVar_LVector4f(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-CInterpolatedVar< LVector4f >::CInterpolatedVar(char const *pDebugName = 0)
  char const *param0 = 0;
  static const char *keyword_list[] = {"pDebugName", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|z:CInterpolatedVar", (char **)keyword_list, &param0)) {
    CInterpolatedVar< LVector4f > *return_value = new CInterpolatedVar< LVector4f >((char const *)param0);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CInterpolatedVar_LVector4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CInterpolatedVar(str pDebugName)\n");
  }
  return -1;
}

CInterpolatedVar< LVector4f > *Dtool_Coerce_CInterpolatedVar_LVector4f(PyObject *args, CInterpolatedVar< LVector4f > &coerced) {
  CInterpolatedVar< LVector4f > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_CInterpolatedVar_LVector4f)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const CInterpolatedVar< LVector4f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CInterpolatedVar< LVector4f >::CInterpolatedVar(char const *pDebugName)
    char const *param0;
    if (PyArg_Parse(arg, "z:CInterpolatedVar", &param0)) {
      coerced = CInterpolatedVar< LVector4f >((char const *)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
    PyErr_Clear();
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_CInterpolatedVar_LVector4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CInterpolatedVar_LVector4f) {
    printf("CInterpolatedVar_LVector4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CInterpolatedVar< LVector4f > *local_this = (CInterpolatedVar< LVector4f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CInterpolatedVar_LVector4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterpolatedVarArrayBase_LVector4f_false) {
    return (CInterpolatedVarArrayBase< LVector4f, false > *) local_this;
  }
  if (requested_type == Dtool_Ptr_IInterpolatedVar) {
    return (IInterpolatedVar *)(CInterpolatedVarArrayBase< LVector4f, false > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CInterpolatedVar_LVector4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CInterpolatedVar_LVector4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterpolatedVarArrayBase_LVector4f_false) {
    CInterpolatedVarArrayBase< LVector4f, false >* other_this = (CInterpolatedVarArrayBase< LVector4f, false >*)from_this;
    return (CInterpolatedVar< LVector4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_IInterpolatedVar) {
    IInterpolatedVar* other_this = (IInterpolatedVar*)from_this;
    return (CInterpolatedVar< LVector4f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CInterpolatedVarArrayBase< LVector4f, false >
 */
/**
 * Python function wrapper for:
 * virtual void CInterpolatedVarArrayBase< LVector4f, false >::Setup(LVector4f *pValue, int type)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_Setup_598(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.Setup")) {
    return nullptr;
  }
  // 1-virtual void CInterpolatedVarArrayBase< LVector4f, false >::Setup(LVector4f *pValue, int type)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"pValue", "type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:Setup", (char **)keyword_list, &param1, &param2)) {
    LVector4f param1_local;
    LVector4f *param1_this = Dtool_Coerce_LVector4f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CInterpolatedVarArrayBase.Setup", "LVector4f");
    }
    ((*local_this).Setup)(param1_this, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Setup(const CInterpolatedVarArrayBase self, LVector4f pValue, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_Setup_598_comment =
  "C++ Interface:\n"
  "Setup(const CInterpolatedVarArrayBase self, LVector4f pValue, int type)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_Setup_598_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CInterpolatedVarArrayBase< LVector4f, false >::NoteChanged(float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_NoteChanged_599(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.NoteChanged")) {
    return nullptr;
  }
  // 1-bool CInterpolatedVarArrayBase< LVector4f, false >::NoteChanged(float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)
  float param1;
  float param2;
  PyObject *param3;
  static const char *keyword_list[] = {"changetime", "interpolation_amount", "bUpdateLastNetworkedValue", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:NoteChanged", (char **)keyword_list, &param1, &param2, &param3)) {
    bool return_value = ((*local_this).NoteChanged)((float)param1, (float)param2, (PyObject_IsTrue(param3) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "NoteChanged(const CInterpolatedVarArrayBase self, float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_NoteChanged_599_comment =
  "C++ Interface:\n"
  "NoteChanged(const CInterpolatedVarArrayBase self, float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)\n"
  "\n"
  "// Just like the IInterpolatedVar functions, but you can specify an\n"
  "// interpolation amount.";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_NoteChanged_599_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< LVector4f, false >::Interpolate(float currentTime, float interpolation_amount)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_Interpolate_600(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.Interpolate")) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< LVector4f, false >::Interpolate(float currentTime, float interpolation_amount)
  float param1;
  float param2;
  static const char *keyword_list[] = {"currentTime", "interpolation_amount", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:Interpolate", (char **)keyword_list, &param1, &param2)) {
    int return_value = ((*local_this).Interpolate)((float)param1, (float)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Interpolate(const CInterpolatedVarArrayBase self, float currentTime, float interpolation_amount)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_Interpolate_600_comment =
  "C++ Interface:\n"
  "Interpolate(const CInterpolatedVarArrayBase self, float currentTime, float interpolation_amount)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_Interpolate_600_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector4f, false >::DebugInterpolate(LVector4f *pOut, float currentTime)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_DebugInterpolate_601(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.DebugInterpolate")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector4f, false >::DebugInterpolate(LVector4f *pOut, float currentTime)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"pOut", "currentTime", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:DebugInterpolate", (char **)keyword_list, &param1, &param2)) {
    LVector4f param1_local;
    LVector4f *param1_this = Dtool_Coerce_LVector4f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CInterpolatedVarArrayBase.DebugInterpolate", "LVector4f");
    }
    ((*local_this).DebugInterpolate)(param1_this, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "DebugInterpolate(const CInterpolatedVarArrayBase self, LVector4f pOut, float currentTime)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_DebugInterpolate_601_comment =
  "C++ Interface:\n"
  "DebugInterpolate(const CInterpolatedVarArrayBase self, LVector4f pOut, float currentTime)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_DebugInterpolate_601_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector4f, false >::GetDerivative(LVector4f *pOut, float currentTime)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetDerivative_602(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.GetDerivative")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector4f, false >::GetDerivative(LVector4f *pOut, float currentTime)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"pOut", "currentTime", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:GetDerivative", (char **)keyword_list, &param1, &param2)) {
    LVector4f param1_local;
    LVector4f *param1_this = Dtool_Coerce_LVector4f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CInterpolatedVarArrayBase.GetDerivative", "LVector4f");
    }
    ((*local_this).GetDerivative)(param1_this, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetDerivative(const CInterpolatedVarArrayBase self, LVector4f pOut, float currentTime)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetDerivative_602_comment =
  "C++ Interface:\n"
  "GetDerivative(const CInterpolatedVarArrayBase self, LVector4f pOut, float currentTime)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetDerivative_602_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector4f, false >::GetDerivative_SmoothVelocity(LVector4f *pOut, float currentTime)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetDerivative_SmoothVelocity_603(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.GetDerivative_SmoothVelocity")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector4f, false >::GetDerivative_SmoothVelocity(LVector4f *pOut, float currentTime)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"pOut", "currentTime", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:GetDerivative_SmoothVelocity", (char **)keyword_list, &param1, &param2)) {
    LVector4f param1_local;
    LVector4f *param1_this = Dtool_Coerce_LVector4f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CInterpolatedVarArrayBase.GetDerivative_SmoothVelocity", "LVector4f");
    }
    ((*local_this).GetDerivative_SmoothVelocity)(param1_this, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetDerivative_SmoothVelocity(const CInterpolatedVarArrayBase self, LVector4f pOut, float currentTime)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetDerivative_SmoothVelocity_603_comment =
  "C++ Interface:\n"
  "GetDerivative_SmoothVelocity(const CInterpolatedVarArrayBase self, LVector4f pOut, float currentTime)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetDerivative_SmoothVelocity_603_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector4f, false >::ClearHistory(void)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_ClearHistory_604(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.ClearHistory")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector4f, false >::ClearHistory(void)
  ((*local_this).ClearHistory)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_ClearHistory_604_comment =
  "C++ Interface:\n"
  "ClearHistory(const CInterpolatedVarArrayBase self)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_ClearHistory_604_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector4f, false >::AddToHead(float changeTime, LVector4f const *values, bool bFlushNewer)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_AddToHead_605(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.AddToHead")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector4f, false >::AddToHead(float changeTime, LVector4f const *values, bool bFlushNewer)
  float param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"changeTime", "values", "bFlushNewer", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fOO:AddToHead", (char **)keyword_list, &param1, &param2, &param3)) {
    LVector4f param2_local;
    LVector4f const *param2_this = Dtool_Coerce_LVector4f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CInterpolatedVarArrayBase.AddToHead", "LVector4f");
    }
    ((*local_this).AddToHead)((float)param1, param2_this, (PyObject_IsTrue(param3) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "AddToHead(const CInterpolatedVarArrayBase self, float changeTime, const LVector4f values, bool bFlushNewer)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_AddToHead_605_comment =
  "C++ Interface:\n"
  "AddToHead(const CInterpolatedVarArrayBase self, float changeTime, const LVector4f values, bool bFlushNewer)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_AddToHead_605_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector4f const &CInterpolatedVarArrayBase< LVector4f, false >::GetPrev(int iArrayIndex = 0) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetPrev_606(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_LVector4f_false)) {
    return nullptr;
  }
  // 1-LVector4f const &CInterpolatedVarArrayBase< LVector4f, false >::GetPrev(int iArrayIndex = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"iArrayIndex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:GetPrev", (char **)keyword_list, &param1)) {
    LVector4f const *return_value = &(((*(const CInterpolatedVarArrayBase< LVector4f, false >*)local_this).GetPrev)((int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetPrev(CInterpolatedVarArrayBase self, int iArrayIndex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetPrev_606_comment =
  "C++ Interface:\n"
  "GetPrev(CInterpolatedVarArrayBase self, int iArrayIndex)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetPrev_606_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector4f const &CInterpolatedVarArrayBase< LVector4f, false >::GetCurrent(int iArrayIndex = 0) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetCurrent_607(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_LVector4f_false)) {
    return nullptr;
  }
  // 1-LVector4f const &CInterpolatedVarArrayBase< LVector4f, false >::GetCurrent(int iArrayIndex = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"iArrayIndex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:GetCurrent", (char **)keyword_list, &param1)) {
    LVector4f const *return_value = &(((*(const CInterpolatedVarArrayBase< LVector4f, false >*)local_this).GetCurrent)((int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetCurrent(CInterpolatedVarArrayBase self, int iArrayIndex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetCurrent_607_comment =
  "C++ Interface:\n"
  "GetCurrent(CInterpolatedVarArrayBase self, int iArrayIndex)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetCurrent_607_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float CInterpolatedVarArrayBase< LVector4f, false >::GetInterval(void) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetInterval_608(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_LVector4f_false)) {
    return nullptr;
  }
  // 1-float CInterpolatedVarArrayBase< LVector4f, false >::GetInterval(void) const
  float return_value = ((*(const CInterpolatedVarArrayBase< LVector4f, false >*)local_this).GetInterval)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetInterval_608_comment =
  "C++ Interface:\n"
  "GetInterval(CInterpolatedVarArrayBase self)\n"
  "\n"
  "// Returns the time difference betweem the most recent sample and its previous\n"
  "// sample.";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetInterval_608_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CInterpolatedVarArrayBase< LVector4f, false >::IsValidIndex(int i)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_IsValidIndex_609(PyObject *self, PyObject *arg) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.IsValidIndex")) {
    return nullptr;
  }
  // 1-bool CInterpolatedVarArrayBase< LVector4f, false >::IsValidIndex(int i)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).IsValidIndex)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "IsValidIndex(const CInterpolatedVarArrayBase self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_IsValidIndex_609_comment =
  "C++ Interface:\n"
  "IsValidIndex(const CInterpolatedVarArrayBase self, int i)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_IsValidIndex_609_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< LVector4f, false >::GetHead(void)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetHead_611(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.GetHead")) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< LVector4f, false >::GetHead(void)
  int return_value = ((*local_this).GetHead)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetHead_611_comment =
  "C++ Interface:\n"
  "GetHead(const CInterpolatedVarArrayBase self)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetHead_611_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< LVector4f, false >::GetNext(int i)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetNext_612(PyObject *self, PyObject *arg) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.GetNext")) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< LVector4f, false >::GetNext(int i)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).GetNext)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetNext(const CInterpolatedVarArrayBase self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetNext_612_comment =
  "C++ Interface:\n"
  "GetNext(const CInterpolatedVarArrayBase self, int i)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetNext_612_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector4f, false >::SetHistoryValuesForItem(int item, LVector4f &value)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetHistoryValuesForItem_613(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.SetHistoryValuesForItem")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector4f, false >::SetHistoryValuesForItem(int item, LVector4f &value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"item", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:SetHistoryValuesForItem", (char **)keyword_list, &param1, &param2)) {
    LVector4f param2_local;
    LVector4f *param2_this = Dtool_Coerce_LVector4f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CInterpolatedVarArrayBase.SetHistoryValuesForItem", "LVector4f");
    }
    ((*local_this).SetHistoryValuesForItem)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetHistoryValuesForItem(const CInterpolatedVarArrayBase self, int item, LVector4f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetHistoryValuesForItem_613_comment =
  "C++ Interface:\n"
  "SetHistoryValuesForItem(const CInterpolatedVarArrayBase self, int item, LVector4f value)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetHistoryValuesForItem_613_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector4f, false >::SetLooping(bool looping, int iArrayIndex = 0)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetLooping_614(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.SetLooping")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector4f, false >::SetLooping(bool looping, int iArrayIndex = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"looping", "iArrayIndex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:SetLooping", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).SetLooping)((PyObject_IsTrue(param1) != 0), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetLooping(const CInterpolatedVarArrayBase self, bool looping, int iArrayIndex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetLooping_614_comment =
  "C++ Interface:\n"
  "SetLooping(const CInterpolatedVarArrayBase self, bool looping, int iArrayIndex)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetLooping_614_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< LVector4f, false >::SetMaxCount(int newmax)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetMaxCount_615(PyObject *self, PyObject *arg) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.SetMaxCount")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< LVector4f, false >::SetMaxCount(int newmax)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).SetMaxCount)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetMaxCount(const CInterpolatedVarArrayBase self, int newmax)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetMaxCount_615_comment =
  "C++ Interface:\n"
  "SetMaxCount(const CInterpolatedVarArrayBase self, int newmax)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetMaxCount_615_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< LVector4f, false >::GetMaxCount(void) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetMaxCount_616(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_LVector4f_false)) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< LVector4f, false >::GetMaxCount(void) const
  int return_value = ((*(const CInterpolatedVarArrayBase< LVector4f, false >*)local_this).GetMaxCount)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetMaxCount_616_comment =
  "C++ Interface:\n"
  "GetMaxCount(CInterpolatedVarArrayBase self)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetMaxCount_616_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float CInterpolatedVarArrayBase< LVector4f, false >::GetOldestEntry(void)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetOldestEntry_617(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_LVector4f_false, (void **)&local_this, "CInterpolatedVarArrayBase_LVector4f_false.GetOldestEntry")) {
    return nullptr;
  }
  // 1-float CInterpolatedVarArrayBase< LVector4f, false >::GetOldestEntry(void)
  float return_value = ((*local_this).GetOldestEntry)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetOldestEntry_617_comment =
  "C++ Interface:\n"
  "GetOldestEntry(const CInterpolatedVarArrayBase self)\n"
  "\n"
  "// Get the time of the oldest entry.";
#else
static const char *Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetOldestEntry_617_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CInterpolatedVarArrayBase< LVector4f, false >::CInterpolatedVarArrayBase(char const *pDebugName = "no debug name")
 */
static int Dtool_Init_CInterpolatedVarArrayBase_LVector4f_false(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-CInterpolatedVarArrayBase< LVector4f, false >::CInterpolatedVarArrayBase(char const *pDebugName = "no debug name")
  char const *param0 = "no debug name";
  static const char *keyword_list[] = {"pDebugName", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|z:CInterpolatedVarArrayBase", (char **)keyword_list, &param0)) {
    CInterpolatedVarArrayBase< LVector4f, false > *return_value = new CInterpolatedVarArrayBase< LVector4f, false >((char const *)param0);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CInterpolatedVarArrayBase_LVector4f_false, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CInterpolatedVarArrayBase(str pDebugName)\n");
  }
  return -1;
}

CInterpolatedVarArrayBase< LVector4f, false > *Dtool_Coerce_CInterpolatedVarArrayBase_LVector4f_false(PyObject *args, CInterpolatedVarArrayBase< LVector4f, false > &coerced) {
  CInterpolatedVarArrayBase< LVector4f, false > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_CInterpolatedVarArrayBase_LVector4f_false)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const CInterpolatedVarArrayBase< LVector4f, false > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CInterpolatedVarArrayBase< LVector4f, false >::CInterpolatedVarArrayBase(char const *pDebugName)
    char const *param0;
    if (PyArg_Parse(arg, "z:CInterpolatedVarArrayBase", &param0)) {
      coerced = CInterpolatedVarArrayBase< LVector4f, false >((char const *)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
    PyErr_Clear();
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_CInterpolatedVarArrayBase_LVector4f_false(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CInterpolatedVarArrayBase_LVector4f_false) {
    printf("CInterpolatedVarArrayBase_LVector4f_false ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CInterpolatedVarArrayBase< LVector4f, false > *local_this = (CInterpolatedVarArrayBase< LVector4f, false > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CInterpolatedVarArrayBase_LVector4f_false) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_IInterpolatedVar) {
    return (IInterpolatedVar *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CInterpolatedVarArrayBase_LVector4f_false(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CInterpolatedVarArrayBase_LVector4f_false) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_IInterpolatedVar) {
    IInterpolatedVar* other_this = (IInterpolatedVar*)from_this;
    return (CInterpolatedVarArrayBase< LVector4f, false >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CInterpolatedVar< float >
 */
/**
 * Python function wrapper for:
 * CInterpolatedVar< float >::CInterpolatedVar(char const *pDebugName = 0)
 */
static int Dtool_Init_CInterpolatedVar_float(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-CInterpolatedVar< float >::CInterpolatedVar(char const *pDebugName = 0)
  char const *param0 = 0;
  static const char *keyword_list[] = {"pDebugName", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|z:CInterpolatedVar", (char **)keyword_list, &param0)) {
    CInterpolatedVar< float > *return_value = new CInterpolatedVar< float >((char const *)param0);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CInterpolatedVar_float, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CInterpolatedVar(str pDebugName)\n");
  }
  return -1;
}

CInterpolatedVar< float > *Dtool_Coerce_CInterpolatedVar_float(PyObject *args, CInterpolatedVar< float > &coerced) {
  CInterpolatedVar< float > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_CInterpolatedVar_float)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const CInterpolatedVar< float > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CInterpolatedVar< float >::CInterpolatedVar(char const *pDebugName)
    char const *param0;
    if (PyArg_Parse(arg, "z:CInterpolatedVar", &param0)) {
      coerced = CInterpolatedVar< float >((char const *)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
    PyErr_Clear();
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_CInterpolatedVar_float(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CInterpolatedVar_float) {
    printf("CInterpolatedVar_float ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CInterpolatedVar< float > *local_this = (CInterpolatedVar< float > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CInterpolatedVar_float) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterpolatedVarArrayBase_float_false) {
    return (CInterpolatedVarArrayBase< float, false > *) local_this;
  }
  if (requested_type == Dtool_Ptr_IInterpolatedVar) {
    return (IInterpolatedVar *)(CInterpolatedVarArrayBase< float, false > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CInterpolatedVar_float(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CInterpolatedVar_float) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterpolatedVarArrayBase_float_false) {
    CInterpolatedVarArrayBase< float, false >* other_this = (CInterpolatedVarArrayBase< float, false >*)from_this;
    return (CInterpolatedVar< float >*)other_this;
  }
  if (from_type == Dtool_Ptr_IInterpolatedVar) {
    IInterpolatedVar* other_this = (IInterpolatedVar*)from_this;
    return (CInterpolatedVar< float >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CInterpolatedVarArrayBase< float, false >
 */
/**
 * Python function wrapper for:
 * bool CInterpolatedVarArrayBase< float, false >::NoteChanged(float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_float_false_NoteChanged_626(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< float, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_float_false, (void **)&local_this, "CInterpolatedVarArrayBase_float_false.NoteChanged")) {
    return nullptr;
  }
  // 1-bool CInterpolatedVarArrayBase< float, false >::NoteChanged(float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)
  float param1;
  float param2;
  PyObject *param3;
  static const char *keyword_list[] = {"changetime", "interpolation_amount", "bUpdateLastNetworkedValue", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:NoteChanged", (char **)keyword_list, &param1, &param2, &param3)) {
    bool return_value = ((*local_this).NoteChanged)((float)param1, (float)param2, (PyObject_IsTrue(param3) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "NoteChanged(const CInterpolatedVarArrayBase self, float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_float_false_NoteChanged_626_comment =
  "C++ Interface:\n"
  "NoteChanged(const CInterpolatedVarArrayBase self, float changetime, float interpolation_amount, bool bUpdateLastNetworkedValue)\n"
  "\n"
  "// Just like the IInterpolatedVar functions, but you can specify an\n"
  "// interpolation amount.";
#else
static const char *Dtool_CInterpolatedVarArrayBase_float_false_NoteChanged_626_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< float, false >::Interpolate(float currentTime, float interpolation_amount)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_float_false_Interpolate_627(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< float, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_float_false, (void **)&local_this, "CInterpolatedVarArrayBase_float_false.Interpolate")) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< float, false >::Interpolate(float currentTime, float interpolation_amount)
  float param1;
  float param2;
  static const char *keyword_list[] = {"currentTime", "interpolation_amount", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:Interpolate", (char **)keyword_list, &param1, &param2)) {
    int return_value = ((*local_this).Interpolate)((float)param1, (float)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Interpolate(const CInterpolatedVarArrayBase self, float currentTime, float interpolation_amount)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_float_false_Interpolate_627_comment =
  "C++ Interface:\n"
  "Interpolate(const CInterpolatedVarArrayBase self, float currentTime, float interpolation_amount)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_float_false_Interpolate_627_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< float, false >::ClearHistory(void)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_float_false_ClearHistory_631(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< float, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_float_false, (void **)&local_this, "CInterpolatedVarArrayBase_float_false.ClearHistory")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< float, false >::ClearHistory(void)
  ((*local_this).ClearHistory)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_float_false_ClearHistory_631_comment =
  "C++ Interface:\n"
  "ClearHistory(const CInterpolatedVarArrayBase self)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_float_false_ClearHistory_631_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float const &CInterpolatedVarArrayBase< float, false >::GetPrev(int iArrayIndex = 0) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_float_false_GetPrev_633(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< float, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_float_false)) {
    return nullptr;
  }
  // 1-float const &CInterpolatedVarArrayBase< float, false >::GetPrev(int iArrayIndex = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"iArrayIndex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:GetPrev", (char **)keyword_list, &param1)) {
    float return_value = ((*(const CInterpolatedVarArrayBase< float, false >*)local_this).GetPrev)((int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetPrev(CInterpolatedVarArrayBase self, int iArrayIndex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_float_false_GetPrev_633_comment =
  "C++ Interface:\n"
  "GetPrev(CInterpolatedVarArrayBase self, int iArrayIndex)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_float_false_GetPrev_633_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float const &CInterpolatedVarArrayBase< float, false >::GetCurrent(int iArrayIndex = 0) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_float_false_GetCurrent_634(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< float, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_float_false)) {
    return nullptr;
  }
  // 1-float const &CInterpolatedVarArrayBase< float, false >::GetCurrent(int iArrayIndex = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"iArrayIndex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:GetCurrent", (char **)keyword_list, &param1)) {
    float return_value = ((*(const CInterpolatedVarArrayBase< float, false >*)local_this).GetCurrent)((int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetCurrent(CInterpolatedVarArrayBase self, int iArrayIndex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_float_false_GetCurrent_634_comment =
  "C++ Interface:\n"
  "GetCurrent(CInterpolatedVarArrayBase self, int iArrayIndex)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_float_false_GetCurrent_634_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float CInterpolatedVarArrayBase< float, false >::GetInterval(void) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_float_false_GetInterval_635(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< float, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_float_false)) {
    return nullptr;
  }
  // 1-float CInterpolatedVarArrayBase< float, false >::GetInterval(void) const
  float return_value = ((*(const CInterpolatedVarArrayBase< float, false >*)local_this).GetInterval)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_float_false_GetInterval_635_comment =
  "C++ Interface:\n"
  "GetInterval(CInterpolatedVarArrayBase self)\n"
  "\n"
  "// Returns the time difference betweem the most recent sample and its previous\n"
  "// sample.";
#else
static const char *Dtool_CInterpolatedVarArrayBase_float_false_GetInterval_635_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CInterpolatedVarArrayBase< float, false >::IsValidIndex(int i)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_float_false_IsValidIndex_636(PyObject *self, PyObject *arg) {
  CInterpolatedVarArrayBase< float, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_float_false, (void **)&local_this, "CInterpolatedVarArrayBase_float_false.IsValidIndex")) {
    return nullptr;
  }
  // 1-bool CInterpolatedVarArrayBase< float, false >::IsValidIndex(int i)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).IsValidIndex)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "IsValidIndex(const CInterpolatedVarArrayBase self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_float_false_IsValidIndex_636_comment =
  "C++ Interface:\n"
  "IsValidIndex(const CInterpolatedVarArrayBase self, int i)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_float_false_IsValidIndex_636_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< float, false >::GetHead(void)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_float_false_GetHead_638(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< float, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_float_false, (void **)&local_this, "CInterpolatedVarArrayBase_float_false.GetHead")) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< float, false >::GetHead(void)
  int return_value = ((*local_this).GetHead)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_float_false_GetHead_638_comment =
  "C++ Interface:\n"
  "GetHead(const CInterpolatedVarArrayBase self)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_float_false_GetHead_638_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< float, false >::GetNext(int i)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_float_false_GetNext_639(PyObject *self, PyObject *arg) {
  CInterpolatedVarArrayBase< float, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_float_false, (void **)&local_this, "CInterpolatedVarArrayBase_float_false.GetNext")) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< float, false >::GetNext(int i)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).GetNext)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetNext(const CInterpolatedVarArrayBase self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_float_false_GetNext_639_comment =
  "C++ Interface:\n"
  "GetNext(const CInterpolatedVarArrayBase self, int i)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_float_false_GetNext_639_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< float, false >::SetLooping(bool looping, int iArrayIndex = 0)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_float_false_SetLooping_641(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterpolatedVarArrayBase< float, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_float_false, (void **)&local_this, "CInterpolatedVarArrayBase_float_false.SetLooping")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< float, false >::SetLooping(bool looping, int iArrayIndex = 0)
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"looping", "iArrayIndex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:SetLooping", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).SetLooping)((PyObject_IsTrue(param1) != 0), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetLooping(const CInterpolatedVarArrayBase self, bool looping, int iArrayIndex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_float_false_SetLooping_641_comment =
  "C++ Interface:\n"
  "SetLooping(const CInterpolatedVarArrayBase self, bool looping, int iArrayIndex)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_float_false_SetLooping_641_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterpolatedVarArrayBase< float, false >::SetMaxCount(int newmax)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_float_false_SetMaxCount_642(PyObject *self, PyObject *arg) {
  CInterpolatedVarArrayBase< float, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_float_false, (void **)&local_this, "CInterpolatedVarArrayBase_float_false.SetMaxCount")) {
    return nullptr;
  }
  // 1-void CInterpolatedVarArrayBase< float, false >::SetMaxCount(int newmax)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).SetMaxCount)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetMaxCount(const CInterpolatedVarArrayBase self, int newmax)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_float_false_SetMaxCount_642_comment =
  "C++ Interface:\n"
  "SetMaxCount(const CInterpolatedVarArrayBase self, int newmax)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_float_false_SetMaxCount_642_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CInterpolatedVarArrayBase< float, false >::GetMaxCount(void) const
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_float_false_GetMaxCount_643(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< float, false > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterpolatedVarArrayBase_float_false)) {
    return nullptr;
  }
  // 1-int CInterpolatedVarArrayBase< float, false >::GetMaxCount(void) const
  int return_value = ((*(const CInterpolatedVarArrayBase< float, false >*)local_this).GetMaxCount)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_float_false_GetMaxCount_643_comment =
  "C++ Interface:\n"
  "GetMaxCount(CInterpolatedVarArrayBase self)\n";
#else
static const char *Dtool_CInterpolatedVarArrayBase_float_false_GetMaxCount_643_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float CInterpolatedVarArrayBase< float, false >::GetOldestEntry(void)
 */
static PyObject *Dtool_CInterpolatedVarArrayBase_float_false_GetOldestEntry_644(PyObject *self, PyObject *) {
  CInterpolatedVarArrayBase< float, false > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterpolatedVarArrayBase_float_false, (void **)&local_this, "CInterpolatedVarArrayBase_float_false.GetOldestEntry")) {
    return nullptr;
  }
  // 1-float CInterpolatedVarArrayBase< float, false >::GetOldestEntry(void)
  float return_value = ((*local_this).GetOldestEntry)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterpolatedVarArrayBase_float_false_GetOldestEntry_644_comment =
  "C++ Interface:\n"
  "GetOldestEntry(const CInterpolatedVarArrayBase self)\n"
  "\n"
  "// Get the time of the oldest entry.";
#else
static const char *Dtool_CInterpolatedVarArrayBase_float_false_GetOldestEntry_644_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CInterpolatedVarArrayBase< float, false >::CInterpolatedVarArrayBase(char const *pDebugName = "no debug name")
 */
static int Dtool_Init_CInterpolatedVarArrayBase_float_false(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-CInterpolatedVarArrayBase< float, false >::CInterpolatedVarArrayBase(char const *pDebugName = "no debug name")
  char const *param0 = "no debug name";
  static const char *keyword_list[] = {"pDebugName", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|z:CInterpolatedVarArrayBase", (char **)keyword_list, &param0)) {
    CInterpolatedVarArrayBase< float, false > *return_value = new CInterpolatedVarArrayBase< float, false >((char const *)param0);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CInterpolatedVarArrayBase_float_false, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CInterpolatedVarArrayBase(str pDebugName)\n");
  }
  return -1;
}

CInterpolatedVarArrayBase< float, false > *Dtool_Coerce_CInterpolatedVarArrayBase_float_false(PyObject *args, CInterpolatedVarArrayBase< float, false > &coerced) {
  CInterpolatedVarArrayBase< float, false > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_CInterpolatedVarArrayBase_float_false)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const CInterpolatedVarArrayBase< float, false > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CInterpolatedVarArrayBase< float, false >::CInterpolatedVarArrayBase(char const *pDebugName)
    char const *param0;
    if (PyArg_Parse(arg, "z:CInterpolatedVarArrayBase", &param0)) {
      coerced = CInterpolatedVarArrayBase< float, false >((char const *)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
    PyErr_Clear();
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_CInterpolatedVarArrayBase_float_false(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CInterpolatedVarArrayBase_float_false) {
    printf("CInterpolatedVarArrayBase_float_false ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CInterpolatedVarArrayBase< float, false > *local_this = (CInterpolatedVarArrayBase< float, false > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CInterpolatedVarArrayBase_float_false) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_IInterpolatedVar) {
    return (IInterpolatedVar *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CInterpolatedVarArrayBase_float_false(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CInterpolatedVarArrayBase_float_false) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_IInterpolatedVar) {
    IInterpolatedVar* other_this = (IInterpolatedVar*)from_this;
    return (CInterpolatedVarArrayBase< float, false >*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for TextureStages (TextureStages)
 */
static PyMethodDef Dtool_Methods_TextureStages[] = {
  {"get", (PyCFunction) &Dtool_TextureStages_get_2, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextureStages_get_2_comment},
  {"get_basetexture", &Dtool_TextureStages_get_basetexture_3, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_basetexture_3_comment},
  {"getBasetexture", &Dtool_TextureStages_get_basetexture_3, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_basetexture_3_comment},
  {"get_lightmap", &Dtool_TextureStages_get_lightmap_4, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_lightmap_4_comment},
  {"getLightmap", &Dtool_TextureStages_get_lightmap_4, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_lightmap_4_comment},
  {"get_bumped_lightmap", &Dtool_TextureStages_get_bumped_lightmap_5, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_bumped_lightmap_5_comment},
  {"getBumpedLightmap", &Dtool_TextureStages_get_bumped_lightmap_5, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_bumped_lightmap_5_comment},
  {"get_spheremap", &Dtool_TextureStages_get_spheremap_6, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_spheremap_6_comment},
  {"getSpheremap", &Dtool_TextureStages_get_spheremap_6, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_spheremap_6_comment},
  {"get_cubemap", &Dtool_TextureStages_get_cubemap_7, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_cubemap_7_comment},
  {"getCubemap", &Dtool_TextureStages_get_cubemap_7, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_cubemap_7_comment},
  {"get_normalmap", &Dtool_TextureStages_get_normalmap_8, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_normalmap_8_comment},
  {"getNormalmap", &Dtool_TextureStages_get_normalmap_8, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_normalmap_8_comment},
  {"get_heightmap", &Dtool_TextureStages_get_heightmap_9, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_heightmap_9_comment},
  {"getHeightmap", &Dtool_TextureStages_get_heightmap_9, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_heightmap_9_comment},
  {"get_glossmap", &Dtool_TextureStages_get_glossmap_10, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_glossmap_10_comment},
  {"getGlossmap", &Dtool_TextureStages_get_glossmap_10, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_glossmap_10_comment},
  {"get_glowmap", &Dtool_TextureStages_get_glowmap_11, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_glowmap_11_comment},
  {"getGlowmap", &Dtool_TextureStages_get_glowmap_11, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_glowmap_11_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TextureStages = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TextureStages = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.TextureStages",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextureStages,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TextureStages,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This simple interface maintains a single TextureStage object for each unique name.\n"
    " * It avoids the creation of duplicate TextureStages with the same name, which\n"
    " * reduces texture swapping and draw call overhead.\n"
    " *\n"
    " * If using our shader system, you should always use this interface to get TextureStages.\n"
    " * You are not required to change any properties on the returned TextureStage, as the shader\n"
    " * specification will know what to do with the TextureStage from the name.\n"
    " * \n"
    " * For example, you do not need to call TextureStage::set_mode() or NodePath::set_tex_gen().\n"
    " * If you apply a texture to a node with the get_normalmap() stage, the shader specification\n"
    " * will know that the texture you supplied is to be treated as a normal map.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextureStages,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextureStages,
    PyType_GenericAlloc,
    Dtool_new_TextureStages,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextureStages,
  Dtool_UpcastInterface_TextureStages,
  Dtool_DowncastInterface_TextureStages,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextureStages(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextureStages._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TextureStages._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextureStages) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextureStages)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextureStages);
  }
}

/**
 * Python method tables for BSPMaterial (BSPMaterial)
 */
static PyMethodDef Dtool_Methods_BSPMaterial[] = {
  {"assign", &Dtool_BSPMaterial_operator_17, METH_O, (const char *)Dtool_BSPMaterial_operator_17_comment},
  {"set_keyvalue", (PyCFunction) &Dtool_BSPMaterial_set_keyvalue_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPMaterial_set_keyvalue_18_comment},
  {"setKeyvalue", (PyCFunction) &Dtool_BSPMaterial_set_keyvalue_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPMaterial_set_keyvalue_18_comment},
  {"get_keyvalue", &Dtool_BSPMaterial_get_keyvalue_19, METH_O, (const char *)Dtool_BSPMaterial_get_keyvalue_19_comment},
  {"getKeyvalue", &Dtool_BSPMaterial_get_keyvalue_19, METH_O, (const char *)Dtool_BSPMaterial_get_keyvalue_19_comment},
  {"get_num_keyvalues", &Dtool_BSPMaterial_get_num_keyvalues_20, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_num_keyvalues_20_comment},
  {"getNumKeyvalues", &Dtool_BSPMaterial_get_num_keyvalues_20, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_num_keyvalues_20_comment},
  {"get_key", &Dtool_BSPMaterial_get_key_21, METH_O, (const char *)Dtool_BSPMaterial_get_key_21_comment},
  {"getKey", &Dtool_BSPMaterial_get_key_21, METH_O, (const char *)Dtool_BSPMaterial_get_key_21_comment},
  {"get_value", &Dtool_BSPMaterial_get_value_22, METH_O, (const char *)Dtool_BSPMaterial_get_value_22_comment},
  {"getValue", &Dtool_BSPMaterial_get_value_22, METH_O, (const char *)Dtool_BSPMaterial_get_value_22_comment},
  {"get_keyvalue_int", &Dtool_BSPMaterial_get_keyvalue_int_23, METH_O, (const char *)Dtool_BSPMaterial_get_keyvalue_int_23_comment},
  {"getKeyvalueInt", &Dtool_BSPMaterial_get_keyvalue_int_23, METH_O, (const char *)Dtool_BSPMaterial_get_keyvalue_int_23_comment},
  {"get_keyvalue_float", &Dtool_BSPMaterial_get_keyvalue_float_24, METH_O, (const char *)Dtool_BSPMaterial_get_keyvalue_float_24_comment},
  {"getKeyvalueFloat", &Dtool_BSPMaterial_get_keyvalue_float_24, METH_O, (const char *)Dtool_BSPMaterial_get_keyvalue_float_24_comment},
  {"set_shader", &Dtool_BSPMaterial_set_shader_25, METH_O, (const char *)Dtool_BSPMaterial_set_shader_25_comment},
  {"setShader", &Dtool_BSPMaterial_set_shader_25, METH_O, (const char *)Dtool_BSPMaterial_set_shader_25_comment},
  {"get_shader", &Dtool_BSPMaterial_get_shader_26, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_shader_26_comment},
  {"getShader", &Dtool_BSPMaterial_get_shader_26, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_shader_26_comment},
  {"get_file", &Dtool_BSPMaterial_get_file_27, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_file_27_comment},
  {"getFile", &Dtool_BSPMaterial_get_file_27, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_file_27_comment},
  {"has_keyvalue", &Dtool_BSPMaterial_has_keyvalue_28, METH_O, (const char *)Dtool_BSPMaterial_has_keyvalue_28_comment},
  {"hasKeyvalue", &Dtool_BSPMaterial_has_keyvalue_28, METH_O, (const char *)Dtool_BSPMaterial_has_keyvalue_28_comment},
  {"has_env_cubemap", &Dtool_BSPMaterial_has_env_cubemap_29, METH_NOARGS, (const char *)Dtool_BSPMaterial_has_env_cubemap_29_comment},
  {"hasEnvCubemap", &Dtool_BSPMaterial_has_env_cubemap_29, METH_NOARGS, (const char *)Dtool_BSPMaterial_has_env_cubemap_29_comment},
  {"has_transparency", &Dtool_BSPMaterial_has_transparency_30, METH_NOARGS, (const char *)Dtool_BSPMaterial_has_transparency_30_comment},
  {"hasTransparency", &Dtool_BSPMaterial_has_transparency_30, METH_NOARGS, (const char *)Dtool_BSPMaterial_has_transparency_30_comment},
  {"get_surface_prop", &Dtool_BSPMaterial_get_surface_prop_31, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_surface_prop_31_comment},
  {"getSurfaceProp", &Dtool_BSPMaterial_get_surface_prop_31, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_surface_prop_31_comment},
  {"get_contents", &Dtool_BSPMaterial_get_contents_32, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_contents_32_comment},
  {"getContents", &Dtool_BSPMaterial_get_contents_32, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_contents_32_comment},
  {"is_lightmapped", &Dtool_BSPMaterial_is_lightmapped_33, METH_NOARGS, (const char *)Dtool_BSPMaterial_is_lightmapped_33_comment},
  {"isLightmapped", &Dtool_BSPMaterial_is_lightmapped_33, METH_NOARGS, (const char *)Dtool_BSPMaterial_is_lightmapped_33_comment},
  {"is_skybox", &Dtool_BSPMaterial_is_skybox_34, METH_NOARGS, (const char *)Dtool_BSPMaterial_is_skybox_34_comment},
  {"isSkybox", &Dtool_BSPMaterial_is_skybox_34, METH_NOARGS, (const char *)Dtool_BSPMaterial_is_skybox_34_comment},
  {"has_bumpmap", &Dtool_BSPMaterial_has_bumpmap_35, METH_NOARGS, (const char *)Dtool_BSPMaterial_has_bumpmap_35_comment},
  {"hasBumpmap", &Dtool_BSPMaterial_has_bumpmap_35, METH_NOARGS, (const char *)Dtool_BSPMaterial_has_bumpmap_35_comment},
  {"get_from_file", &Dtool_BSPMaterial_get_from_file_36, METH_O | METH_STATIC, (const char *)Dtool_BSPMaterial_get_from_file_36_comment},
  {"getFromFile", &Dtool_BSPMaterial_get_from_file_36, METH_O | METH_STATIC, (const char *)Dtool_BSPMaterial_get_from_file_36_comment},
  {"get_class_type", &Dtool_BSPMaterial_get_class_type_37, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterial_get_class_type_37_comment},
  {"getClassType", &Dtool_BSPMaterial_get_class_type_37, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterial_get_class_type_37_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPMaterial = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPMaterial = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPMaterial = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPMaterial = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPMaterial = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPMaterial = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.BSPMaterial",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPMaterial,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPMaterial,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPMaterial,
    &Dtool_SequenceMethods_BSPMaterial,
    &Dtool_MappingMethods_BSPMaterial,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPMaterial,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPMaterial,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPMaterial,
    PyType_GenericAlloc,
    Dtool_new_BSPMaterial,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPMaterial,
  Dtool_UpcastInterface_BSPMaterial,
  Dtool_DowncastInterface_BSPMaterial,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BSPMaterial(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPMaterial._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_BSPMaterial._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BSPMaterial._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPMaterial) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPMaterial)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPMaterial);
  }
}

/**
 * Python method tables for BSPMaterialAttrib (BSPMaterialAttrib)
 */
static PyMethodDef Dtool_Methods_BSPMaterialAttrib[] = {
  {"make", &Dtool_BSPMaterialAttrib_make_41, METH_O | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_make_41_comment},
  {"make_override_shader", &Dtool_BSPMaterialAttrib_make_override_shader_42, METH_O | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_make_override_shader_42_comment},
  {"makeOverrideShader", &Dtool_BSPMaterialAttrib_make_override_shader_42, METH_O | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_make_override_shader_42_comment},
  {"make_default", &Dtool_BSPMaterialAttrib_make_default_43, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_make_default_43_comment},
  {"makeDefault", &Dtool_BSPMaterialAttrib_make_default_43, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_make_default_43_comment},
  {"get_override_shader", &Dtool_BSPMaterialAttrib_get_override_shader_44, METH_NOARGS, (const char *)Dtool_BSPMaterialAttrib_get_override_shader_44_comment},
  {"getOverrideShader", &Dtool_BSPMaterialAttrib_get_override_shader_44, METH_NOARGS, (const char *)Dtool_BSPMaterialAttrib_get_override_shader_44_comment},
  {"has_override_shader", &Dtool_BSPMaterialAttrib_has_override_shader_45, METH_NOARGS, (const char *)Dtool_BSPMaterialAttrib_has_override_shader_45_comment},
  {"hasOverrideShader", &Dtool_BSPMaterialAttrib_has_override_shader_45, METH_NOARGS, (const char *)Dtool_BSPMaterialAttrib_has_override_shader_45_comment},
  {"get_material", &Dtool_BSPMaterialAttrib_get_material_46, METH_NOARGS, (const char *)Dtool_BSPMaterialAttrib_get_material_46_comment},
  {"getMaterial", &Dtool_BSPMaterialAttrib_get_material_46, METH_NOARGS, (const char *)Dtool_BSPMaterialAttrib_get_material_46_comment},
  {"get_class_slot", &Dtool_BSPMaterialAttrib_get_class_slot_47, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_get_class_slot_47_comment},
  {"getClassSlot", &Dtool_BSPMaterialAttrib_get_class_slot_47, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_get_class_slot_47_comment},
  {"get_class_type", &Dtool_BSPMaterialAttrib_get_class_type_50, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_get_class_type_50_comment},
  {"getClassType", &Dtool_BSPMaterialAttrib_get_class_type_50, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_get_class_type_50_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPMaterialAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPMaterialAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPMaterialAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPMaterialAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPMaterialAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPMaterialAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.BSPMaterialAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPMaterialAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPMaterialAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPMaterialAttrib,
    &Dtool_SequenceMethods_BSPMaterialAttrib,
    &Dtool_MappingMethods_BSPMaterialAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPMaterialAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPMaterialAttrib,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPMaterialAttrib,
    PyType_GenericAlloc,
    Dtool_new_BSPMaterialAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPMaterialAttrib,
  Dtool_UpcastInterface_BSPMaterialAttrib,
  Dtool_DowncastInterface_BSPMaterialAttrib,
  (CoerceFunction)Dtool_ConstCoerce_BSPMaterialAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_BSPMaterialAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_RenderAttrib != nullptr);
    assert(Dtool_Ptr_RenderAttrib->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_RenderAttrib->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPMaterialAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_RenderAttrib);
    Dtool_BSPMaterialAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BSPMaterialAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_BSPMaterialAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_BSPMaterialAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPMaterialAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPMaterialAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPMaterialAttrib);
  }
}

/**
 * Python method tables for PackResult (PackResult)
 */
static PyMethodDef Dtool_Methods_PackResult[] = {
  {"get_width", &Dtool_PackResult_get_width_53, METH_NOARGS, (const char *)Dtool_PackResult_get_width_53_comment},
  {"getWidth", &Dtool_PackResult_get_width_53, METH_NOARGS, (const char *)Dtool_PackResult_get_width_53_comment},
  {"get_height", &Dtool_PackResult_get_height_54, METH_NOARGS, (const char *)Dtool_PackResult_get_height_54_comment},
  {"getHeight", &Dtool_PackResult_get_height_54, METH_NOARGS, (const char *)Dtool_PackResult_get_height_54_comment},
  {"get_unused_area", &Dtool_PackResult_get_unused_area_55, METH_NOARGS, (const char *)Dtool_PackResult_get_unused_area_55_comment},
  {"getUnusedArea", &Dtool_PackResult_get_unused_area_55, METH_NOARGS, (const char *)Dtool_PackResult_get_unused_area_55_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PackResult = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PackResult = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.PackResult",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PackResult,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PackResult,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PackResult,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PackResult,
    PyType_GenericAlloc,
    Dtool_new_PackResult,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PackResult,
  Dtool_UpcastInterface_PackResult,
  Dtool_DowncastInterface_PackResult,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PackResult(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PackResult._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PackResult._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PackResult) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PackResult)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PackResult);
  }
}

/**
 * Python method tables for TextureLocation (TextureLocation)
 */
static PyMethodDef Dtool_Methods_TextureLocation[] = {
  {"get_x", &Dtool_TextureLocation_get_x_59, METH_NOARGS, (const char *)Dtool_TextureLocation_get_x_59_comment},
  {"getX", &Dtool_TextureLocation_get_x_59, METH_NOARGS, (const char *)Dtool_TextureLocation_get_x_59_comment},
  {"get_y", &Dtool_TextureLocation_get_y_60, METH_NOARGS, (const char *)Dtool_TextureLocation_get_y_60_comment},
  {"getY", &Dtool_TextureLocation_get_y_60, METH_NOARGS, (const char *)Dtool_TextureLocation_get_y_60_comment},
  {"get_width", &Dtool_TextureLocation_get_width_61, METH_NOARGS, (const char *)Dtool_TextureLocation_get_width_61_comment},
  {"getWidth", &Dtool_TextureLocation_get_width_61, METH_NOARGS, (const char *)Dtool_TextureLocation_get_width_61_comment},
  {"get_height", &Dtool_TextureLocation_get_height_62, METH_NOARGS, (const char *)Dtool_TextureLocation_get_height_62_comment},
  {"getHeight", &Dtool_TextureLocation_get_height_62, METH_NOARGS, (const char *)Dtool_TextureLocation_get_height_62_comment},
  {"get_rotated", &Dtool_TextureLocation_get_rotated_63, METH_NOARGS, (const char *)Dtool_TextureLocation_get_rotated_63_comment},
  {"getRotated", &Dtool_TextureLocation_get_rotated_63, METH_NOARGS, (const char *)Dtool_TextureLocation_get_rotated_63_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TextureLocation = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TextureLocation = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.TextureLocation",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TextureLocation,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TextureLocation,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextureLocation,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextureLocation,
    PyType_GenericAlloc,
    Dtool_new_TextureLocation,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextureLocation,
  Dtool_UpcastInterface_TextureLocation,
  Dtool_DowncastInterface_TextureLocation,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextureLocation(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextureLocation._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TextureLocation._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextureLocation) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextureLocation)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextureLocation);
  }
}

/**
 * Python method tables for TexturePacker (TexturePacker)
 */
static PyMethodDef Dtool_Methods_TexturePacker[] = {
  {"getTextureCount", &Dtool_TexturePacker_getTextureCount_67, METH_NOARGS, (const char *)Dtool_TexturePacker_getTextureCount_67_comment},
  {"setTextureCount", &Dtool_TexturePacker_setTextureCount_68, METH_O, (const char *)Dtool_TexturePacker_setTextureCount_68_comment},
  {"addTexture", (PyCFunction) &Dtool_TexturePacker_addTexture_69, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePacker_addTexture_69_comment},
  {"wouldTextureFit", (PyCFunction) &Dtool_TexturePacker_wouldTextureFit_70, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePacker_wouldTextureFit_70_comment},
  {"addNewTexture", (PyCFunction) &Dtool_TexturePacker_addNewTexture_71, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePacker_addNewTexture_71_comment},
  {"packTextures", (PyCFunction) &Dtool_TexturePacker_packTextures_72, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePacker_packTextures_72_comment},
  {"getTextureLocation", &Dtool_TexturePacker_getTextureLocation_73, METH_O, (const char *)Dtool_TexturePacker_getTextureLocation_73_comment},
  {"createTexturePacker", &Dtool_TexturePacker_createTexturePacker_74, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePacker_createTexturePacker_74_comment},
  {"releaseTexturePacker", &Dtool_TexturePacker_releaseTexturePacker_75, METH_O | METH_STATIC, (const char *)Dtool_TexturePacker_releaseTexturePacker_75_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TexturePacker = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TexturePacker = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.TexturePacker",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TexturePacker,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TexturePacker,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TexturePacker,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TexturePacker,
    PyType_GenericAlloc,
    Dtool_new_TexturePacker,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TexturePacker,
  Dtool_UpcastInterface_TexturePacker,
  Dtool_DowncastInterface_TexturePacker,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TexturePacker(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TexturePacker._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TexturePacker._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TexturePacker) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TexturePacker)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TexturePacker);
  }
}

/**
 * Python method tables for RayTrace (RayTrace)
 */
static PyMethodDef Dtool_Methods_RayTrace[] = {
  {"initialize", &Dtool_RayTrace_initialize_78, METH_NOARGS | METH_STATIC, (const char *)Dtool_RayTrace_initialize_78_comment},
  {"destruct", &Dtool_RayTrace_destruct_79, METH_NOARGS | METH_STATIC, (const char *)Dtool_RayTrace_destruct_79_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_RayTrace = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_RayTrace = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.RayTrace",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RayTrace,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RayTrace,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RayTrace,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RayTrace,
    PyType_GenericAlloc,
    Dtool_new_RayTrace,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RayTrace,
  Dtool_UpcastInterface_RayTrace,
  Dtool_DowncastInterface_RayTrace,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_RayTrace(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_RayTrace._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_RayTrace._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RayTrace) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RayTrace)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RayTrace);
  }
}

/**
 * Python method tables for RayTraceHitResult (RayTraceHitResult)
 */
static PyMethodDef Dtool_Methods_RayTraceHitResult[] = {
  {"has_hit", &Dtool_RayTraceHitResult_has_hit_84, METH_NOARGS, (const char *)Dtool_RayTraceHitResult_has_hit_84_comment},
  {"hasHit", &Dtool_RayTraceHitResult_has_hit_84, METH_NOARGS, (const char *)Dtool_RayTraceHitResult_has_hit_84_comment},
  {"get_hit_normal", &Dtool_RayTraceHitResult_get_hit_normal_85, METH_NOARGS, (const char *)Dtool_RayTraceHitResult_get_hit_normal_85_comment},
  {"getHitNormal", &Dtool_RayTraceHitResult_get_hit_normal_85, METH_NOARGS, (const char *)Dtool_RayTraceHitResult_get_hit_normal_85_comment},
  {"get_uv", &Dtool_RayTraceHitResult_get_uv_86, METH_NOARGS, (const char *)Dtool_RayTraceHitResult_get_uv_86_comment},
  {"getUv", &Dtool_RayTraceHitResult_get_uv_86, METH_NOARGS, (const char *)Dtool_RayTraceHitResult_get_uv_86_comment},
  {"get_prim_id", &Dtool_RayTraceHitResult_get_prim_id_87, METH_NOARGS, (const char *)Dtool_RayTraceHitResult_get_prim_id_87_comment},
  {"getPrimId", &Dtool_RayTraceHitResult_get_prim_id_87, METH_NOARGS, (const char *)Dtool_RayTraceHitResult_get_prim_id_87_comment},
  {"get_geom_id", &Dtool_RayTraceHitResult_get_geom_id_88, METH_NOARGS, (const char *)Dtool_RayTraceHitResult_get_geom_id_88_comment},
  {"getGeomId", &Dtool_RayTraceHitResult_get_geom_id_88, METH_NOARGS, (const char *)Dtool_RayTraceHitResult_get_geom_id_88_comment},
  {"get_hit_fraction", &Dtool_RayTraceHitResult_get_hit_fraction_89, METH_NOARGS, (const char *)Dtool_RayTraceHitResult_get_hit_fraction_89_comment},
  {"getHitFraction", &Dtool_RayTraceHitResult_get_hit_fraction_89, METH_NOARGS, (const char *)Dtool_RayTraceHitResult_get_hit_fraction_89_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_RayTraceHitResult = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_RayTraceHitResult = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.RayTraceHitResult",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RayTraceHitResult,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RayTraceHitResult,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RayTraceHitResult,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RayTraceHitResult,
    PyType_GenericAlloc,
    Dtool_new_RayTraceHitResult,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RayTraceHitResult,
  Dtool_UpcastInterface_RayTraceHitResult,
  Dtool_DowncastInterface_RayTraceHitResult,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_RayTraceHitResult(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_RayTraceHitResult._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_RayTraceHitResult._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RayTraceHitResult) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RayTraceHitResult)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RayTraceHitResult);
  }
}

/**
 * Python method tables for RayTraceScene (RayTraceScene)
 */
static PyMethodDef Dtool_Methods_RayTraceScene[] = {
  {"add_geometry", &Dtool_RayTraceScene_add_geometry_94, METH_O, (const char *)Dtool_RayTraceScene_add_geometry_94_comment},
  {"addGeometry", &Dtool_RayTraceScene_add_geometry_94, METH_O, (const char *)Dtool_RayTraceScene_add_geometry_94_comment},
  {"remove_geometry", &Dtool_RayTraceScene_remove_geometry_95, METH_O, (const char *)Dtool_RayTraceScene_remove_geometry_95_comment},
  {"removeGeometry", &Dtool_RayTraceScene_remove_geometry_95, METH_O, (const char *)Dtool_RayTraceScene_remove_geometry_95_comment},
  {"remove_all", &Dtool_RayTraceScene_remove_all_96, METH_NOARGS, (const char *)Dtool_RayTraceScene_remove_all_96_comment},
  {"removeAll", &Dtool_RayTraceScene_remove_all_96, METH_NOARGS, (const char *)Dtool_RayTraceScene_remove_all_96_comment},
  {"trace_line", (PyCFunction) &Dtool_RayTraceScene_trace_line_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RayTraceScene_trace_line_98_comment},
  {"traceLine", (PyCFunction) &Dtool_RayTraceScene_trace_line_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RayTraceScene_trace_line_98_comment},
  {"trace_ray", (PyCFunction) &Dtool_RayTraceScene_trace_ray_99, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RayTraceScene_trace_ray_99_comment},
  {"traceRay", (PyCFunction) &Dtool_RayTraceScene_trace_ray_99, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RayTraceScene_trace_ray_99_comment},
  {"set_build_quality", &Dtool_RayTraceScene_set_build_quality_100, METH_O, (const char *)Dtool_RayTraceScene_set_build_quality_100_comment},
  {"setBuildQuality", &Dtool_RayTraceScene_set_build_quality_100, METH_O, (const char *)Dtool_RayTraceScene_set_build_quality_100_comment},
  {"update", &Dtool_RayTraceScene_update_101, METH_NOARGS, (const char *)Dtool_RayTraceScene_update_101_comment},
  {"get_geometry", &Dtool_RayTraceScene_get_geometry_102, METH_O, (const char *)Dtool_RayTraceScene_get_geometry_102_comment},
  {"getGeometry", &Dtool_RayTraceScene_get_geometry_102, METH_O, (const char *)Dtool_RayTraceScene_get_geometry_102_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_RayTraceScene = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RayTraceScene = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RayTraceScene = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RayTraceScene = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RayTraceScene = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RayTraceScene = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.RayTraceScene",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RayTraceScene,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RayTraceScene,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RayTraceScene,
    &Dtool_SequenceMethods_RayTraceScene,
    &Dtool_MappingMethods_RayTraceScene,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RayTraceScene,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RayTraceScene,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RayTraceScene,
    PyType_GenericAlloc,
    Dtool_new_RayTraceScene,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RayTraceScene,
  Dtool_UpcastInterface_RayTraceScene,
  Dtool_DowncastInterface_RayTraceScene,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_RayTraceScene(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_RayTraceScene._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_RayTraceScene._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_RayTraceScene._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum RayTraceScene::;
    PyDict_SetItemString(dict, "BUILD_QUALITY_LOW", Dtool_WrapValue(RayTraceScene::BUILD_QUALITY_LOW));
    PyDict_SetItemString(dict, "BUILD_QUALITY_MEDIUM", Dtool_WrapValue(RayTraceScene::BUILD_QUALITY_MEDIUM));
    PyDict_SetItemString(dict, "BUILD_QUALITY_HIGH", Dtool_WrapValue(RayTraceScene::BUILD_QUALITY_HIGH));
    if (PyType_Ready((PyTypeObject *)&Dtool_RayTraceScene) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RayTraceScene)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RayTraceScene);
  }
}

/**
 * Python method tables for RayTraceGeometry (RayTraceGeometry)
 */
static PyMethodDef Dtool_Methods_RayTraceGeometry[] = {
  {"get_class_type", &Dtool_RayTraceGeometry_get_class_type_105, METH_NOARGS | METH_STATIC, (const char *)Dtool_RayTraceGeometry_get_class_type_105_comment},
  {"getClassType", &Dtool_RayTraceGeometry_get_class_type_105, METH_NOARGS | METH_STATIC, (const char *)Dtool_RayTraceGeometry_get_class_type_105_comment},
  {"set_mask", &Dtool_RayTraceGeometry_set_mask_106, METH_O, (const char *)Dtool_RayTraceGeometry_set_mask_106_comment},
  {"setMask", &Dtool_RayTraceGeometry_set_mask_106, METH_O, (const char *)Dtool_RayTraceGeometry_set_mask_106_comment},
  {"get_mask", &Dtool_RayTraceGeometry_get_mask_107, METH_NOARGS, (const char *)Dtool_RayTraceGeometry_get_mask_107_comment},
  {"getMask", &Dtool_RayTraceGeometry_get_mask_107, METH_NOARGS, (const char *)Dtool_RayTraceGeometry_get_mask_107_comment},
  {"get_geom_id", &Dtool_RayTraceGeometry_get_geom_id_108, METH_NOARGS, (const char *)Dtool_RayTraceGeometry_get_geom_id_108_comment},
  {"getGeomId", &Dtool_RayTraceGeometry_get_geom_id_108, METH_NOARGS, (const char *)Dtool_RayTraceGeometry_get_geom_id_108_comment},
  {"set_build_quality", &Dtool_RayTraceGeometry_set_build_quality_109, METH_O, (const char *)Dtool_RayTraceGeometry_set_build_quality_109_comment},
  {"setBuildQuality", &Dtool_RayTraceGeometry_set_build_quality_109, METH_O, (const char *)Dtool_RayTraceGeometry_set_build_quality_109_comment},
  {"build", &Dtool_RayTraceGeometry_build_110, METH_NOARGS, (const char *)Dtool_RayTraceGeometry_build_110_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_RayTraceGeometry = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RayTraceGeometry = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RayTraceGeometry = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RayTraceGeometry = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RayTraceGeometry = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RayTraceGeometry = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.RayTraceGeometry",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RayTraceGeometry,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RayTraceGeometry,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RayTraceGeometry,
    &Dtool_SequenceMethods_RayTraceGeometry,
    &Dtool_MappingMethods_RayTraceGeometry,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RayTraceGeometry,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RayTraceGeometry,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RayTraceGeometry,
    PyType_GenericAlloc,
    Dtool_new_RayTraceGeometry,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RayTraceGeometry,
  Dtool_UpcastInterface_RayTraceGeometry,
  Dtool_DowncastInterface_RayTraceGeometry,
  (CoerceFunction)Dtool_ConstCoerce_RayTraceGeometry,
  (CoerceFunction)Dtool_Coerce_RayTraceGeometry,
};

static void Dtool_PyModuleClassInit_RayTraceGeometry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_RayTraceGeometry._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_RayTraceGeometry._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_RayTraceGeometry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RayTraceGeometry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RayTraceGeometry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RayTraceGeometry);
  }
}

/**
 * Python method tables for RayTraceTriangleMesh (RayTraceTriangleMesh)
 */
static PyMethodDef Dtool_Methods_RayTraceTriangleMesh[] = {
  {"get_class_type", &Dtool_RayTraceTriangleMesh_get_class_type_112, METH_NOARGS | METH_STATIC, (const char *)Dtool_RayTraceTriangleMesh_get_class_type_112_comment},
  {"getClassType", &Dtool_RayTraceTriangleMesh_get_class_type_112, METH_NOARGS | METH_STATIC, (const char *)Dtool_RayTraceTriangleMesh_get_class_type_112_comment},
  {"add_triangle", (PyCFunction) &Dtool_RayTraceTriangleMesh_add_triangle_114, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RayTraceTriangleMesh_add_triangle_114_comment},
  {"addTriangle", (PyCFunction) &Dtool_RayTraceTriangleMesh_add_triangle_114, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RayTraceTriangleMesh_add_triangle_114_comment},
  {"add_triangles_from_geom", (PyCFunction) &Dtool_RayTraceTriangleMesh_add_triangles_from_geom_115, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RayTraceTriangleMesh_add_triangles_from_geom_115_comment},
  {"addTrianglesFromGeom", (PyCFunction) &Dtool_RayTraceTriangleMesh_add_triangles_from_geom_115, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RayTraceTriangleMesh_add_triangles_from_geom_115_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_RayTraceTriangleMesh = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RayTraceTriangleMesh = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RayTraceTriangleMesh = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RayTraceTriangleMesh = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RayTraceTriangleMesh = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RayTraceTriangleMesh = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.RayTraceTriangleMesh",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RayTraceTriangleMesh,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RayTraceTriangleMesh,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RayTraceTriangleMesh,
    &Dtool_SequenceMethods_RayTraceTriangleMesh,
    &Dtool_MappingMethods_RayTraceTriangleMesh,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RayTraceTriangleMesh,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RayTraceTriangleMesh,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RayTraceTriangleMesh,
    PyType_GenericAlloc,
    Dtool_new_RayTraceTriangleMesh,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RayTraceTriangleMesh,
  Dtool_UpcastInterface_RayTraceTriangleMesh,
  Dtool_DowncastInterface_RayTraceTriangleMesh,
  (CoerceFunction)Dtool_ConstCoerce_RayTraceTriangleMesh,
  (CoerceFunction)Dtool_Coerce_RayTraceTriangleMesh,
};

static void Dtool_PyModuleClassInit_RayTraceTriangleMesh(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RayTraceGeometry(nullptr);
    Dtool_RayTraceTriangleMesh._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RayTraceGeometry);
    Dtool_RayTraceTriangleMesh._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_RayTraceTriangleMesh._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RayTraceTriangleMesh) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RayTraceTriangleMesh)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RayTraceTriangleMesh);
  }
}

/**
 * Python method tables for BSPFaceAttrib (BSPFaceAttrib)
 */
static PyMethodDef Dtool_Methods_BSPFaceAttrib[] = {
  {"make", (PyCFunction) &Dtool_BSPFaceAttrib_make_119, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_make_119_comment},
  {"make_default", &Dtool_BSPFaceAttrib_make_default_120, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_make_default_120_comment},
  {"makeDefault", &Dtool_BSPFaceAttrib_make_default_120, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_make_default_120_comment},
  {"make_ignore_pvs", &Dtool_BSPFaceAttrib_make_ignore_pvs_121, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_make_ignore_pvs_121_comment},
  {"makeIgnorePvs", &Dtool_BSPFaceAttrib_make_ignore_pvs_121, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_make_ignore_pvs_121_comment},
  {"get_material", &Dtool_BSPFaceAttrib_get_material_122, METH_NOARGS, (const char *)Dtool_BSPFaceAttrib_get_material_122_comment},
  {"getMaterial", &Dtool_BSPFaceAttrib_get_material_122, METH_NOARGS, (const char *)Dtool_BSPFaceAttrib_get_material_122_comment},
  {"get_face_type", &Dtool_BSPFaceAttrib_get_face_type_123, METH_NOARGS, (const char *)Dtool_BSPFaceAttrib_get_face_type_123_comment},
  {"getFaceType", &Dtool_BSPFaceAttrib_get_face_type_123, METH_NOARGS, (const char *)Dtool_BSPFaceAttrib_get_face_type_123_comment},
  {"get_ignore_pvs", &Dtool_BSPFaceAttrib_get_ignore_pvs_124, METH_NOARGS, (const char *)Dtool_BSPFaceAttrib_get_ignore_pvs_124_comment},
  {"getIgnorePvs", &Dtool_BSPFaceAttrib_get_ignore_pvs_124, METH_NOARGS, (const char *)Dtool_BSPFaceAttrib_get_ignore_pvs_124_comment},
  {"get_class_slot", &Dtool_BSPFaceAttrib_get_class_slot_125, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_get_class_slot_125_comment},
  {"getClassSlot", &Dtool_BSPFaceAttrib_get_class_slot_125, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_get_class_slot_125_comment},
  {"get_class_type", &Dtool_BSPFaceAttrib_get_class_type_127, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_get_class_type_127_comment},
  {"getClassType", &Dtool_BSPFaceAttrib_get_class_type_127, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_get_class_type_127_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPFaceAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPFaceAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.BSPFaceAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPFaceAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPFaceAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPFaceAttrib,
    &Dtool_SequenceMethods_BSPFaceAttrib,
    &Dtool_MappingMethods_BSPFaceAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPFaceAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An attribute applied to each face Geom from a BSP file.\n"
    " * All it does right now is indicate the material of the face\n"
    " * and if it's a wall or a floor (depending on the face normal).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPFaceAttrib,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPFaceAttrib,
    PyType_GenericAlloc,
    Dtool_new_BSPFaceAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPFaceAttrib,
  Dtool_UpcastInterface_BSPFaceAttrib,
  Dtool_DowncastInterface_BSPFaceAttrib,
  (CoerceFunction)Dtool_ConstCoerce_BSPFaceAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_BSPFaceAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_RenderAttrib != nullptr);
    assert(Dtool_Ptr_RenderAttrib->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_RenderAttrib->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPFaceAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_RenderAttrib);
    Dtool_BSPFaceAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BSPFaceAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum BSPFaceAttrib::;
    PyDict_SetItemString(dict, "FACETYPE_WALL", Dtool_WrapValue(BSPFaceAttrib::FACETYPE_WALL));
    PyDict_SetItemString(dict, "FACETYPE_FLOOR", Dtool_WrapValue(BSPFaceAttrib::FACETYPE_FLOOR));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_BSPFaceAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_BSPFaceAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPFaceAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPFaceAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPFaceAttrib);
  }
}

/**
 * Python method tables for BSPLoader (BSPLoader)
 */
static PyMethodDef Dtool_Methods_BSPLoader[] = {
  {"remove_physics", &Dtool_BSPLoader_remove_physics_130, METH_O, (const char *)Dtool_BSPLoader_remove_physics_130_comment},
  {"removePhysics", &Dtool_BSPLoader_remove_physics_130, METH_O, (const char *)Dtool_BSPLoader_remove_physics_130_comment},
  {"set_physics_world", &Dtool_BSPLoader_set_physics_world_131, METH_O, (const char *)Dtool_BSPLoader_set_physics_world_131_comment},
  {"setPhysicsWorld", &Dtool_BSPLoader_set_physics_world_131, METH_O, (const char *)Dtool_BSPLoader_set_physics_world_131_comment},
  {"get_physics_world", &Dtool_BSPLoader_get_physics_world_132, METH_NOARGS, (const char *)Dtool_BSPLoader_get_physics_world_132_comment},
  {"getPhysicsWorld", &Dtool_BSPLoader_get_physics_world_132, METH_NOARGS, (const char *)Dtool_BSPLoader_get_physics_world_132_comment},
  {"has_brush_collision_node", &Dtool_BSPLoader_has_brush_collision_node_133, METH_O, (const char *)Dtool_BSPLoader_has_brush_collision_node_133_comment},
  {"hasBrushCollisionNode", &Dtool_BSPLoader_has_brush_collision_node_133, METH_O, (const char *)Dtool_BSPLoader_has_brush_collision_node_133_comment},
  {"has_brush_collision_triangle", (PyCFunction) &Dtool_BSPLoader_has_brush_collision_triangle_134, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_has_brush_collision_triangle_134_comment},
  {"hasBrushCollisionTriangle", (PyCFunction) &Dtool_BSPLoader_has_brush_collision_triangle_134, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_has_brush_collision_triangle_134_comment},
  {"get_brush_triangle_material", (PyCFunction) &Dtool_BSPLoader_get_brush_triangle_material_135, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_brush_triangle_material_135_comment},
  {"getBrushTriangleMaterial", (PyCFunction) &Dtool_BSPLoader_get_brush_triangle_material_135, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_brush_triangle_material_135_comment},
  {"get_brush_triangle_model", (PyCFunction) &Dtool_BSPLoader_get_brush_triangle_model_136, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_brush_triangle_model_136_comment},
  {"getBrushTriangleModel", (PyCFunction) &Dtool_BSPLoader_get_brush_triangle_model_136, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_brush_triangle_model_136_comment},
  {"get_brush_triangle_model_fast", (PyCFunction) &Dtool_BSPLoader_get_brush_triangle_model_fast_137, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_brush_triangle_model_fast_137_comment},
  {"getBrushTriangleModelFast", (PyCFunction) &Dtool_BSPLoader_get_brush_triangle_model_fast_137, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_brush_triangle_model_fast_137_comment},
  {"get_model_origin", &Dtool_BSPLoader_get_model_origin_138, METH_O, (const char *)Dtool_BSPLoader_get_model_origin_138_comment},
  {"getModelOrigin", &Dtool_BSPLoader_get_model_origin_138, METH_O, (const char *)Dtool_BSPLoader_get_model_origin_138_comment},
  {"read", (PyCFunction) &Dtool_BSPLoader_read_139, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_read_139_comment},
  {"do_optimizations", &Dtool_BSPLoader_do_optimizations_140, METH_NOARGS, (const char *)Dtool_BSPLoader_do_optimizations_140_comment},
  {"doOptimizations", &Dtool_BSPLoader_do_optimizations_140, METH_NOARGS, (const char *)Dtool_BSPLoader_do_optimizations_140_comment},
  {"set_gamma", (PyCFunction) &Dtool_BSPLoader_set_gamma_141, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_set_gamma_141_comment},
  {"setGamma", (PyCFunction) &Dtool_BSPLoader_set_gamma_141, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_set_gamma_141_comment},
  {"get_gamma", &Dtool_BSPLoader_get_gamma_142, METH_NOARGS, (const char *)Dtool_BSPLoader_get_gamma_142_comment},
  {"getGamma", &Dtool_BSPLoader_get_gamma_142, METH_NOARGS, (const char *)Dtool_BSPLoader_get_gamma_142_comment},
  {"set_win", &Dtool_BSPLoader_set_win_143, METH_O, (const char *)Dtool_BSPLoader_set_win_143_comment},
  {"setWin", &Dtool_BSPLoader_set_win_143, METH_O, (const char *)Dtool_BSPLoader_set_win_143_comment},
  {"set_camera", &Dtool_BSPLoader_set_camera_144, METH_O, (const char *)Dtool_BSPLoader_set_camera_144_comment},
  {"setCamera", &Dtool_BSPLoader_set_camera_144, METH_O, (const char *)Dtool_BSPLoader_set_camera_144_comment},
  {"set_render", &Dtool_BSPLoader_set_render_145, METH_O, (const char *)Dtool_BSPLoader_set_render_145_comment},
  {"setRender", &Dtool_BSPLoader_set_render_145, METH_O, (const char *)Dtool_BSPLoader_set_render_145_comment},
  {"set_shader_generator", &Dtool_BSPLoader_set_shader_generator_146, METH_O, (const char *)Dtool_BSPLoader_set_shader_generator_146_comment},
  {"setShaderGenerator", &Dtool_BSPLoader_set_shader_generator_146, METH_O, (const char *)Dtool_BSPLoader_set_shader_generator_146_comment},
  {"set_want_visibility", &Dtool_BSPLoader_set_want_visibility_147, METH_O, (const char *)Dtool_BSPLoader_set_want_visibility_147_comment},
  {"setWantVisibility", &Dtool_BSPLoader_set_want_visibility_147, METH_O, (const char *)Dtool_BSPLoader_set_want_visibility_147_comment},
  {"set_want_lightmaps", &Dtool_BSPLoader_set_want_lightmaps_148, METH_O, (const char *)Dtool_BSPLoader_set_want_lightmaps_148_comment},
  {"setWantLightmaps", &Dtool_BSPLoader_set_want_lightmaps_148, METH_O, (const char *)Dtool_BSPLoader_set_want_lightmaps_148_comment},
  {"set_physics_type", &Dtool_BSPLoader_set_physics_type_149, METH_O, (const char *)Dtool_BSPLoader_set_physics_type_149_comment},
  {"setPhysicsType", &Dtool_BSPLoader_set_physics_type_149, METH_O, (const char *)Dtool_BSPLoader_set_physics_type_149_comment},
  {"set_visualize_leafs", &Dtool_BSPLoader_set_visualize_leafs_150, METH_O, (const char *)Dtool_BSPLoader_set_visualize_leafs_150_comment},
  {"setVisualizeLeafs", &Dtool_BSPLoader_set_visualize_leafs_150, METH_O, (const char *)Dtool_BSPLoader_set_visualize_leafs_150_comment},
  {"set_materials_file", &Dtool_BSPLoader_set_materials_file_151, METH_O, (const char *)Dtool_BSPLoader_set_materials_file_151_comment},
  {"setMaterialsFile", &Dtool_BSPLoader_set_materials_file_151, METH_O, (const char *)Dtool_BSPLoader_set_materials_file_151_comment},
  {"set_wireframe", &Dtool_BSPLoader_set_wireframe_152, METH_O, (const char *)Dtool_BSPLoader_set_wireframe_152_comment},
  {"setWireframe", &Dtool_BSPLoader_set_wireframe_152, METH_O, (const char *)Dtool_BSPLoader_set_wireframe_152_comment},
  {"get_wireframe", &Dtool_BSPLoader_get_wireframe_153, METH_NOARGS, (const char *)Dtool_BSPLoader_get_wireframe_153_comment},
  {"getWireframe", &Dtool_BSPLoader_get_wireframe_153, METH_NOARGS, (const char *)Dtool_BSPLoader_get_wireframe_153_comment},
  {"get_camera", &Dtool_BSPLoader_get_camera_154, METH_NOARGS, (const char *)Dtool_BSPLoader_get_camera_154_comment},
  {"getCamera", &Dtool_BSPLoader_get_camera_154, METH_NOARGS, (const char *)Dtool_BSPLoader_get_camera_154_comment},
  {"trace_decal", (PyCFunction) &Dtool_BSPLoader_trace_decal_155, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_trace_decal_155_comment},
  {"traceDecal", (PyCFunction) &Dtool_BSPLoader_trace_decal_155, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_trace_decal_155_comment},
  {"get_closest_cubemap_texture", &Dtool_BSPLoader_get_closest_cubemap_texture_156, METH_O, (const char *)Dtool_BSPLoader_get_closest_cubemap_texture_156_comment},
  {"getClosestCubemapTexture", &Dtool_BSPLoader_get_closest_cubemap_texture_156, METH_O, (const char *)Dtool_BSPLoader_get_closest_cubemap_texture_156_comment},
  {"build_cubemaps", &Dtool_BSPLoader_build_cubemaps_157, METH_NOARGS, (const char *)Dtool_BSPLoader_build_cubemaps_157_comment},
  {"buildCubemaps", &Dtool_BSPLoader_build_cubemaps_157, METH_NOARGS, (const char *)Dtool_BSPLoader_build_cubemaps_157_comment},
  {"set_want_shadows", &Dtool_BSPLoader_set_want_shadows_158, METH_O, (const char *)Dtool_BSPLoader_set_want_shadows_158_comment},
  {"setWantShadows", &Dtool_BSPLoader_set_want_shadows_158, METH_O, (const char *)Dtool_BSPLoader_set_want_shadows_158_comment},
  {"set_shadow_dir", &Dtool_BSPLoader_set_shadow_dir_159, METH_O, (const char *)Dtool_BSPLoader_set_shadow_dir_159_comment},
  {"setShadowDir", &Dtool_BSPLoader_set_shadow_dir_159, METH_O, (const char *)Dtool_BSPLoader_set_shadow_dir_159_comment},
  {"extract_modelnum", &Dtool_BSPLoader_extract_modelnum_160, METH_O, (const char *)Dtool_BSPLoader_extract_modelnum_160_comment},
  {"extractModelnum", &Dtool_BSPLoader_extract_modelnum_160, METH_O, (const char *)Dtool_BSPLoader_extract_modelnum_160_comment},
  {"get_model_bounds", (PyCFunction) &Dtool_BSPLoader_get_model_bounds_161, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_model_bounds_161_comment},
  {"getModelBounds", (PyCFunction) &Dtool_BSPLoader_get_model_bounds_161, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_model_bounds_161_comment},
  {"set_ai", &Dtool_BSPLoader_set_ai_162, METH_O, (const char *)Dtool_BSPLoader_set_ai_162_comment},
  {"setAi", &Dtool_BSPLoader_set_ai_162, METH_O, (const char *)Dtool_BSPLoader_set_ai_162_comment},
  {"is_ai", &Dtool_BSPLoader_is_ai_163, METH_NOARGS, (const char *)Dtool_BSPLoader_is_ai_163_comment},
  {"isAi", &Dtool_BSPLoader_is_ai_163, METH_NOARGS, (const char *)Dtool_BSPLoader_is_ai_163_comment},
  {"trace_line", (PyCFunction) &Dtool_BSPLoader_trace_line_164, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_trace_line_164_comment},
  {"traceLine", (PyCFunction) &Dtool_BSPLoader_trace_line_164, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_trace_line_164_comment},
  {"clip_line", (PyCFunction) &Dtool_BSPLoader_clip_line_165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_clip_line_165_comment},
  {"clipLine", (PyCFunction) &Dtool_BSPLoader_clip_line_165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_clip_line_165_comment},
  {"get_model", &Dtool_BSPLoader_get_model_166, METH_O, (const char *)Dtool_BSPLoader_get_model_166_comment},
  {"getModel", &Dtool_BSPLoader_get_model_166, METH_O, (const char *)Dtool_BSPLoader_get_model_166_comment},
  {"find_leaf", (PyCFunction) &Dtool_BSPLoader_find_leaf_167, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_find_leaf_167_comment},
  {"findLeaf", (PyCFunction) &Dtool_BSPLoader_find_leaf_167, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_find_leaf_167_comment},
  {"find_node", &Dtool_BSPLoader_find_node_168, METH_O, (const char *)Dtool_BSPLoader_find_node_168_comment},
  {"findNode", &Dtool_BSPLoader_find_node_168, METH_O, (const char *)Dtool_BSPLoader_find_node_168_comment},
  {"is_cluster_visible", (PyCFunction) &Dtool_BSPLoader_is_cluster_visible_169, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_is_cluster_visible_169_comment},
  {"isClusterVisible", (PyCFunction) &Dtool_BSPLoader_is_cluster_visible_169, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_is_cluster_visible_169_comment},
  {"pvs_bounds_test", (PyCFunction) &Dtool_BSPLoader_pvs_bounds_test_170, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_pvs_bounds_test_170_comment},
  {"pvsBoundsTest", (PyCFunction) &Dtool_BSPLoader_pvs_bounds_test_170, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_pvs_bounds_test_170_comment},
  {"make_net_bounds", (PyCFunction) &Dtool_BSPLoader_make_net_bounds_171, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_make_net_bounds_171_comment},
  {"makeNetBounds", (PyCFunction) &Dtool_BSPLoader_make_net_bounds_171, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_make_net_bounds_171_comment},
  {"has_active_level", &Dtool_BSPLoader_has_active_level_172, METH_NOARGS, (const char *)Dtool_BSPLoader_has_active_level_172_comment},
  {"hasActiveLevel", &Dtool_BSPLoader_has_active_level_172, METH_NOARGS, (const char *)Dtool_BSPLoader_has_active_level_172_comment},
  {"has_visibility", &Dtool_BSPLoader_has_visibility_173, METH_NOARGS, (const char *)Dtool_BSPLoader_has_visibility_173_comment},
  {"hasVisibility", &Dtool_BSPLoader_has_visibility_173, METH_NOARGS, (const char *)Dtool_BSPLoader_has_visibility_173_comment},
  {"cleanup", (PyCFunction) &Dtool_BSPLoader_cleanup_174, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_cleanup_174_comment},
  {"get_result", &Dtool_BSPLoader_get_result_175, METH_NOARGS, (const char *)Dtool_BSPLoader_get_result_175_comment},
  {"getResult", &Dtool_BSPLoader_get_result_175, METH_NOARGS, (const char *)Dtool_BSPLoader_get_result_175_comment},
  {"set_current_leaf", &Dtool_BSPLoader_set_current_leaf_176, METH_O, (const char *)Dtool_BSPLoader_set_current_leaf_176_comment},
  {"setCurrentLeaf", &Dtool_BSPLoader_set_current_leaf_176, METH_O, (const char *)Dtool_BSPLoader_set_current_leaf_176_comment},
  {"get_current_leaf", &Dtool_BSPLoader_get_current_leaf_177, METH_NOARGS, (const char *)Dtool_BSPLoader_get_current_leaf_177_comment},
  {"getCurrentLeaf", &Dtool_BSPLoader_get_current_leaf_177, METH_NOARGS, (const char *)Dtool_BSPLoader_get_current_leaf_177_comment},
  {"get_num_visleafs", &Dtool_BSPLoader_get_num_visleafs_178, METH_NOARGS, (const char *)Dtool_BSPLoader_get_num_visleafs_178_comment},
  {"getNumVisleafs", &Dtool_BSPLoader_get_num_visleafs_178, METH_NOARGS, (const char *)Dtool_BSPLoader_get_num_visleafs_178_comment},
  {"get_leaf_center", &Dtool_BSPLoader_get_leaf_center_179, METH_O, (const char *)Dtool_BSPLoader_get_leaf_center_179_comment},
  {"getLeafCenter", &Dtool_BSPLoader_get_leaf_center_179, METH_O, (const char *)Dtool_BSPLoader_get_leaf_center_179_comment},
  {"get_lightcoords", (PyCFunction) &Dtool_BSPLoader_get_lightcoords_180, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_lightcoords_180_comment},
  {"getLightcoords", (PyCFunction) &Dtool_BSPLoader_get_lightcoords_180, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_lightcoords_180_comment},
  {"set_global_ptr", &Dtool_BSPLoader_set_global_ptr_181, METH_O | METH_STATIC, (const char *)Dtool_BSPLoader_set_global_ptr_181_comment},
  {"setGlobalPtr", &Dtool_BSPLoader_set_global_ptr_181, METH_O | METH_STATIC, (const char *)Dtool_BSPLoader_set_global_ptr_181_comment},
  {"get_global_ptr", &Dtool_BSPLoader_get_global_ptr_182, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPLoader_get_global_ptr_182_comment},
  {"getGlobalPtr", &Dtool_BSPLoader_get_global_ptr_182, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPLoader_get_global_ptr_182_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_BSPLoader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.BSPLoader",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPLoader,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPLoader,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Loads and handles the operations of PBSP files.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPLoader,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPLoader,
    PyType_GenericAlloc,
    Dtool_new_BSPLoader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPLoader,
  Dtool_UpcastInterface_BSPLoader,
  Dtool_DowncastInterface_BSPLoader,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BSPLoader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BSPLoader._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_BSPLoader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum BSPLoader::PhysicsType;
    PyDict_SetItemString(dict, "PT_none", Dtool_WrapValue(BSPLoader::PT_none));
    PyDict_SetItemString(dict, "PTNone", Dtool_WrapValue(BSPLoader::PT_none));
    PyDict_SetItemString(dict, "PT_panda", Dtool_WrapValue(BSPLoader::PT_panda));
    PyDict_SetItemString(dict, "PTPanda", Dtool_WrapValue(BSPLoader::PT_panda));
    PyDict_SetItemString(dict, "PT_bullet", Dtool_WrapValue(BSPLoader::PT_bullet));
    PyDict_SetItemString(dict, "PTBullet", Dtool_WrapValue(BSPLoader::PT_bullet));
    PyDict_SetItemString(dict, "PT_ode", Dtool_WrapValue(BSPLoader::PT_ode));
    PyDict_SetItemString(dict, "PTOde", Dtool_WrapValue(BSPLoader::PT_ode));
    PyDict_SetItemString(dict, "PT_physx", Dtool_WrapValue(BSPLoader::PT_physx));
    PyDict_SetItemString(dict, "PTPhysx", Dtool_WrapValue(BSPLoader::PT_physx));
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPLoader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPLoader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPLoader);
  }
}

/**
 * Python method tables for BoundingKDOP (BoundingKDOP)
 */
static PyMethodDef Dtool_Methods_BoundingKDOP[] = {
  {"get_num_points", &Dtool_BoundingKDOP_get_num_points_187, METH_NOARGS, (const char *)Dtool_BoundingKDOP_get_num_points_187_comment},
  {"getNumPoints", &Dtool_BoundingKDOP_get_num_points_187, METH_NOARGS, (const char *)Dtool_BoundingKDOP_get_num_points_187_comment},
  {"get_point", &Dtool_BoundingKDOP_get_point_188, METH_O, (const char *)Dtool_BoundingKDOP_get_point_188_comment},
  {"getPoint", &Dtool_BoundingKDOP_get_point_188, METH_O, (const char *)Dtool_BoundingKDOP_get_point_188_comment},
  {"get_num_planes", &Dtool_BoundingKDOP_get_num_planes_189, METH_NOARGS, (const char *)Dtool_BoundingKDOP_get_num_planes_189_comment},
  {"getNumPlanes", &Dtool_BoundingKDOP_get_num_planes_189, METH_NOARGS, (const char *)Dtool_BoundingKDOP_get_num_planes_189_comment},
  {"get_plane", &Dtool_BoundingKDOP_get_plane_190, METH_O, (const char *)Dtool_BoundingKDOP_get_plane_190_comment},
  {"getPlane", &Dtool_BoundingKDOP_get_plane_190, METH_O, (const char *)Dtool_BoundingKDOP_get_plane_190_comment},
  {"get_class_type", &Dtool_BoundingKDOP_get_class_type_191, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingKDOP_get_class_type_191_comment},
  {"getClassType", &Dtool_BoundingKDOP_get_class_type_191, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingKDOP_get_class_type_191_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BoundingKDOP = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BoundingKDOP = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BoundingKDOP = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BoundingKDOP = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BoundingKDOP = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BoundingKDOP = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.BoundingKDOP",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BoundingKDOP,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BoundingKDOP,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BoundingKDOP,
    &Dtool_SequenceMethods_BoundingKDOP,
    &Dtool_MappingMethods_BoundingKDOP,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BoundingKDOP,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines a bounding convex volume.  It may represent any enclosing convex volume,\n"
    " * including simple boxes.  However, if all you want is an axis-aligned\n"
    " * bounding box, you may be better off with the simpler BoundingBox class.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BoundingKDOP,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BoundingKDOP,
    PyType_GenericAlloc,
    Dtool_new_BoundingKDOP,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BoundingKDOP,
  Dtool_UpcastInterface_BoundingKDOP,
  Dtool_DowncastInterface_BoundingKDOP,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BoundingKDOP(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_FiniteBoundingVolume != nullptr);
    assert(Dtool_Ptr_FiniteBoundingVolume->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_FiniteBoundingVolume->_Dtool_ModuleClassInit(nullptr);
    Dtool_BoundingKDOP._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_FiniteBoundingVolume);
    Dtool_BoundingKDOP._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BoundingKDOP._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BoundingKDOP) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BoundingKDOP)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BoundingKDOP);
  }
}

/**
 * Python method tables for CBaseEntity (CBaseEntity)
 */
static PyMethodDef Dtool_Methods_CBaseEntity[] = {
  {"get_class_type", &Dtool_CBaseEntity_get_class_type_194, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBaseEntity_get_class_type_194_comment},
  {"getClassType", &Dtool_CBaseEntity_get_class_type_194, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBaseEntity_get_class_type_194_comment},
  {"get_loader", &Dtool_CBaseEntity_get_loader_196, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_loader_196_comment},
  {"getLoader", &Dtool_CBaseEntity_get_loader_196, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_loader_196_comment},
  {"get_entity_value", &Dtool_CBaseEntity_get_entity_value_197, METH_O, (const char *)Dtool_CBaseEntity_get_entity_value_197_comment},
  {"getEntityValue", &Dtool_CBaseEntity_get_entity_value_197, METH_O, (const char *)Dtool_CBaseEntity_get_entity_value_197_comment},
  {"get_entity_value_vector", &Dtool_CBaseEntity_get_entity_value_vector_198, METH_O, (const char *)Dtool_CBaseEntity_get_entity_value_vector_198_comment},
  {"getEntityValueVector", &Dtool_CBaseEntity_get_entity_value_vector_198, METH_O, (const char *)Dtool_CBaseEntity_get_entity_value_vector_198_comment},
  {"get_entity_value_color", (PyCFunction) &Dtool_CBaseEntity_get_entity_value_color_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CBaseEntity_get_entity_value_color_199_comment},
  {"getEntityValueColor", (PyCFunction) &Dtool_CBaseEntity_get_entity_value_color_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CBaseEntity_get_entity_value_color_199_comment},
  {"get_classname", &Dtool_CBaseEntity_get_classname_200, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_classname_200_comment},
  {"getClassname", &Dtool_CBaseEntity_get_classname_200, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_classname_200_comment},
  {"get_targetname", &Dtool_CBaseEntity_get_targetname_201, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_targetname_201_comment},
  {"getTargetname", &Dtool_CBaseEntity_get_targetname_201, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_targetname_201_comment},
  {"get_bsp_entnum", &Dtool_CBaseEntity_get_bsp_entnum_202, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_bsp_entnum_202_comment},
  {"getBspEntnum", &Dtool_CBaseEntity_get_bsp_entnum_202, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_bsp_entnum_202_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CBaseEntity = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CBaseEntity = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CBaseEntity = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CBaseEntity = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CBaseEntity = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CBaseEntity = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CBaseEntity",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CBaseEntity,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CBaseEntity,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CBaseEntity,
    &Dtool_SequenceMethods_CBaseEntity,
    &Dtool_MappingMethods_CBaseEntity,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CBaseEntity,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CBaseEntity,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CBaseEntity,
    PyType_GenericAlloc,
    Dtool_new_CBaseEntity,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CBaseEntity,
  Dtool_UpcastInterface_CBaseEntity,
  Dtool_DowncastInterface_CBaseEntity,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CBaseEntity(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_CBaseEntity._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_CBaseEntity._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CBaseEntity._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CBaseEntity) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CBaseEntity)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CBaseEntity);
  }
}

/**
 * Python method tables for CPointEntity (CPointEntity)
 */
static PyMethodDef Dtool_Methods_CPointEntity[] = {
  {"get_class_type", &Dtool_CPointEntity_get_class_type_205, METH_NOARGS | METH_STATIC, (const char *)Dtool_CPointEntity_get_class_type_205_comment},
  {"getClassType", &Dtool_CPointEntity_get_class_type_205, METH_NOARGS | METH_STATIC, (const char *)Dtool_CPointEntity_get_class_type_205_comment},
  {"get_origin", &Dtool_CPointEntity_get_origin_207, METH_NOARGS, (const char *)Dtool_CPointEntity_get_origin_207_comment},
  {"getOrigin", &Dtool_CPointEntity_get_origin_207, METH_NOARGS, (const char *)Dtool_CPointEntity_get_origin_207_comment},
  {"get_angles", &Dtool_CPointEntity_get_angles_208, METH_NOARGS, (const char *)Dtool_CPointEntity_get_angles_208_comment},
  {"getAngles", &Dtool_CPointEntity_get_angles_208, METH_NOARGS, (const char *)Dtool_CPointEntity_get_angles_208_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CPointEntity = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CPointEntity = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CPointEntity = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CPointEntity = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CPointEntity = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CPointEntity = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CPointEntity",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CPointEntity,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CPointEntity,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CPointEntity,
    &Dtool_SequenceMethods_CPointEntity,
    &Dtool_MappingMethods_CPointEntity,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CPointEntity,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CPointEntity,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CPointEntity,
    PyType_GenericAlloc,
    Dtool_new_CPointEntity,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CPointEntity,
  Dtool_UpcastInterface_CPointEntity,
  Dtool_DowncastInterface_CPointEntity,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CPointEntity(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CBaseEntity(nullptr);
    Dtool_CPointEntity._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CBaseEntity);
    Dtool_CPointEntity._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CPointEntity._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CPointEntity) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CPointEntity)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CPointEntity);
  }
}

/**
 * Python method tables for CBoundsEntity (CBoundsEntity)
 */
static PyMethodDef Dtool_Methods_CBoundsEntity[] = {
  {"get_class_type", &Dtool_CBoundsEntity_get_class_type_211, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBoundsEntity_get_class_type_211_comment},
  {"getClassType", &Dtool_CBoundsEntity_get_class_type_211, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBoundsEntity_get_class_type_211_comment},
  {"get_bounds", &Dtool_CBoundsEntity_get_bounds_213, METH_NOARGS, (const char *)Dtool_CBoundsEntity_get_bounds_213_comment},
  {"getBounds", &Dtool_CBoundsEntity_get_bounds_213, METH_NOARGS, (const char *)Dtool_CBoundsEntity_get_bounds_213_comment},
  {"is_inside", &Dtool_CBoundsEntity_is_inside_214, METH_O, (const char *)Dtool_CBoundsEntity_is_inside_214_comment},
  {"isInside", &Dtool_CBoundsEntity_is_inside_214, METH_O, (const char *)Dtool_CBoundsEntity_is_inside_214_comment},
  {"fillin_bounds", (PyCFunction) &Dtool_CBoundsEntity_fillin_bounds_215, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CBoundsEntity_fillin_bounds_215_comment},
  {"fillinBounds", (PyCFunction) &Dtool_CBoundsEntity_fillin_bounds_215, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CBoundsEntity_fillin_bounds_215_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CBoundsEntity = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CBoundsEntity = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CBoundsEntity = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CBoundsEntity = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CBoundsEntity = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CBoundsEntity = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CBoundsEntity",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CBoundsEntity,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CBoundsEntity,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CBoundsEntity,
    &Dtool_SequenceMethods_CBoundsEntity,
    &Dtool_MappingMethods_CBoundsEntity,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CBoundsEntity,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A flavor of a brush entity (but doesn't inherit from CBrushEntity) which uses the brush only to describe\n"
    " * the bounds. Useful for triggers or water, because we don't actually care about the brush's geometry.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CBoundsEntity,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CBoundsEntity,
    PyType_GenericAlloc,
    Dtool_new_CBoundsEntity,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CBoundsEntity,
  Dtool_UpcastInterface_CBoundsEntity,
  Dtool_DowncastInterface_CBoundsEntity,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CBoundsEntity(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CBaseEntity(nullptr);
    Dtool_CBoundsEntity._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CBaseEntity);
    Dtool_CBoundsEntity._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CBoundsEntity._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CBoundsEntity) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CBoundsEntity)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CBoundsEntity);
  }
}

/**
 * Python method tables for CBrushEntity (CBrushEntity)
 */
static PyMethodDef Dtool_Methods_CBrushEntity[] = {
  {"get_class_type", &Dtool_CBrushEntity_get_class_type_218, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBrushEntity_get_class_type_218_comment},
  {"getClassType", &Dtool_CBrushEntity_get_class_type_218, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBrushEntity_get_class_type_218_comment},
  {"get_model_np", &Dtool_CBrushEntity_get_model_np_220, METH_NOARGS, (const char *)Dtool_CBrushEntity_get_model_np_220_comment},
  {"getModelNp", &Dtool_CBrushEntity_get_model_np_220, METH_NOARGS, (const char *)Dtool_CBrushEntity_get_model_np_220_comment},
  {"get_model_bounds", (PyCFunction) &Dtool_CBrushEntity_get_model_bounds_221, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CBrushEntity_get_model_bounds_221_comment},
  {"getModelBounds", (PyCFunction) &Dtool_CBrushEntity_get_model_bounds_221, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CBrushEntity_get_model_bounds_221_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CBrushEntity = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CBrushEntity = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CBrushEntity = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CBrushEntity = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CBrushEntity = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CBrushEntity = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CBrushEntity",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CBrushEntity,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CBrushEntity,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CBrushEntity,
    &Dtool_SequenceMethods_CBrushEntity,
    &Dtool_MappingMethods_CBrushEntity,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CBrushEntity,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CBrushEntity,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CBrushEntity,
    PyType_GenericAlloc,
    Dtool_new_CBrushEntity,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CBrushEntity,
  Dtool_UpcastInterface_CBrushEntity,
  Dtool_DowncastInterface_CBrushEntity,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CBrushEntity(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CBaseEntity(nullptr);
    Dtool_CBrushEntity._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CBaseEntity);
    Dtool_CBrushEntity._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CBrushEntity._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CBrushEntity) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CBrushEntity)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CBrushEntity);
  }
}

/**
 * Python method tables for ShaderPermutations (ShaderPermutations)
 */
static PyMethodDef Dtool_Methods_ShaderPermutations[] = {
  {"add_permutation", (PyCFunction) &Dtool_ShaderPermutations_add_permutation_225, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderPermutations_add_permutation_225_comment},
  {"addPermutation", (PyCFunction) &Dtool_ShaderPermutations_add_permutation_225, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderPermutations_add_permutation_225_comment},
  {"complete", &Dtool_ShaderPermutations_complete_226, METH_NOARGS, (const char *)Dtool_ShaderPermutations_complete_226_comment},
  {"add_input", &Dtool_ShaderPermutations_add_input_227, METH_O, (const char *)Dtool_ShaderPermutations_add_input_227_comment},
  {"addInput", &Dtool_ShaderPermutations_add_input_227, METH_O, (const char *)Dtool_ShaderPermutations_add_input_227_comment},
  {"add_flag", &Dtool_ShaderPermutations_add_flag_228, METH_O, (const char *)Dtool_ShaderPermutations_add_flag_228_comment},
  {"addFlag", &Dtool_ShaderPermutations_add_flag_228, METH_O, (const char *)Dtool_ShaderPermutations_add_flag_228_comment},
  {"get_hash", &Dtool_ShaderPermutations_get_hash_229, METH_NOARGS, (const char *)Dtool_ShaderPermutations_get_hash_229_comment},
  {"getHash", &Dtool_ShaderPermutations_get_hash_229, METH_NOARGS, (const char *)Dtool_ShaderPermutations_get_hash_229_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ShaderPermutations slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_ShaderPermutations_get_hash_229_tp_hash(PyObject *self) {
  ShaderPermutations *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderPermutations, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_hash)();
}

static PyNumberMethods Dtool_NumberMethods_ShaderPermutations = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShaderPermutations = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ShaderPermutations = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ShaderPermutations = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ShaderPermutations = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ShaderPermutations = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.ShaderPermutations",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ShaderPermutations,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ShaderPermutations,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    nullptr,
    &Dtool_NumberMethods_ShaderPermutations,
    &Dtool_SequenceMethods_ShaderPermutations,
    &Dtool_MappingMethods_ShaderPermutations,
    &Dtool_ShaderPermutations_get_hash_229_tp_hash,
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ShaderPermutations,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Represents a list of #defines and variable inputs to a shader that is being generated.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
#if PY_MAJOR_VERSION >= 3
    &DtoolInstance_RichComparePointers,
#else
    nullptr, // tp_richcompare
#endif
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShaderPermutations,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShaderPermutations,
    PyType_GenericAlloc,
    Dtool_new_ShaderPermutations,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShaderPermutations,
  Dtool_UpcastInterface_ShaderPermutations,
  Dtool_DowncastInterface_ShaderPermutations,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ShaderPermutations(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_ShaderPermutations._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_ShaderPermutations._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ShaderPermutations._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShaderPermutations) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShaderPermutations)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShaderPermutations);
  }
}

/**
 * Python method tables for ShaderSpec (ShaderSpec)
 */
static PyMethodDef Dtool_Methods_ShaderSpec[] = {
  {"read_shader_files", (PyCFunction) &Dtool_ShaderSpec_read_shader_files_237, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderSpec_read_shader_files_237_comment},
  {"readShaderFiles", (PyCFunction) &Dtool_ShaderSpec_read_shader_files_237, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderSpec_read_shader_files_237_comment},
  {"get_class_type", &Dtool_ShaderSpec_get_class_type_238, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderSpec_get_class_type_238_comment},
  {"getClassType", &Dtool_ShaderSpec_get_class_type_238, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderSpec_get_class_type_238_comment},
  {"upcast_to_ReferenceCount", &Dtool_ShaderSpec_upcast_to_ReferenceCount_232, METH_NOARGS, (const char *)Dtool_ShaderSpec_upcast_to_ReferenceCount_232_comment},
  {"upcastToReferenceCount", &Dtool_ShaderSpec_upcast_to_ReferenceCount_232, METH_NOARGS, (const char *)Dtool_ShaderSpec_upcast_to_ReferenceCount_232_comment},
  {"upcast_to_Namable", &Dtool_ShaderSpec_upcast_to_Namable_235, METH_NOARGS, (const char *)Dtool_ShaderSpec_upcast_to_Namable_235_comment},
  {"upcastToNamable", &Dtool_ShaderSpec_upcast_to_Namable_235, METH_NOARGS, (const char *)Dtool_ShaderSpec_upcast_to_Namable_235_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ShaderSpec = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShaderSpec = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ShaderSpec = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ShaderSpec = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ShaderSpec = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ShaderSpec = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.ShaderSpec",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ShaderSpec,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ShaderSpec,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ShaderSpec,
    &Dtool_SequenceMethods_ShaderSpec,
    &Dtool_MappingMethods_ShaderSpec,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ShaderSpec,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Serves to setup the permutations for a specific shader\n"
    " * when setting up a shader for a specific RenderState.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShaderSpec,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShaderSpec,
    PyType_GenericAlloc,
    Dtool_new_ShaderSpec,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShaderSpec,
  Dtool_UpcastInterface_ShaderSpec,
  Dtool_DowncastInterface_ShaderSpec,
  (CoerceFunction)Dtool_ConstCoerce_ShaderSpec,
  (CoerceFunction)Dtool_Coerce_ShaderSpec,
};

static void Dtool_PyModuleClassInit_ShaderSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_ShaderSpec._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_ReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_ShaderSpec._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ShaderSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShaderSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShaderSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShaderSpec);
  }
}

/**
 * Python method tables for PlanarReflections (PlanarReflections)
 */
static PyMethodDef Dtool_Methods_PlanarReflections[] = {
  {"get_reflection_texture", &Dtool_PlanarReflections_get_reflection_texture_241, METH_NOARGS, (const char *)Dtool_PlanarReflections_get_reflection_texture_241_comment},
  {"getReflectionTexture", &Dtool_PlanarReflections_get_reflection_texture_241, METH_NOARGS, (const char *)Dtool_PlanarReflections_get_reflection_texture_241_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PlanarReflections = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PlanarReflections = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PlanarReflections = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PlanarReflections = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PlanarReflections = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PlanarReflections = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.PlanarReflections",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PlanarReflections,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PlanarReflections,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PlanarReflections,
    &Dtool_SequenceMethods_PlanarReflections,
    &Dtool_MappingMethods_PlanarReflections,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PlanarReflections,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PlanarReflections,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PlanarReflections,
    PyType_GenericAlloc,
    Dtool_new_PlanarReflections,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PlanarReflections,
  Dtool_UpcastInterface_PlanarReflections,
  Dtool_DowncastInterface_PlanarReflections,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PlanarReflections(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_PlanarReflections._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_PlanarReflections._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PlanarReflections._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PlanarReflections) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PlanarReflections)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PlanarReflections);
  }
}

/**
 * Python method tables for BSPShaderGenerator (BSPShaderGenerator)
 */
static PyMethodDef Dtool_Methods_BSPShaderGenerator[] = {
  {"set_sun_light", &Dtool_BSPShaderGenerator_set_sun_light_250, METH_O, (const char *)Dtool_BSPShaderGenerator_set_sun_light_250_comment},
  {"setSunLight", &Dtool_BSPShaderGenerator_set_sun_light_250, METH_O, (const char *)Dtool_BSPShaderGenerator_set_sun_light_250_comment},
  {"add_shader", &Dtool_BSPShaderGenerator_add_shader_251, METH_O, (const char *)Dtool_BSPShaderGenerator_add_shader_251_comment},
  {"addShader", &Dtool_BSPShaderGenerator_add_shader_251, METH_O, (const char *)Dtool_BSPShaderGenerator_add_shader_251_comment},
  {"get_sun_vector", &Dtool_BSPShaderGenerator_get_sun_vector_252, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_sun_vector_252_comment},
  {"getSunVector", &Dtool_BSPShaderGenerator_get_sun_vector_252, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_sun_vector_252_comment},
  {"has_shadow_sunlight", &Dtool_BSPShaderGenerator_has_shadow_sunlight_253, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_has_shadow_sunlight_253_comment},
  {"hasShadowSunlight", &Dtool_BSPShaderGenerator_has_shadow_sunlight_253, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_has_shadow_sunlight_253_comment},
  {"get_pssm_array_texture", &Dtool_BSPShaderGenerator_get_pssm_array_texture_254, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_pssm_array_texture_254_comment},
  {"getPssmArrayTexture", &Dtool_BSPShaderGenerator_get_pssm_array_texture_254, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_pssm_array_texture_254_comment},
  {"get_camera", &Dtool_BSPShaderGenerator_get_camera_256, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_camera_256_comment},
  {"getCamera", &Dtool_BSPShaderGenerator_get_camera_256, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_camera_256_comment},
  {"get_render", &Dtool_BSPShaderGenerator_get_render_257, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_render_257_comment},
  {"getRender", &Dtool_BSPShaderGenerator_get_render_257, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_render_257_comment},
  {"set_shader_quality", &Dtool_BSPShaderGenerator_set_shader_quality_258, METH_O, (const char *)Dtool_BSPShaderGenerator_set_shader_quality_258_comment},
  {"setShaderQuality", &Dtool_BSPShaderGenerator_set_shader_quality_258, METH_O, (const char *)Dtool_BSPShaderGenerator_set_shader_quality_258_comment},
  {"get_shader_quality", &Dtool_BSPShaderGenerator_get_shader_quality_259, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_shader_quality_259_comment},
  {"getShaderQuality", &Dtool_BSPShaderGenerator_get_shader_quality_259, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_shader_quality_259_comment},
  {"set_fog", &Dtool_BSPShaderGenerator_set_fog_260, METH_O, (const char *)Dtool_BSPShaderGenerator_set_fog_260_comment},
  {"setFog", &Dtool_BSPShaderGenerator_set_fog_260, METH_O, (const char *)Dtool_BSPShaderGenerator_set_fog_260_comment},
  {"clear_fog", &Dtool_BSPShaderGenerator_clear_fog_261, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_clear_fog_261_comment},
  {"clearFog", &Dtool_BSPShaderGenerator_clear_fog_261, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_clear_fog_261_comment},
  {"get_fog", &Dtool_BSPShaderGenerator_get_fog_262, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_fog_262_comment},
  {"getFog", &Dtool_BSPShaderGenerator_get_fog_262, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_fog_262_comment},
  {"get_fog_data", &Dtool_BSPShaderGenerator_get_fog_data_263, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_fog_data_263_comment},
  {"getFogData", &Dtool_BSPShaderGenerator_get_fog_data_263, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_fog_data_263_comment},
  {"set_exposure_adustment", &Dtool_BSPShaderGenerator_set_exposure_adustment_264, METH_O, (const char *)Dtool_BSPShaderGenerator_set_exposure_adustment_264_comment},
  {"setExposureAdustment", &Dtool_BSPShaderGenerator_set_exposure_adustment_264, METH_O, (const char *)Dtool_BSPShaderGenerator_set_exposure_adustment_264_comment},
  {"get_exposure_adjustment", &Dtool_BSPShaderGenerator_get_exposure_adjustment_265, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_exposure_adjustment_265_comment},
  {"getExposureAdjustment", &Dtool_BSPShaderGenerator_get_exposure_adjustment_265, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_exposure_adjustment_265_comment},
  {"get_gsg", &Dtool_BSPShaderGenerator_get_gsg_266, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_gsg_266_comment},
  {"getGsg", &Dtool_BSPShaderGenerator_get_gsg_266, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_gsg_266_comment},
  {"get_output", &Dtool_BSPShaderGenerator_get_output_267, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_output_267_comment},
  {"getOutput", &Dtool_BSPShaderGenerator_get_output_267, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_output_267_comment},
  {"get_planar_reflections", &Dtool_BSPShaderGenerator_get_planar_reflections_268, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_planar_reflections_268_comment},
  {"getPlanarReflections", &Dtool_BSPShaderGenerator_get_planar_reflections_268, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_get_planar_reflections_268_comment},
  {"set_identity_cubemap", &Dtool_BSPShaderGenerator_set_identity_cubemap_269, METH_O | METH_STATIC, (const char *)Dtool_BSPShaderGenerator_set_identity_cubemap_269_comment},
  {"setIdentityCubemap", &Dtool_BSPShaderGenerator_set_identity_cubemap_269, METH_O | METH_STATIC, (const char *)Dtool_BSPShaderGenerator_set_identity_cubemap_269_comment},
  {"get_identity_cubemap", &Dtool_BSPShaderGenerator_get_identity_cubemap_270, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPShaderGenerator_get_identity_cubemap_270_comment},
  {"getIdentityCubemap", &Dtool_BSPShaderGenerator_get_identity_cubemap_270, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPShaderGenerator_get_identity_cubemap_270_comment},
  {"make_shader", (PyCFunction) &Dtool_BSPShaderGenerator_make_shader_271, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BSPShaderGenerator_make_shader_271_comment},
  {"makeShader", (PyCFunction) &Dtool_BSPShaderGenerator_make_shader_271, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BSPShaderGenerator_make_shader_271_comment},
  {"update", &Dtool_BSPShaderGenerator_update_272, METH_NOARGS, (const char *)Dtool_BSPShaderGenerator_update_272_comment},
  {"get_class_type", &Dtool_BSPShaderGenerator_get_class_type_273, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPShaderGenerator_get_class_type_273_comment},
  {"getClassType", &Dtool_BSPShaderGenerator_get_class_type_273, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPShaderGenerator_get_class_type_273_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPShaderGenerator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPShaderGenerator = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPShaderGenerator = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPShaderGenerator = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPShaderGenerator = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPShaderGenerator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.BSPShaderGenerator",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPShaderGenerator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPShaderGenerator,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPShaderGenerator,
    &Dtool_SequenceMethods_BSPShaderGenerator,
    &Dtool_MappingMethods_BSPShaderGenerator,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPShaderGenerator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPShaderGenerator,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPShaderGenerator,
    PyType_GenericAlloc,
    Dtool_new_BSPShaderGenerator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPShaderGenerator,
  Dtool_UpcastInterface_BSPShaderGenerator,
  Dtool_DowncastInterface_BSPShaderGenerator,
  (CoerceFunction)Dtool_ConstCoerce_BSPShaderGenerator,
  (CoerceFunction)Dtool_Coerce_BSPShaderGenerator,
};

static void Dtool_PyModuleClassInit_BSPShaderGenerator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ShaderGenerator != nullptr);
    assert(Dtool_Ptr_ShaderGenerator->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ShaderGenerator->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPShaderGenerator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ShaderGenerator);
    Dtool_BSPShaderGenerator._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BSPShaderGenerator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPShaderGenerator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPShaderGenerator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPShaderGenerator);
  }
}

/**
 * Python method tables for BSPCullTraverser (BSPCullTraverser)
 */
static PyMethodDef Dtool_Methods_BSPCullTraverser[] = {
  {"get_class_type", &Dtool_BSPCullTraverser_get_class_type_277, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPCullTraverser_get_class_type_277_comment},
  {"getClassType", &Dtool_BSPCullTraverser_get_class_type_277, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPCullTraverser_get_class_type_277_comment},
  {"has_camera_bits", &Dtool_BSPCullTraverser_has_camera_bits_279, METH_O, (const char *)Dtool_BSPCullTraverser_has_camera_bits_279_comment},
  {"hasCameraBits", &Dtool_BSPCullTraverser_has_camera_bits_279, METH_O, (const char *)Dtool_BSPCullTraverser_has_camera_bits_279_comment},
  {"needs_lighting", &Dtool_BSPCullTraverser_needs_lighting_280, METH_NOARGS, (const char *)Dtool_BSPCullTraverser_needs_lighting_280_comment},
  {"needsLighting", &Dtool_BSPCullTraverser_needs_lighting_280, METH_NOARGS, (const char *)Dtool_BSPCullTraverser_needs_lighting_280_comment},
  {"needs_culling", &Dtool_BSPCullTraverser_needs_culling_281, METH_NOARGS, (const char *)Dtool_BSPCullTraverser_needs_culling_281_comment},
  {"needsCulling", &Dtool_BSPCullTraverser_needs_culling_281, METH_NOARGS, (const char *)Dtool_BSPCullTraverser_needs_culling_281_comment},
  {"get_required_leaf_flags", &Dtool_BSPCullTraverser_get_required_leaf_flags_282, METH_NOARGS, (const char *)Dtool_BSPCullTraverser_get_required_leaf_flags_282_comment},
  {"getRequiredLeafFlags", &Dtool_BSPCullTraverser_get_required_leaf_flags_282, METH_NOARGS, (const char *)Dtool_BSPCullTraverser_get_required_leaf_flags_282_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPCullTraverser = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPCullTraverser = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPCullTraverser = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPCullTraverser = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPCullTraverser = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPCullTraverser = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.BSPCullTraverser",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPCullTraverser,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPCullTraverser,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPCullTraverser,
    &Dtool_SequenceMethods_BSPCullTraverser,
    &Dtool_MappingMethods_BSPCullTraverser,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPCullTraverser,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPCullTraverser,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPCullTraverser,
    PyType_GenericAlloc,
    Dtool_new_BSPCullTraverser,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPCullTraverser,
  Dtool_UpcastInterface_BSPCullTraverser,
  Dtool_DowncastInterface_BSPCullTraverser,
  (CoerceFunction)Dtool_ConstCoerce_BSPCullTraverser,
  (CoerceFunction)Dtool_Coerce_BSPCullTraverser,
};

static void Dtool_PyModuleClassInit_BSPCullTraverser(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CullTraverser != nullptr);
    assert(Dtool_Ptr_CullTraverser->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CullTraverser->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPCullTraverser._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CullTraverser);
    Dtool_BSPCullTraverser._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BSPCullTraverser._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPCullTraverser) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPCullTraverser)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPCullTraverser);
  }
}

/**
 * Python method tables for BSPRender (BSPRender)
 */
static PyMethodDef Dtool_Methods_BSPRender[] = {
  {"get_class_type", &Dtool_BSPRender_get_class_type_285, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPRender_get_class_type_285_comment},
  {"getClassType", &Dtool_BSPRender_get_class_type_285, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPRender_get_class_type_285_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPRender = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPRender = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPRender = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPRender = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPRender = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPRender = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.BSPRender",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPRender,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPRender,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPRender,
    &Dtool_SequenceMethods_BSPRender,
    &Dtool_MappingMethods_BSPRender,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPRender,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Top of the scene graph when a BSP level is in effect.\n"
    " * Culls nodes against the PVS, operates ambient cubes, etc.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPRender,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPRender,
    PyType_GenericAlloc,
    Dtool_new_BSPRender,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPRender,
  Dtool_UpcastInterface_BSPRender,
  Dtool_DowncastInterface_BSPRender,
  (CoerceFunction)Dtool_ConstCoerce_BSPRender,
  (CoerceFunction)Dtool_Coerce_BSPRender,
};

static void Dtool_PyModuleClassInit_BSPRender(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPRender._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_BSPRender._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BSPRender._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPRender) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPRender)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPRender);
  }
}

/**
 * Python method tables for BSPRoot (BSPRoot)
 */
static PyMethodDef Dtool_Methods_BSPRoot[] = {
  {"get_class_type", &Dtool_BSPRoot_get_class_type_289, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPRoot_get_class_type_289_comment},
  {"getClassType", &Dtool_BSPRoot_get_class_type_289, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPRoot_get_class_type_289_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPRoot = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPRoot = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPRoot = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPRoot = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPRoot = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPRoot = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.BSPRoot",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPRoot,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPRoot,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPRoot,
    &Dtool_SequenceMethods_BSPRoot,
    &Dtool_MappingMethods_BSPRoot,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPRoot,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPRoot,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPRoot,
    PyType_GenericAlloc,
    Dtool_new_BSPRoot,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPRoot,
  Dtool_UpcastInterface_BSPRoot,
  Dtool_DowncastInterface_BSPRoot,
  (CoerceFunction)Dtool_ConstCoerce_BSPRoot,
  (CoerceFunction)Dtool_Coerce_BSPRoot,
};

static void Dtool_PyModuleClassInit_BSPRoot(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPRoot._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_BSPRoot._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BSPRoot._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPRoot) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPRoot)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPRoot);
  }
}

/**
 * Python method tables for BSPProp (BSPProp)
 */
static PyMethodDef Dtool_Methods_BSPProp[] = {
  {"get_class_type", &Dtool_BSPProp_get_class_type_294, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPProp_get_class_type_294_comment},
  {"getClassType", &Dtool_BSPProp_get_class_type_294, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPProp_get_class_type_294_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPProp = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPProp = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPProp = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPProp = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPProp = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPProp = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.BSPProp",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPProp,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPProp,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPProp,
    &Dtool_SequenceMethods_BSPProp,
    &Dtool_MappingMethods_BSPProp,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPProp,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPProp,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPProp,
    PyType_GenericAlloc,
    Dtool_new_BSPProp,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPProp,
  Dtool_UpcastInterface_BSPProp,
  Dtool_DowncastInterface_BSPProp,
  (CoerceFunction)Dtool_ConstCoerce_BSPProp,
  (CoerceFunction)Dtool_Coerce_BSPProp,
};

static void Dtool_PyModuleClassInit_BSPProp(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ModelRoot != nullptr);
    assert(Dtool_Ptr_ModelRoot->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ModelRoot->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPProp._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ModelRoot);
    Dtool_BSPProp._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BSPProp._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPProp) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPProp)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPProp);
  }
}

/**
 * Python method tables for BSPModel (BSPModel)
 */
static PyMethodDef Dtool_Methods_BSPModel[] = {
  {"get_class_type", &Dtool_BSPModel_get_class_type_299, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPModel_get_class_type_299_comment},
  {"getClassType", &Dtool_BSPModel_get_class_type_299, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPModel_get_class_type_299_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPModel = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPModel = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPModel = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPModel = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPModel = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPModel = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.BSPModel",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPModel,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPModel,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPModel,
    &Dtool_SequenceMethods_BSPModel,
    &Dtool_MappingMethods_BSPModel,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPModel,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPModel,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPModel,
    PyType_GenericAlloc,
    Dtool_new_BSPModel,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPModel,
  Dtool_UpcastInterface_BSPModel,
  Dtool_DowncastInterface_BSPModel,
  (CoerceFunction)Dtool_ConstCoerce_BSPModel,
  (CoerceFunction)Dtool_Coerce_BSPModel,
};

static void Dtool_PyModuleClassInit_BSPModel(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ModelNode != nullptr);
    assert(Dtool_Ptr_ModelNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ModelNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPModel._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ModelNode);
    Dtool_BSPModel._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BSPModel._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPModel) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPModel)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPModel);
  }
}

/**
 * Python method tables for VertexLitGenericSpec (VertexLitGenericSpec)
 */
static PyMethodDef Dtool_Methods_VertexLitGenericSpec[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_VertexLitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VertexLitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VertexLitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VertexLitGenericSpec = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VertexLitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VertexLitGenericSpec = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.VertexLitGenericSpec",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VertexLitGenericSpec,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VertexLitGenericSpec,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VertexLitGenericSpec,
    &Dtool_SequenceMethods_VertexLitGenericSpec,
    &Dtool_MappingMethods_VertexLitGenericSpec,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VertexLitGenericSpec,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VertexLitGenericSpec,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VertexLitGenericSpec,
    PyType_GenericAlloc,
    Dtool_new_VertexLitGenericSpec,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VertexLitGenericSpec,
  Dtool_UpcastInterface_VertexLitGenericSpec,
  Dtool_DowncastInterface_VertexLitGenericSpec,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VertexLitGenericSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ShaderSpec(nullptr);
    Dtool_VertexLitGenericSpec._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ShaderSpec);
    Dtool_VertexLitGenericSpec._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VertexLitGenericSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VertexLitGenericSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VertexLitGenericSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VertexLitGenericSpec);
  }
}

/**
 * Python method tables for LightmappedGenericSpec (LightmappedGenericSpec)
 */
static PyMethodDef Dtool_Methods_LightmappedGenericSpec[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LightmappedGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LightmappedGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LightmappedGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LightmappedGenericSpec = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LightmappedGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LightmappedGenericSpec = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.LightmappedGenericSpec",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LightmappedGenericSpec,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LightmappedGenericSpec,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LightmappedGenericSpec,
    &Dtool_SequenceMethods_LightmappedGenericSpec,
    &Dtool_MappingMethods_LightmappedGenericSpec,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LightmappedGenericSpec,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LightmappedGenericSpec,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LightmappedGenericSpec,
    PyType_GenericAlloc,
    Dtool_new_LightmappedGenericSpec,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightmappedGenericSpec,
  Dtool_UpcastInterface_LightmappedGenericSpec,
  Dtool_DowncastInterface_LightmappedGenericSpec,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LightmappedGenericSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ShaderSpec(nullptr);
    Dtool_LightmappedGenericSpec._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ShaderSpec);
    Dtool_LightmappedGenericSpec._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LightmappedGenericSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightmappedGenericSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightmappedGenericSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightmappedGenericSpec);
  }
}

/**
 * Python method tables for UnlitGenericSpec (UnlitGenericSpec)
 */
static PyMethodDef Dtool_Methods_UnlitGenericSpec[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_UnlitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_UnlitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_UnlitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_UnlitGenericSpec = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_UnlitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_UnlitGenericSpec = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.UnlitGenericSpec",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_UnlitGenericSpec,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_UnlitGenericSpec,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_UnlitGenericSpec,
    &Dtool_SequenceMethods_UnlitGenericSpec,
    &Dtool_MappingMethods_UnlitGenericSpec,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_UnlitGenericSpec,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Shader that only supports a basetexture, no fancy lighting effects or anything.\n"
    " * Could be used for UI elements, emissive materials, particles, etc.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_UnlitGenericSpec,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_UnlitGenericSpec,
    PyType_GenericAlloc,
    Dtool_new_UnlitGenericSpec,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UnlitGenericSpec,
  Dtool_UpcastInterface_UnlitGenericSpec,
  Dtool_DowncastInterface_UnlitGenericSpec,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_UnlitGenericSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ShaderSpec(nullptr);
    Dtool_UnlitGenericSpec._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ShaderSpec);
    Dtool_UnlitGenericSpec._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_UnlitGenericSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UnlitGenericSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UnlitGenericSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UnlitGenericSpec);
  }
}

/**
 * Python method tables for UnlitNoMatSpec (UnlitNoMatSpec)
 */
static PyMethodDef Dtool_Methods_UnlitNoMatSpec[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_UnlitNoMatSpec = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_UnlitNoMatSpec = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_UnlitNoMatSpec = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_UnlitNoMatSpec = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_UnlitNoMatSpec = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_UnlitNoMatSpec = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.UnlitNoMatSpec",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_UnlitNoMatSpec,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_UnlitNoMatSpec,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_UnlitNoMatSpec,
    &Dtool_SequenceMethods_UnlitNoMatSpec,
    &Dtool_MappingMethods_UnlitNoMatSpec,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_UnlitNoMatSpec,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_UnlitNoMatSpec,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_UnlitNoMatSpec,
    PyType_GenericAlloc,
    Dtool_new_UnlitNoMatSpec,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UnlitNoMatSpec,
  Dtool_UpcastInterface_UnlitNoMatSpec,
  Dtool_DowncastInterface_UnlitNoMatSpec,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_UnlitNoMatSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ShaderSpec(nullptr);
    Dtool_UnlitNoMatSpec._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ShaderSpec);
    Dtool_UnlitNoMatSpec._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_UnlitNoMatSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UnlitNoMatSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UnlitNoMatSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UnlitNoMatSpec);
  }
}

/**
 * Python method tables for CSMRenderSpec (CSMRenderSpec)
 */
static PyMethodDef Dtool_Methods_CSMRenderSpec[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CSMRenderSpec = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CSMRenderSpec = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CSMRenderSpec = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CSMRenderSpec = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CSMRenderSpec = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CSMRenderSpec = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CSMRenderSpec",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CSMRenderSpec,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CSMRenderSpec,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CSMRenderSpec,
    &Dtool_SequenceMethods_CSMRenderSpec,
    &Dtool_MappingMethods_CSMRenderSpec,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CSMRenderSpec,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CSMRenderSpec,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CSMRenderSpec,
    PyType_GenericAlloc,
    Dtool_new_CSMRenderSpec,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CSMRenderSpec,
  Dtool_UpcastInterface_CSMRenderSpec,
  Dtool_DowncastInterface_CSMRenderSpec,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CSMRenderSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ShaderSpec(nullptr);
    Dtool_CSMRenderSpec._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ShaderSpec);
    Dtool_CSMRenderSpec._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CSMRenderSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CSMRenderSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CSMRenderSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CSMRenderSpec);
  }
}

/**
 * Python method tables for SkyBoxSpec (SkyBoxSpec)
 */
static PyMethodDef Dtool_Methods_SkyBoxSpec[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_SkyBoxSpec = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SkyBoxSpec = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SkyBoxSpec = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SkyBoxSpec = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SkyBoxSpec = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SkyBoxSpec = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.SkyBoxSpec",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SkyBoxSpec,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SkyBoxSpec,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_SkyBoxSpec,
    &Dtool_SequenceMethods_SkyBoxSpec,
    &Dtool_MappingMethods_SkyBoxSpec,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SkyBoxSpec,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SkyBoxSpec,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SkyBoxSpec,
    PyType_GenericAlloc,
    Dtool_new_SkyBoxSpec,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SkyBoxSpec,
  Dtool_UpcastInterface_SkyBoxSpec,
  Dtool_DowncastInterface_SkyBoxSpec,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SkyBoxSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ShaderSpec(nullptr);
    Dtool_SkyBoxSpec._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ShaderSpec);
    Dtool_SkyBoxSpec._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SkyBoxSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SkyBoxSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SkyBoxSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SkyBoxSpec);
  }
}

/**
 * Python method tables for AmbientBoostEffect (AmbientBoostEffect)
 */
static PyMethodDef Dtool_Methods_AmbientBoostEffect[] = {
  {"make", &Dtool_AmbientBoostEffect_make_322, METH_NOARGS | METH_STATIC, (const char *)Dtool_AmbientBoostEffect_make_322_comment},
  {"get_class_type", &Dtool_AmbientBoostEffect_get_class_type_323, METH_NOARGS | METH_STATIC, (const char *)Dtool_AmbientBoostEffect_get_class_type_323_comment},
  {"getClassType", &Dtool_AmbientBoostEffect_get_class_type_323, METH_NOARGS | METH_STATIC, (const char *)Dtool_AmbientBoostEffect_get_class_type_323_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AmbientBoostEffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AmbientBoostEffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AmbientBoostEffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AmbientBoostEffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AmbientBoostEffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AmbientBoostEffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.AmbientBoostEffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AmbientBoostEffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AmbientBoostEffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AmbientBoostEffect,
    &Dtool_SequenceMethods_AmbientBoostEffect,
    &Dtool_MappingMethods_AmbientBoostEffect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AmbientBoostEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AmbientBoostEffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AmbientBoostEffect,
    PyType_GenericAlloc,
    Dtool_new_AmbientBoostEffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AmbientBoostEffect,
  Dtool_UpcastInterface_AmbientBoostEffect,
  Dtool_DowncastInterface_AmbientBoostEffect,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AmbientBoostEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_RenderEffect != nullptr);
    assert(Dtool_Ptr_RenderEffect->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_RenderEffect->_Dtool_ModuleClassInit(nullptr);
    Dtool_AmbientBoostEffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_RenderEffect);
    Dtool_AmbientBoostEffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AmbientBoostEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AmbientBoostEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AmbientBoostEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AmbientBoostEffect);
  }
}

/**
 * Python method tables for Audio3DManager (Audio3DManager)
 */
static PyMethodDef Dtool_Methods_Audio3DManager[] = {
  {"set_distance_factor", &Dtool_Audio3DManager_set_distance_factor_327, METH_O, (const char *)Dtool_Audio3DManager_set_distance_factor_327_comment},
  {"setDistanceFactor", &Dtool_Audio3DManager_set_distance_factor_327, METH_O, (const char *)Dtool_Audio3DManager_set_distance_factor_327_comment},
  {"get_distance_factor", &Dtool_Audio3DManager_get_distance_factor_328, METH_NOARGS, (const char *)Dtool_Audio3DManager_get_distance_factor_328_comment},
  {"getDistanceFactor", &Dtool_Audio3DManager_get_distance_factor_328, METH_NOARGS, (const char *)Dtool_Audio3DManager_get_distance_factor_328_comment},
  {"set_doppler_factor", &Dtool_Audio3DManager_set_doppler_factor_329, METH_O, (const char *)Dtool_Audio3DManager_set_doppler_factor_329_comment},
  {"setDopplerFactor", &Dtool_Audio3DManager_set_doppler_factor_329, METH_O, (const char *)Dtool_Audio3DManager_set_doppler_factor_329_comment},
  {"get_doppler_factor", &Dtool_Audio3DManager_get_doppler_factor_330, METH_NOARGS, (const char *)Dtool_Audio3DManager_get_doppler_factor_330_comment},
  {"getDopplerFactor", &Dtool_Audio3DManager_get_doppler_factor_330, METH_NOARGS, (const char *)Dtool_Audio3DManager_get_doppler_factor_330_comment},
  {"set_drop_off_factor", &Dtool_Audio3DManager_set_drop_off_factor_331, METH_O, (const char *)Dtool_Audio3DManager_set_drop_off_factor_331_comment},
  {"setDropOffFactor", &Dtool_Audio3DManager_set_drop_off_factor_331, METH_O, (const char *)Dtool_Audio3DManager_set_drop_off_factor_331_comment},
  {"get_drop_off_factor", &Dtool_Audio3DManager_get_drop_off_factor_332, METH_NOARGS, (const char *)Dtool_Audio3DManager_get_drop_off_factor_332_comment},
  {"getDropOffFactor", &Dtool_Audio3DManager_get_drop_off_factor_332, METH_NOARGS, (const char *)Dtool_Audio3DManager_get_drop_off_factor_332_comment},
  {"set_sound_min_distance", (PyCFunction) &Dtool_Audio3DManager_set_sound_min_distance_333, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Audio3DManager_set_sound_min_distance_333_comment},
  {"setSoundMinDistance", (PyCFunction) &Dtool_Audio3DManager_set_sound_min_distance_333, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Audio3DManager_set_sound_min_distance_333_comment},
  {"get_sound_min_distance", &Dtool_Audio3DManager_get_sound_min_distance_334, METH_O, (const char *)Dtool_Audio3DManager_get_sound_min_distance_334_comment},
  {"getSoundMinDistance", &Dtool_Audio3DManager_get_sound_min_distance_334, METH_O, (const char *)Dtool_Audio3DManager_get_sound_min_distance_334_comment},
  {"set_sound_max_distance", (PyCFunction) &Dtool_Audio3DManager_set_sound_max_distance_335, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Audio3DManager_set_sound_max_distance_335_comment},
  {"setSoundMaxDistance", (PyCFunction) &Dtool_Audio3DManager_set_sound_max_distance_335, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Audio3DManager_set_sound_max_distance_335_comment},
  {"get_sound_max_distance", &Dtool_Audio3DManager_get_sound_max_distance_336, METH_O, (const char *)Dtool_Audio3DManager_get_sound_max_distance_336_comment},
  {"getSoundMaxDistance", &Dtool_Audio3DManager_get_sound_max_distance_336, METH_O, (const char *)Dtool_Audio3DManager_get_sound_max_distance_336_comment},
  {"attach_listener", &Dtool_Audio3DManager_attach_listener_337, METH_O, (const char *)Dtool_Audio3DManager_attach_listener_337_comment},
  {"attachListener", &Dtool_Audio3DManager_attach_listener_337, METH_O, (const char *)Dtool_Audio3DManager_attach_listener_337_comment},
  {"detach_listener", &Dtool_Audio3DManager_detach_listener_338, METH_NOARGS, (const char *)Dtool_Audio3DManager_detach_listener_338_comment},
  {"detachListener", &Dtool_Audio3DManager_detach_listener_338, METH_NOARGS, (const char *)Dtool_Audio3DManager_detach_listener_338_comment},
  {"load_sfx", &Dtool_Audio3DManager_load_sfx_339, METH_O, (const char *)Dtool_Audio3DManager_load_sfx_339_comment},
  {"loadSfx", &Dtool_Audio3DManager_load_sfx_339, METH_O, (const char *)Dtool_Audio3DManager_load_sfx_339_comment},
  {"attach_sound_to_object", (PyCFunction) &Dtool_Audio3DManager_attach_sound_to_object_340, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Audio3DManager_attach_sound_to_object_340_comment},
  {"attachSoundToObject", (PyCFunction) &Dtool_Audio3DManager_attach_sound_to_object_340, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Audio3DManager_attach_sound_to_object_340_comment},
  {"detach_sound", &Dtool_Audio3DManager_detach_sound_341, METH_O, (const char *)Dtool_Audio3DManager_detach_sound_341_comment},
  {"detachSound", &Dtool_Audio3DManager_detach_sound_341, METH_O, (const char *)Dtool_Audio3DManager_detach_sound_341_comment},
  {"print_audio_digest", &Dtool_Audio3DManager_print_audio_digest_342, METH_NOARGS, (const char *)Dtool_Audio3DManager_print_audio_digest_342_comment},
  {"printAudioDigest", &Dtool_Audio3DManager_print_audio_digest_342, METH_NOARGS, (const char *)Dtool_Audio3DManager_print_audio_digest_342_comment},
  {"update", &Dtool_Audio3DManager_update_343, METH_NOARGS, (const char *)Dtool_Audio3DManager_update_343_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Audio3DManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Audio3DManager = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Audio3DManager = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Audio3DManager = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Audio3DManager = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Audio3DManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.Audio3DManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Audio3DManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Audio3DManager,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Audio3DManager,
    &Dtool_SequenceMethods_Audio3DManager,
    &Dtool_MappingMethods_Audio3DManager,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Audio3DManager,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Audio3DManager,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Audio3DManager,
    PyType_GenericAlloc,
    Dtool_new_Audio3DManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Audio3DManager,
  Dtool_UpcastInterface_Audio3DManager,
  Dtool_DowncastInterface_Audio3DManager,
  (CoerceFunction)Dtool_ConstCoerce_Audio3DManager,
  (CoerceFunction)Dtool_Coerce_Audio3DManager,
};

static void Dtool_PyModuleClassInit_Audio3DManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_Audio3DManager._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_Audio3DManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Audio3DManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Audio3DManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Audio3DManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Audio3DManager);
  }
}

/**
 * Python method tables for CIOLib (CIOLib)
 */
static PyMethodDef Dtool_Methods_CIOLib[] = {
  {"set_pupil_direction", (PyCFunction) &Dtool_CIOLib_set_pupil_direction_346, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_CIOLib_set_pupil_direction_346_comment},
  {"setPupilDirection", (PyCFunction) &Dtool_CIOLib_set_pupil_direction_346, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_CIOLib_set_pupil_direction_346_comment},
  {"look_pupils_at", (PyCFunction) &Dtool_CIOLib_look_pupils_at_347, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_CIOLib_look_pupils_at_347_comment},
  {"lookPupilsAt", (PyCFunction) &Dtool_CIOLib_look_pupils_at_347, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_CIOLib_look_pupils_at_347_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CIOLib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_CIOLib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CIOLib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CIOLib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CIOLib,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CIOLib,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CIOLib,
    PyType_GenericAlloc,
    Dtool_new_CIOLib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CIOLib,
  Dtool_UpcastInterface_CIOLib,
  Dtool_DowncastInterface_CIOLib,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CIOLib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CIOLib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CIOLib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CIOLib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CIOLib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CIOLib);
  }
}

/**
 * Python method tables for DecalModulateSpec (DecalModulateSpec)
 */
static PyMethodDef Dtool_Methods_DecalModulateSpec[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DecalModulateSpec = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DecalModulateSpec = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DecalModulateSpec = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DecalModulateSpec = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DecalModulateSpec = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DecalModulateSpec = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.DecalModulateSpec",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DecalModulateSpec,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DecalModulateSpec,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DecalModulateSpec,
    &Dtool_SequenceMethods_DecalModulateSpec,
    &Dtool_MappingMethods_DecalModulateSpec,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DecalModulateSpec,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is just an alias of UnlitGeneric that enables color blending on the decal.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DecalModulateSpec,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DecalModulateSpec,
    PyType_GenericAlloc,
    Dtool_new_DecalModulateSpec,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DecalModulateSpec,
  Dtool_UpcastInterface_DecalModulateSpec,
  Dtool_DowncastInterface_DecalModulateSpec,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DecalModulateSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_UnlitGenericSpec(nullptr);
    Dtool_DecalModulateSpec._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_UnlitGenericSpec);
    Dtool_DecalModulateSpec._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DecalModulateSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DecalModulateSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DecalModulateSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DecalModulateSpec);
  }
}

/**
 * Python method tables for GlowNode (GlowNode)
 */
static PyMethodDef Dtool_Methods_GlowNode[] = {
  {"get_class_type", &Dtool_GlowNode_get_class_type_355, METH_NOARGS | METH_STATIC, (const char *)Dtool_GlowNode_get_class_type_355_comment},
  {"getClassType", &Dtool_GlowNode_get_class_type_355, METH_NOARGS | METH_STATIC, (const char *)Dtool_GlowNode_get_class_type_355_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GlowNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GlowNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GlowNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GlowNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GlowNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GlowNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.GlowNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GlowNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GlowNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GlowNode,
    &Dtool_SequenceMethods_GlowNode,
    &Dtool_MappingMethods_GlowNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GlowNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization on GeomNode that uses a pixel occlusion query\n"
    " * to determine if the Geoms on the node should be rendered.\n"
    " *\n"
    " * This is useful for things like light glows or lens flares.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GlowNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GlowNode,
    PyType_GenericAlloc,
    Dtool_new_GlowNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GlowNode,
  Dtool_UpcastInterface_GlowNode,
  Dtool_DowncastInterface_GlowNode,
  (CoerceFunction)Dtool_ConstCoerce_GlowNode,
  (CoerceFunction)Dtool_Coerce_GlowNode,
};

static void Dtool_PyModuleClassInit_GlowNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_GeomNode != nullptr);
    assert(Dtool_Ptr_GeomNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_GeomNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_GlowNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_GeomNode);
    Dtool_GlowNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GlowNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GlowNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GlowNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GlowNode);
  }
}

/**
 * Python method tables for PostProcessEffect (PostProcessEffect)
 */
static PyMethodDef Dtool_Methods_PostProcessEffect[] = {
  {"get_class_type", &Dtool_PostProcessEffect_get_class_type_363, METH_NOARGS | METH_STATIC, (const char *)Dtool_PostProcessEffect_get_class_type_363_comment},
  {"getClassType", &Dtool_PostProcessEffect_get_class_type_363, METH_NOARGS | METH_STATIC, (const char *)Dtool_PostProcessEffect_get_class_type_363_comment},
  {"get_final_texture", &Dtool_PostProcessEffect_get_final_texture_364, METH_NOARGS, (const char *)Dtool_PostProcessEffect_get_final_texture_364_comment},
  {"getFinalTexture", &Dtool_PostProcessEffect_get_final_texture_364, METH_NOARGS, (const char *)Dtool_PostProcessEffect_get_final_texture_364_comment},
  {"add_pass", &Dtool_PostProcessEffect_add_pass_365, METH_O, (const char *)Dtool_PostProcessEffect_add_pass_365_comment},
  {"addPass", &Dtool_PostProcessEffect_add_pass_365, METH_O, (const char *)Dtool_PostProcessEffect_add_pass_365_comment},
  {"remove_pass", &Dtool_PostProcessEffect_remove_pass_366, METH_O, (const char *)Dtool_PostProcessEffect_remove_pass_366_comment},
  {"removePass", &Dtool_PostProcessEffect_remove_pass_366, METH_O, (const char *)Dtool_PostProcessEffect_remove_pass_366_comment},
  {"get_pass", &Dtool_PostProcessEffect_get_pass_367, METH_O, (const char *)Dtool_PostProcessEffect_get_pass_367_comment},
  {"getPass", &Dtool_PostProcessEffect_get_pass_367, METH_O, (const char *)Dtool_PostProcessEffect_get_pass_367_comment},
  {"setup", &Dtool_PostProcessEffect_setup_368, METH_NOARGS, (const char *)Dtool_PostProcessEffect_setup_368_comment},
  {"update", &Dtool_PostProcessEffect_update_369, METH_NOARGS, (const char *)Dtool_PostProcessEffect_update_369_comment},
  {"window_event", &Dtool_PostProcessEffect_window_event_370, METH_O, (const char *)Dtool_PostProcessEffect_window_event_370_comment},
  {"windowEvent", &Dtool_PostProcessEffect_window_event_370, METH_O, (const char *)Dtool_PostProcessEffect_window_event_370_comment},
  {"shutdown", &Dtool_PostProcessEffect_shutdown_371, METH_NOARGS, (const char *)Dtool_PostProcessEffect_shutdown_371_comment},
  {"upcast_to_ReferenceCount", &Dtool_PostProcessEffect_upcast_to_ReferenceCount_359, METH_NOARGS, (const char *)Dtool_PostProcessEffect_upcast_to_ReferenceCount_359_comment},
  {"upcastToReferenceCount", &Dtool_PostProcessEffect_upcast_to_ReferenceCount_359, METH_NOARGS, (const char *)Dtool_PostProcessEffect_upcast_to_ReferenceCount_359_comment},
  {"upcast_to_Namable", &Dtool_PostProcessEffect_upcast_to_Namable_361, METH_NOARGS, (const char *)Dtool_PostProcessEffect_upcast_to_Namable_361_comment},
  {"upcastToNamable", &Dtool_PostProcessEffect_upcast_to_Namable_361, METH_NOARGS, (const char *)Dtool_PostProcessEffect_upcast_to_Namable_361_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PostProcessEffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PostProcessEffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PostProcessEffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PostProcessEffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PostProcessEffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PostProcessEffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.PostProcessEffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PostProcessEffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PostProcessEffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PostProcessEffect,
    &Dtool_SequenceMethods_PostProcessEffect,
    &Dtool_MappingMethods_PostProcessEffect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PostProcessEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PostProcessEffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PostProcessEffect,
    PyType_GenericAlloc,
    Dtool_new_PostProcessEffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PostProcessEffect,
  Dtool_UpcastInterface_PostProcessEffect,
  Dtool_DowncastInterface_PostProcessEffect,
  (CoerceFunction)Dtool_ConstCoerce_PostProcessEffect,
  (CoerceFunction)Dtool_Coerce_PostProcessEffect,
};

static void Dtool_PyModuleClassInit_PostProcessEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_PostProcessEffect._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_ReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_PostProcessEffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PostProcessEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PostProcessEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PostProcessEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PostProcessEffect);
  }
}

/**
 * Python method tables for PostProcessPass (PostProcessPass)
 */
static PyMethodDef Dtool_Methods_PostProcessPass[] = {
  {"get_class_type", &Dtool_PostProcessPass_get_class_type_379, METH_NOARGS | METH_STATIC, (const char *)Dtool_PostProcessPass_get_class_type_379_comment},
  {"getClassType", &Dtool_PostProcessPass_get_class_type_379, METH_NOARGS | METH_STATIC, (const char *)Dtool_PostProcessPass_get_class_type_379_comment},
  {"get_quad", &Dtool_PostProcessPass_get_quad_381, METH_NOARGS, (const char *)Dtool_PostProcessPass_get_quad_381_comment},
  {"getQuad", &Dtool_PostProcessPass_get_quad_381, METH_NOARGS, (const char *)Dtool_PostProcessPass_get_quad_381_comment},
  {"get_back_buffer_dimensions", &Dtool_PostProcessPass_get_back_buffer_dimensions_382, METH_NOARGS, (const char *)Dtool_PostProcessPass_get_back_buffer_dimensions_382_comment},
  {"getBackBufferDimensions", &Dtool_PostProcessPass_get_back_buffer_dimensions_382, METH_NOARGS, (const char *)Dtool_PostProcessPass_get_back_buffer_dimensions_382_comment},
  {"get_camera", &Dtool_PostProcessPass_get_camera_383, METH_NOARGS, (const char *)Dtool_PostProcessPass_get_camera_383_comment},
  {"getCamera", &Dtool_PostProcessPass_get_camera_383, METH_NOARGS, (const char *)Dtool_PostProcessPass_get_camera_383_comment},
  {"has_texture_bits", &Dtool_PostProcessPass_has_texture_bits_384, METH_O, (const char *)Dtool_PostProcessPass_has_texture_bits_384_comment},
  {"hasTextureBits", &Dtool_PostProcessPass_has_texture_bits_384, METH_O, (const char *)Dtool_PostProcessPass_has_texture_bits_384_comment},
  {"set_div_size", (PyCFunction) &Dtool_PostProcessPass_set_div_size_385, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PostProcessPass_set_div_size_385_comment},
  {"setDivSize", (PyCFunction) &Dtool_PostProcessPass_set_div_size_385, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PostProcessPass_set_div_size_385_comment},
  {"set_forced_size", (PyCFunction) &Dtool_PostProcessPass_set_forced_size_386, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PostProcessPass_set_forced_size_386_comment},
  {"setForcedSize", (PyCFunction) &Dtool_PostProcessPass_set_forced_size_386, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PostProcessPass_set_forced_size_386_comment},
  {"set_framebuffer_properties", &Dtool_PostProcessPass_set_framebuffer_properties_387, METH_O, (const char *)Dtool_PostProcessPass_set_framebuffer_properties_387_comment},
  {"setFramebufferProperties", &Dtool_PostProcessPass_set_framebuffer_properties_387, METH_O, (const char *)Dtool_PostProcessPass_set_framebuffer_properties_387_comment},
  {"set_output_texture_bits", &Dtool_PostProcessPass_set_output_texture_bits_388, METH_O, (const char *)Dtool_PostProcessPass_set_output_texture_bits_388_comment},
  {"setOutputTextureBits", &Dtool_PostProcessPass_set_output_texture_bits_388, METH_O, (const char *)Dtool_PostProcessPass_set_output_texture_bits_388_comment},
  {"get_corrected_size", &Dtool_PostProcessPass_get_corrected_size_389, METH_O, (const char *)Dtool_PostProcessPass_get_corrected_size_389_comment},
  {"getCorrectedSize", &Dtool_PostProcessPass_get_corrected_size_389, METH_O, (const char *)Dtool_PostProcessPass_get_corrected_size_389_comment},
  {"get_texture", &Dtool_PostProcessPass_get_texture_390, METH_O, (const char *)Dtool_PostProcessPass_get_texture_390_comment},
  {"getTexture", &Dtool_PostProcessPass_get_texture_390, METH_O, (const char *)Dtool_PostProcessPass_get_texture_390_comment},
  {"get_color_texture", &Dtool_PostProcessPass_get_color_texture_391, METH_NOARGS, (const char *)Dtool_PostProcessPass_get_color_texture_391_comment},
  {"getColorTexture", &Dtool_PostProcessPass_get_color_texture_391, METH_NOARGS, (const char *)Dtool_PostProcessPass_get_color_texture_391_comment},
  {"get_depth_texture", &Dtool_PostProcessPass_get_depth_texture_392, METH_NOARGS, (const char *)Dtool_PostProcessPass_get_depth_texture_392_comment},
  {"getDepthTexture", &Dtool_PostProcessPass_get_depth_texture_392, METH_NOARGS, (const char *)Dtool_PostProcessPass_get_depth_texture_392_comment},
  {"setup_buffer", &Dtool_PostProcessPass_setup_buffer_393, METH_NOARGS, (const char *)Dtool_PostProcessPass_setup_buffer_393_comment},
  {"setupBuffer", &Dtool_PostProcessPass_setup_buffer_393, METH_NOARGS, (const char *)Dtool_PostProcessPass_setup_buffer_393_comment},
  {"setup_textures", &Dtool_PostProcessPass_setup_textures_394, METH_NOARGS, (const char *)Dtool_PostProcessPass_setup_textures_394_comment},
  {"setupTextures", &Dtool_PostProcessPass_setup_textures_394, METH_NOARGS, (const char *)Dtool_PostProcessPass_setup_textures_394_comment},
  {"setup_quad", &Dtool_PostProcessPass_setup_quad_395, METH_NOARGS, (const char *)Dtool_PostProcessPass_setup_quad_395_comment},
  {"setupQuad", &Dtool_PostProcessPass_setup_quad_395, METH_NOARGS, (const char *)Dtool_PostProcessPass_setup_quad_395_comment},
  {"setup_camera", &Dtool_PostProcessPass_setup_camera_396, METH_NOARGS, (const char *)Dtool_PostProcessPass_setup_camera_396_comment},
  {"setupCamera", &Dtool_PostProcessPass_setup_camera_396, METH_NOARGS, (const char *)Dtool_PostProcessPass_setup_camera_396_comment},
  {"setup_region", &Dtool_PostProcessPass_setup_region_397, METH_NOARGS, (const char *)Dtool_PostProcessPass_setup_region_397_comment},
  {"setupRegion", &Dtool_PostProcessPass_setup_region_397, METH_NOARGS, (const char *)Dtool_PostProcessPass_setup_region_397_comment},
  {"setup", &Dtool_PostProcessPass_setup_398, METH_NOARGS, (const char *)Dtool_PostProcessPass_setup_398_comment},
  {"update", &Dtool_PostProcessPass_update_399, METH_NOARGS, (const char *)Dtool_PostProcessPass_update_399_comment},
  {"window_event", &Dtool_PostProcessPass_window_event_400, METH_O, (const char *)Dtool_PostProcessPass_window_event_400_comment},
  {"windowEvent", &Dtool_PostProcessPass_window_event_400, METH_O, (const char *)Dtool_PostProcessPass_window_event_400_comment},
  {"shutdown", &Dtool_PostProcessPass_shutdown_401, METH_NOARGS, (const char *)Dtool_PostProcessPass_shutdown_401_comment},
  {"get_default_fbprops", &Dtool_PostProcessPass_get_default_fbprops_402, METH_NOARGS | METH_STATIC, (const char *)Dtool_PostProcessPass_get_default_fbprops_402_comment},
  {"getDefaultFbprops", &Dtool_PostProcessPass_get_default_fbprops_402, METH_NOARGS | METH_STATIC, (const char *)Dtool_PostProcessPass_get_default_fbprops_402_comment},
  {"upcast_to_ReferenceCount", &Dtool_PostProcessPass_upcast_to_ReferenceCount_375, METH_NOARGS, (const char *)Dtool_PostProcessPass_upcast_to_ReferenceCount_375_comment},
  {"upcastToReferenceCount", &Dtool_PostProcessPass_upcast_to_ReferenceCount_375, METH_NOARGS, (const char *)Dtool_PostProcessPass_upcast_to_ReferenceCount_375_comment},
  {"upcast_to_Namable", &Dtool_PostProcessPass_upcast_to_Namable_377, METH_NOARGS, (const char *)Dtool_PostProcessPass_upcast_to_Namable_377_comment},
  {"upcastToNamable", &Dtool_PostProcessPass_upcast_to_Namable_377, METH_NOARGS, (const char *)Dtool_PostProcessPass_upcast_to_Namable_377_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PostProcessPass = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PostProcessPass = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PostProcessPass = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PostProcessPass = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PostProcessPass = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PostProcessPass = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.PostProcessPass",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PostProcessPass,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PostProcessPass,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PostProcessPass,
    &Dtool_SequenceMethods_PostProcessPass,
    &Dtool_MappingMethods_PostProcessPass,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PostProcessPass,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PostProcessPass,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PostProcessPass,
    PyType_GenericAlloc,
    Dtool_new_PostProcessPass,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PostProcessPass,
  Dtool_UpcastInterface_PostProcessPass,
  Dtool_DowncastInterface_PostProcessPass,
  (CoerceFunction)Dtool_ConstCoerce_PostProcessPass,
  (CoerceFunction)Dtool_Coerce_PostProcessPass,
};

static void Dtool_PyModuleClassInit_PostProcessPass(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_PostProcessPass._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_ReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_PostProcessPass._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PostProcessPass._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PostProcessPass) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PostProcessPass)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PostProcessPass);
  }
}

/**
 * Python method tables for PostProcessScenePass (PostProcessScenePass)
 */
static PyMethodDef Dtool_Methods_PostProcessScenePass[] = {
  {"setup_scene_camera", &Dtool_PostProcessScenePass_setup_scene_camera_406, METH_O, (const char *)Dtool_PostProcessScenePass_setup_scene_camera_406_comment},
  {"setupSceneCamera", &Dtool_PostProcessScenePass_setup_scene_camera_406, METH_O, (const char *)Dtool_PostProcessScenePass_setup_scene_camera_406_comment},
  {"set_camera_state", &Dtool_PostProcessScenePass_set_camera_state_407, METH_O, (const char *)Dtool_PostProcessScenePass_set_camera_state_407_comment},
  {"setCameraState", &Dtool_PostProcessScenePass_set_camera_state_407, METH_O, (const char *)Dtool_PostProcessScenePass_set_camera_state_407_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PostProcessScenePass = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PostProcessScenePass = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PostProcessScenePass = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PostProcessScenePass = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PostProcessScenePass = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PostProcessScenePass = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.PostProcessScenePass",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PostProcessScenePass,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PostProcessScenePass,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PostProcessScenePass,
    &Dtool_SequenceMethods_PostProcessScenePass,
    &Dtool_MappingMethods_PostProcessScenePass,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PostProcessScenePass,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PostProcessScenePass,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PostProcessScenePass,
    PyType_GenericAlloc,
    Dtool_new_PostProcessScenePass,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PostProcessScenePass,
  Dtool_UpcastInterface_PostProcessScenePass,
  Dtool_DowncastInterface_PostProcessScenePass,
  (CoerceFunction)Dtool_ConstCoerce_PostProcessScenePass,
  (CoerceFunction)Dtool_Coerce_PostProcessScenePass,
};

static void Dtool_PyModuleClassInit_PostProcessScenePass(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PostProcessPass(nullptr);
    Dtool_PostProcessScenePass._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PostProcessPass);
    Dtool_PostProcessScenePass._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PostProcessScenePass._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PostProcessScenePass) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PostProcessScenePass)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PostProcessScenePass);
  }
}

/**
 * Python method tables for PostProcess (PostProcess)
 */
static PyMethodDef Dtool_Methods_PostProcess[] = {
  {"startup", &Dtool_PostProcess_startup_411, METH_O, (const char *)Dtool_PostProcess_startup_411_comment},
  {"add_camera", &Dtool_PostProcess_add_camera_412, METH_O, (const char *)Dtool_PostProcess_add_camera_412_comment},
  {"addCamera", &Dtool_PostProcess_add_camera_412, METH_O, (const char *)Dtool_PostProcess_add_camera_412_comment},
  {"remove_camera", &Dtool_PostProcess_remove_camera_413, METH_O, (const char *)Dtool_PostProcess_remove_camera_413_comment},
  {"removeCamera", &Dtool_PostProcess_remove_camera_413, METH_O, (const char *)Dtool_PostProcess_remove_camera_413_comment},
  {"add_effect", &Dtool_PostProcess_add_effect_414, METH_O, (const char *)Dtool_PostProcess_add_effect_414_comment},
  {"addEffect", &Dtool_PostProcess_add_effect_414, METH_O, (const char *)Dtool_PostProcess_add_effect_414_comment},
  {"remove_effect", &Dtool_PostProcess_remove_effect_415, METH_O, (const char *)Dtool_PostProcess_remove_effect_415_comment},
  {"removeEffect", &Dtool_PostProcess_remove_effect_415, METH_O, (const char *)Dtool_PostProcess_remove_effect_415_comment},
  {"get_effect", &Dtool_PostProcess_get_effect_416, METH_O, (const char *)Dtool_PostProcess_get_effect_416_comment},
  {"getEffect", &Dtool_PostProcess_get_effect_416, METH_O, (const char *)Dtool_PostProcess_get_effect_416_comment},
  {"get_scene_color_texture", &Dtool_PostProcess_get_scene_color_texture_417, METH_NOARGS, (const char *)Dtool_PostProcess_get_scene_color_texture_417_comment},
  {"getSceneColorTexture", &Dtool_PostProcess_get_scene_color_texture_417, METH_NOARGS, (const char *)Dtool_PostProcess_get_scene_color_texture_417_comment},
  {"get_scene_depth_texture", &Dtool_PostProcess_get_scene_depth_texture_418, METH_NOARGS, (const char *)Dtool_PostProcess_get_scene_depth_texture_418_comment},
  {"getSceneDepthTexture", &Dtool_PostProcess_get_scene_depth_texture_418, METH_NOARGS, (const char *)Dtool_PostProcess_get_scene_depth_texture_418_comment},
  {"get_scene_pass", &Dtool_PostProcess_get_scene_pass_419, METH_NOARGS, (const char *)Dtool_PostProcess_get_scene_pass_419_comment},
  {"getScenePass", &Dtool_PostProcess_get_scene_pass_419, METH_NOARGS, (const char *)Dtool_PostProcess_get_scene_pass_419_comment},
  {"get_output", &Dtool_PostProcess_get_output_420, METH_NOARGS, (const char *)Dtool_PostProcess_get_output_420_comment},
  {"getOutput", &Dtool_PostProcess_get_output_420, METH_NOARGS, (const char *)Dtool_PostProcess_get_output_420_comment},
  {"get_camera", &Dtool_PostProcess_get_camera_421, METH_O, (const char *)Dtool_PostProcess_get_camera_421_comment},
  {"getCamera", &Dtool_PostProcess_get_camera_421, METH_O, (const char *)Dtool_PostProcess_get_camera_421_comment},
  {"next_sort", &Dtool_PostProcess_next_sort_422, METH_NOARGS, (const char *)Dtool_PostProcess_next_sort_422_comment},
  {"nextSort", &Dtool_PostProcess_next_sort_422, METH_NOARGS, (const char *)Dtool_PostProcess_next_sort_422_comment},
  {"get_output_display_region", &Dtool_PostProcess_get_output_display_region_423, METH_NOARGS, (const char *)Dtool_PostProcess_get_output_display_region_423_comment},
  {"getOutputDisplayRegion", &Dtool_PostProcess_get_output_display_region_423, METH_NOARGS, (const char *)Dtool_PostProcess_get_output_display_region_423_comment},
  {"is_fullscreen", &Dtool_PostProcess_is_fullscreen_424, METH_NOARGS, (const char *)Dtool_PostProcess_is_fullscreen_424_comment},
  {"isFullscreen", &Dtool_PostProcess_is_fullscreen_424, METH_NOARGS, (const char *)Dtool_PostProcess_is_fullscreen_424_comment},
  {"set_scene_aux_bits", &Dtool_PostProcess_set_scene_aux_bits_425, METH_O, (const char *)Dtool_PostProcess_set_scene_aux_bits_425_comment},
  {"setSceneAuxBits", &Dtool_PostProcess_set_scene_aux_bits_425, METH_O, (const char *)Dtool_PostProcess_set_scene_aux_bits_425_comment},
  {"set_stacked_clears", (PyCFunction) &Dtool_PostProcess_set_stacked_clears_426, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PostProcess_set_stacked_clears_426_comment},
  {"setStackedClears", (PyCFunction) &Dtool_PostProcess_set_stacked_clears_426, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PostProcess_set_stacked_clears_426_comment},
  {"set_window_clears", &Dtool_PostProcess_set_window_clears_427, METH_O, (const char *)Dtool_PostProcess_set_window_clears_427_comment},
  {"setWindowClears", &Dtool_PostProcess_set_window_clears_427, METH_O, (const char *)Dtool_PostProcess_set_window_clears_427_comment},
  {"set_clears", (PyCFunction) &Dtool_PostProcess_set_clears_428, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PostProcess_set_clears_428_comment},
  {"setClears", (PyCFunction) &Dtool_PostProcess_set_clears_428, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PostProcess_set_clears_428_comment},
  {"shutdown", &Dtool_PostProcess_shutdown_429, METH_NOARGS, (const char *)Dtool_PostProcess_shutdown_429_comment},
  {"update", &Dtool_PostProcess_update_430, METH_NOARGS, (const char *)Dtool_PostProcess_update_430_comment},
  {"window_event", &Dtool_PostProcess_window_event_431, METH_NOARGS, (const char *)Dtool_PostProcess_window_event_431_comment},
  {"windowEvent", &Dtool_PostProcess_window_event_431, METH_NOARGS, (const char *)Dtool_PostProcess_window_event_431_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PostProcess = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PostProcess = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PostProcess = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PostProcess = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PostProcess = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PostProcess = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.PostProcess",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PostProcess,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PostProcess,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PostProcess,
    &Dtool_SequenceMethods_PostProcess,
    &Dtool_MappingMethods_PostProcess,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PostProcess,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PostProcess,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PostProcess,
    PyType_GenericAlloc,
    Dtool_new_PostProcess,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PostProcess,
  Dtool_UpcastInterface_PostProcess,
  Dtool_DowncastInterface_PostProcess,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PostProcess(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_PostProcess._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_PostProcess._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PostProcess._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PostProcess) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PostProcess)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PostProcess);
  }
}

/**
 * Python method tables for HDRPass (HDRPass)
 */
static PyMethodDef Dtool_Methods_HDRPass[] = {
  {"get_class_type", &Dtool_HDRPass_get_class_type_434, METH_NOARGS | METH_STATIC, (const char *)Dtool_HDRPass_get_class_type_434_comment},
  {"getClassType", &Dtool_HDRPass_get_class_type_434, METH_NOARGS | METH_STATIC, (const char *)Dtool_HDRPass_get_class_type_434_comment},
  {"set_exposure_output", &Dtool_HDRPass_set_exposure_output_436, METH_O, (const char *)Dtool_HDRPass_set_exposure_output_436_comment},
  {"setExposureOutput", &Dtool_HDRPass_set_exposure_output_436, METH_O, (const char *)Dtool_HDRPass_set_exposure_output_436_comment},
  {"get_exposure", &Dtool_HDRPass_get_exposure_437, METH_NOARGS, (const char *)Dtool_HDRPass_get_exposure_437_comment},
  {"getExposure", &Dtool_HDRPass_get_exposure_437, METH_NOARGS, (const char *)Dtool_HDRPass_get_exposure_437_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_HDRPass = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_HDRPass = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_HDRPass = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_HDRPass = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_HDRPass = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_HDRPass = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.HDRPass",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_HDRPass,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_HDRPass,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_HDRPass,
    &Dtool_SequenceMethods_HDRPass,
    &Dtool_MappingMethods_HDRPass,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_HDRPass,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_HDRPass,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_HDRPass,
    PyType_GenericAlloc,
    Dtool_new_HDRPass,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HDRPass,
  Dtool_UpcastInterface_HDRPass,
  Dtool_DowncastInterface_HDRPass,
  (CoerceFunction)Dtool_ConstCoerce_HDRPass,
  (CoerceFunction)Dtool_Coerce_HDRPass,
};

static void Dtool_PyModuleClassInit_HDRPass(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PostProcessPass(nullptr);
    Dtool_HDRPass._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PostProcessPass);
    Dtool_HDRPass._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_HDRPass._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_HDRPass) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HDRPass)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HDRPass);
  }
}

/**
 * Python method tables for HDREffect (HDREffect)
 */
static PyMethodDef Dtool_Methods_HDREffect[] = {
  {"get_hdr_pass", &Dtool_HDREffect_get_hdr_pass_441, METH_NOARGS, (const char *)Dtool_HDREffect_get_hdr_pass_441_comment},
  {"getHdrPass", &Dtool_HDREffect_get_hdr_pass_441, METH_NOARGS, (const char *)Dtool_HDREffect_get_hdr_pass_441_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_HDREffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_HDREffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_HDREffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_HDREffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_HDREffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_HDREffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.HDREffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_HDREffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_HDREffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_HDREffect,
    &Dtool_SequenceMethods_HDREffect,
    &Dtool_MappingMethods_HDREffect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_HDREffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_HDREffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_HDREffect,
    PyType_GenericAlloc,
    Dtool_new_HDREffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HDREffect,
  Dtool_UpcastInterface_HDREffect,
  Dtool_DowncastInterface_HDREffect,
  (CoerceFunction)Dtool_ConstCoerce_HDREffect,
  (CoerceFunction)Dtool_Coerce_HDREffect,
};

static void Dtool_PyModuleClassInit_HDREffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PostProcessEffect(nullptr);
    Dtool_HDREffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PostProcessEffect);
    Dtool_HDREffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_HDREffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_HDREffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HDREffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HDREffect);
  }
}

/**
 * Python method tables for BloomEffect (BloomEffect)
 */
static PyMethodDef Dtool_Methods_BloomEffect[] = {
  {"get_class_type", &Dtool_BloomEffect_get_class_type_444, METH_NOARGS | METH_STATIC, (const char *)Dtool_BloomEffect_get_class_type_444_comment},
  {"getClassType", &Dtool_BloomEffect_get_class_type_444, METH_NOARGS | METH_STATIC, (const char *)Dtool_BloomEffect_get_class_type_444_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BloomEffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BloomEffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BloomEffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BloomEffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BloomEffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BloomEffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.BloomEffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BloomEffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BloomEffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BloomEffect,
    &Dtool_SequenceMethods_BloomEffect,
    &Dtool_MappingMethods_BloomEffect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BloomEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BloomEffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BloomEffect,
    PyType_GenericAlloc,
    Dtool_new_BloomEffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BloomEffect,
  Dtool_UpcastInterface_BloomEffect,
  Dtool_DowncastInterface_BloomEffect,
  (CoerceFunction)Dtool_ConstCoerce_BloomEffect,
  (CoerceFunction)Dtool_Coerce_BloomEffect,
};

static void Dtool_PyModuleClassInit_BloomEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PostProcessEffect(nullptr);
    Dtool_BloomEffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PostProcessEffect);
    Dtool_BloomEffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BloomEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BloomEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BloomEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BloomEffect);
  }
}

/**
 * Python method tables for LightingOriginEffect (LightingOriginEffect)
 */
static PyMethodDef Dtool_Methods_LightingOriginEffect[] = {
  {"get_class_type", &Dtool_LightingOriginEffect_get_class_type_448, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightingOriginEffect_get_class_type_448_comment},
  {"getClassType", &Dtool_LightingOriginEffect_get_class_type_448, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightingOriginEffect_get_class_type_448_comment},
  {"make", &Dtool_LightingOriginEffect_make_449, METH_O | METH_STATIC, (const char *)Dtool_LightingOriginEffect_make_449_comment},
  {"get_lighting_origin", &Dtool_LightingOriginEffect_get_lighting_origin_450, METH_NOARGS, (const char *)Dtool_LightingOriginEffect_get_lighting_origin_450_comment},
  {"getLightingOrigin", &Dtool_LightingOriginEffect_get_lighting_origin_450, METH_NOARGS, (const char *)Dtool_LightingOriginEffect_get_lighting_origin_450_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LightingOriginEffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LightingOriginEffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LightingOriginEffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LightingOriginEffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LightingOriginEffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LightingOriginEffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.LightingOriginEffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LightingOriginEffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LightingOriginEffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LightingOriginEffect,
    &Dtool_SequenceMethods_LightingOriginEffect,
    &Dtool_MappingMethods_LightingOriginEffect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LightingOriginEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LightingOriginEffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LightingOriginEffect,
    PyType_GenericAlloc,
    Dtool_new_LightingOriginEffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightingOriginEffect,
  Dtool_UpcastInterface_LightingOriginEffect,
  Dtool_DowncastInterface_LightingOriginEffect,
  (CoerceFunction)Dtool_ConstCoerce_LightingOriginEffect,
  nullptr,
};

static void Dtool_PyModuleClassInit_LightingOriginEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_RenderEffect != nullptr);
    assert(Dtool_Ptr_RenderEffect->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_RenderEffect->_Dtool_ModuleClassInit(nullptr);
    Dtool_LightingOriginEffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_RenderEffect);
    Dtool_LightingOriginEffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LightingOriginEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightingOriginEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightingOriginEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightingOriginEffect);
  }
}

/**
 * Python method tables for FXAA_Effect (FXAA_Effect)
 */
static PyMethodDef Dtool_Methods_FXAA_Effect[] = {
  {"get_class_type", &Dtool_FXAA_Effect_get_class_type_453, METH_NOARGS | METH_STATIC, (const char *)Dtool_FXAA_Effect_get_class_type_453_comment},
  {"getClassType", &Dtool_FXAA_Effect_get_class_type_453, METH_NOARGS | METH_STATIC, (const char *)Dtool_FXAA_Effect_get_class_type_453_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_FXAA_Effect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FXAA_Effect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_FXAA_Effect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_FXAA_Effect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_FXAA_Effect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_FXAA_Effect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.FXAA_Effect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_FXAA_Effect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_FXAA_Effect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_FXAA_Effect,
    &Dtool_SequenceMethods_FXAA_Effect,
    &Dtool_MappingMethods_FXAA_Effect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_FXAA_Effect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_FXAA_Effect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_FXAA_Effect,
    PyType_GenericAlloc,
    Dtool_new_FXAA_Effect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FXAA_Effect,
  Dtool_UpcastInterface_FXAA_Effect,
  Dtool_DowncastInterface_FXAA_Effect,
  (CoerceFunction)Dtool_ConstCoerce_FXAA_Effect,
  (CoerceFunction)Dtool_Coerce_FXAA_Effect,
};

static void Dtool_PyModuleClassInit_FXAA_Effect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PostProcessEffect(nullptr);
    Dtool_FXAA_Effect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PostProcessEffect);
    Dtool_FXAA_Effect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_FXAA_Effect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FXAA_Effect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FXAA_Effect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FXAA_Effect);
  }
}

/**
 * Python method tables for BloomAttrib (BloomAttrib)
 */
static PyMethodDef Dtool_Methods_BloomAttrib[] = {
  {"get_class_slot", &Dtool_BloomAttrib_get_class_slot_457, METH_NOARGS | METH_STATIC, (const char *)Dtool_BloomAttrib_get_class_slot_457_comment},
  {"getClassSlot", &Dtool_BloomAttrib_get_class_slot_457, METH_NOARGS | METH_STATIC, (const char *)Dtool_BloomAttrib_get_class_slot_457_comment},
  {"get_class_type", &Dtool_BloomAttrib_get_class_type_459, METH_NOARGS | METH_STATIC, (const char *)Dtool_BloomAttrib_get_class_type_459_comment},
  {"getClassType", &Dtool_BloomAttrib_get_class_type_459, METH_NOARGS | METH_STATIC, (const char *)Dtool_BloomAttrib_get_class_type_459_comment},
  {"make", (PyCFunction) &Dtool_BloomAttrib_make_460, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BloomAttrib_make_460_comment},
  {"is_bloom_enabled", &Dtool_BloomAttrib_is_bloom_enabled_461, METH_NOARGS, (const char *)Dtool_BloomAttrib_is_bloom_enabled_461_comment},
  {"isBloomEnabled", &Dtool_BloomAttrib_is_bloom_enabled_461, METH_NOARGS, (const char *)Dtool_BloomAttrib_is_bloom_enabled_461_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BloomAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BloomAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BloomAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BloomAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BloomAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BloomAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.BloomAttrib",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BloomAttrib,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BloomAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BloomAttrib,
    &Dtool_SequenceMethods_BloomAttrib,
    &Dtool_MappingMethods_BloomAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BloomAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BloomAttrib,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BloomAttrib,
    PyType_GenericAlloc,
    Dtool_new_BloomAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BloomAttrib,
  Dtool_UpcastInterface_BloomAttrib,
  Dtool_DowncastInterface_BloomAttrib,
  (CoerceFunction)Dtool_ConstCoerce_BloomAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_BloomAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_RenderAttrib != nullptr);
    assert(Dtool_Ptr_RenderAttrib->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_RenderAttrib->_Dtool_ModuleClassInit(nullptr);
    Dtool_BloomAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_RenderAttrib);
    Dtool_BloomAttrib._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BloomAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_BloomAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_BloomAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_BloomAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BloomAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BloomAttrib);
  }
}

/**
 * Python method tables for PhysicsCharacterController (PhysicsCharacterController)
 */
static PyMethodDef Dtool_Methods_PhysicsCharacterController[] = {
  {"set_max_slope", (PyCFunction) &Dtool_PhysicsCharacterController_set_max_slope_466, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsCharacterController_set_max_slope_466_comment},
  {"setMaxSlope", (PyCFunction) &Dtool_PhysicsCharacterController_set_max_slope_466, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsCharacterController_set_max_slope_466_comment},
  {"set_collide_mask", &Dtool_PhysicsCharacterController_set_collide_mask_467, METH_O, (const char *)Dtool_PhysicsCharacterController_set_collide_mask_467_comment},
  {"setCollideMask", &Dtool_PhysicsCharacterController_set_collide_mask_467, METH_O, (const char *)Dtool_PhysicsCharacterController_set_collide_mask_467_comment},
  {"set_event_enter_callback", &Dtool_PhysicsCharacterController_set_event_enter_callback_468, METH_O, (const char *)Dtool_PhysicsCharacterController_set_event_enter_callback_468_comment},
  {"setEventEnterCallback", &Dtool_PhysicsCharacterController_set_event_enter_callback_468, METH_O, (const char *)Dtool_PhysicsCharacterController_set_event_enter_callback_468_comment},
  {"set_event_exit_callback", &Dtool_PhysicsCharacterController_set_event_exit_callback_469, METH_O, (const char *)Dtool_PhysicsCharacterController_set_event_exit_callback_469_comment},
  {"setEventExitCallback", &Dtool_PhysicsCharacterController_set_event_exit_callback_469, METH_O, (const char *)Dtool_PhysicsCharacterController_set_event_exit_callback_469_comment},
  {"set_active_jump_limiter", &Dtool_PhysicsCharacterController_set_active_jump_limiter_470, METH_O, (const char *)Dtool_PhysicsCharacterController_set_active_jump_limiter_470_comment},
  {"setActiveJumpLimiter", &Dtool_PhysicsCharacterController_set_active_jump_limiter_470, METH_O, (const char *)Dtool_PhysicsCharacterController_set_active_jump_limiter_470_comment},
  {"set_default_material", &Dtool_PhysicsCharacterController_set_default_material_471, METH_O, (const char *)Dtool_PhysicsCharacterController_set_default_material_471_comment},
  {"setDefaultMaterial", &Dtool_PhysicsCharacterController_set_default_material_471, METH_O, (const char *)Dtool_PhysicsCharacterController_set_default_material_471_comment},
  {"set_touching_water", &Dtool_PhysicsCharacterController_set_touching_water_472, METH_O, (const char *)Dtool_PhysicsCharacterController_set_touching_water_472_comment},
  {"setTouchingWater", &Dtool_PhysicsCharacterController_set_touching_water_472, METH_O, (const char *)Dtool_PhysicsCharacterController_set_touching_water_472_comment},
  {"get_current_material", &Dtool_PhysicsCharacterController_get_current_material_473, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_get_current_material_473_comment},
  {"getCurrentMaterial", &Dtool_PhysicsCharacterController_get_current_material_473, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_get_current_material_473_comment},
  {"get_walk_capsule", &Dtool_PhysicsCharacterController_get_walk_capsule_474, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_get_walk_capsule_474_comment},
  {"getWalkCapsule", &Dtool_PhysicsCharacterController_get_walk_capsule_474, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_get_walk_capsule_474_comment},
  {"get_crouch_capsule", &Dtool_PhysicsCharacterController_get_crouch_capsule_475, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_get_crouch_capsule_475_comment},
  {"getCrouchCapsule", &Dtool_PhysicsCharacterController_get_crouch_capsule_475, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_get_crouch_capsule_475_comment},
  {"get_event_sphere", &Dtool_PhysicsCharacterController_get_event_sphere_476, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_get_event_sphere_476_comment},
  {"getEventSphere", &Dtool_PhysicsCharacterController_get_event_sphere_476, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_get_event_sphere_476_comment},
  {"get_capsule", &Dtool_PhysicsCharacterController_get_capsule_477, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_get_capsule_477_comment},
  {"getCapsule", &Dtool_PhysicsCharacterController_get_capsule_477, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_get_capsule_477_comment},
  {"get_movement_parent", &Dtool_PhysicsCharacterController_get_movement_parent_478, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_get_movement_parent_478_comment},
  {"getMovementParent", &Dtool_PhysicsCharacterController_get_movement_parent_478, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_get_movement_parent_478_comment},
  {"set_gravity", &Dtool_PhysicsCharacterController_set_gravity_479, METH_O, (const char *)Dtool_PhysicsCharacterController_set_gravity_479_comment},
  {"setGravity", &Dtool_PhysicsCharacterController_set_gravity_479, METH_O, (const char *)Dtool_PhysicsCharacterController_set_gravity_479_comment},
  {"set_movement_state", &Dtool_PhysicsCharacterController_set_movement_state_480, METH_O, (const char *)Dtool_PhysicsCharacterController_set_movement_state_480_comment},
  {"setMovementState", &Dtool_PhysicsCharacterController_set_movement_state_480, METH_O, (const char *)Dtool_PhysicsCharacterController_set_movement_state_480_comment},
  {"get_movement_state", &Dtool_PhysicsCharacterController_get_movement_state_481, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_get_movement_state_481_comment},
  {"getMovementState", &Dtool_PhysicsCharacterController_get_movement_state_481, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_get_movement_state_481_comment},
  {"set_stand_up_callback", &Dtool_PhysicsCharacterController_set_stand_up_callback_482, METH_O, (const char *)Dtool_PhysicsCharacterController_set_stand_up_callback_482_comment},
  {"setStandUpCallback", &Dtool_PhysicsCharacterController_set_stand_up_callback_482, METH_O, (const char *)Dtool_PhysicsCharacterController_set_stand_up_callback_482_comment},
  {"set_fall_callback", &Dtool_PhysicsCharacterController_set_fall_callback_483, METH_O, (const char *)Dtool_PhysicsCharacterController_set_fall_callback_483_comment},
  {"setFallCallback", &Dtool_PhysicsCharacterController_set_fall_callback_483, METH_O, (const char *)Dtool_PhysicsCharacterController_set_fall_callback_483_comment},
  {"start_crouch", &Dtool_PhysicsCharacterController_start_crouch_484, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_start_crouch_484_comment},
  {"startCrouch", &Dtool_PhysicsCharacterController_start_crouch_484, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_start_crouch_484_comment},
  {"stop_crouch", &Dtool_PhysicsCharacterController_stop_crouch_485, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_stop_crouch_485_comment},
  {"stopCrouch", &Dtool_PhysicsCharacterController_stop_crouch_485, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_stop_crouch_485_comment},
  {"is_on_ground", &Dtool_PhysicsCharacterController_is_on_ground_486, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_is_on_ground_486_comment},
  {"isOnGround", &Dtool_PhysicsCharacterController_is_on_ground_486, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_is_on_ground_486_comment},
  {"start_jump", (PyCFunction) &Dtool_PhysicsCharacterController_start_jump_487, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsCharacterController_start_jump_487_comment},
  {"startJump", (PyCFunction) &Dtool_PhysicsCharacterController_start_jump_487, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsCharacterController_start_jump_487_comment},
  {"set_angular_movement", &Dtool_PhysicsCharacterController_set_angular_movement_488, METH_O, (const char *)Dtool_PhysicsCharacterController_set_angular_movement_488_comment},
  {"setAngularMovement", &Dtool_PhysicsCharacterController_set_angular_movement_488, METH_O, (const char *)Dtool_PhysicsCharacterController_set_angular_movement_488_comment},
  {"set_linear_movement", &Dtool_PhysicsCharacterController_set_linear_movement_489, METH_O, (const char *)Dtool_PhysicsCharacterController_set_linear_movement_489_comment},
  {"setLinearMovement", &Dtool_PhysicsCharacterController_set_linear_movement_489, METH_O, (const char *)Dtool_PhysicsCharacterController_set_linear_movement_489_comment},
  {"place_on_ground", &Dtool_PhysicsCharacterController_place_on_ground_490, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_place_on_ground_490_comment},
  {"placeOnGround", &Dtool_PhysicsCharacterController_place_on_ground_490, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_place_on_ground_490_comment},
  {"update", &Dtool_PhysicsCharacterController_update_491, METH_O, (const char *)Dtool_PhysicsCharacterController_update_491_comment},
  {"remove_capsules", &Dtool_PhysicsCharacterController_remove_capsules_492, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_remove_capsules_492_comment},
  {"removeCapsules", &Dtool_PhysicsCharacterController_remove_capsules_492, METH_NOARGS, (const char *)Dtool_PhysicsCharacterController_remove_capsules_492_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PhysicsCharacterController = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PhysicsCharacterController = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PhysicsCharacterController = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PhysicsCharacterController = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PhysicsCharacterController = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PhysicsCharacterController = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.PhysicsCharacterController",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PhysicsCharacterController,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PhysicsCharacterController,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PhysicsCharacterController,
    &Dtool_SequenceMethods_PhysicsCharacterController,
    &Dtool_MappingMethods_PhysicsCharacterController,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PhysicsCharacterController,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PhysicsCharacterController,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PhysicsCharacterController,
    PyType_GenericAlloc,
    Dtool_new_PhysicsCharacterController,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PhysicsCharacterController,
  Dtool_UpcastInterface_PhysicsCharacterController,
  Dtool_DowncastInterface_PhysicsCharacterController,
  (CoerceFunction)Dtool_ConstCoerce_PhysicsCharacterController,
  (CoerceFunction)Dtool_Coerce_PhysicsCharacterController,
};

static void Dtool_PyModuleClassInit_PhysicsCharacterController(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_PhysicsCharacterController._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_PhysicsCharacterController._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PhysicsCharacterController._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PhysicsCharacterController) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PhysicsCharacterController)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PhysicsCharacterController);
  }
}

/**
 * Python method tables for Py_BSPLoader (Py_BSPLoader)
 */
static PyMethodDef Dtool_Methods_Py_BSPLoader[] = {
  {"find_all_entities", &Dtool_Py_BSPLoader_find_all_entities_495, METH_O, (const char *)Dtool_Py_BSPLoader_find_all_entities_495_comment},
  {"findAllEntities", &Dtool_Py_BSPLoader_find_all_entities_495, METH_O, (const char *)Dtool_Py_BSPLoader_find_all_entities_495_comment},
  {"get_num_entities", &Dtool_Py_BSPLoader_get_num_entities_496, METH_NOARGS, (const char *)Dtool_Py_BSPLoader_get_num_entities_496_comment},
  {"getNumEntities", &Dtool_Py_BSPLoader_get_num_entities_496, METH_NOARGS, (const char *)Dtool_Py_BSPLoader_get_num_entities_496_comment},
  {"get_entity", &Dtool_Py_BSPLoader_get_entity_497, METH_O, (const char *)Dtool_Py_BSPLoader_get_entity_497_comment},
  {"getEntity", &Dtool_Py_BSPLoader_get_entity_497, METH_O, (const char *)Dtool_Py_BSPLoader_get_entity_497_comment},
  {"get_c_entity", &Dtool_Py_BSPLoader_get_c_entity_498, METH_O, (const char *)Dtool_Py_BSPLoader_get_c_entity_498_comment},
  {"getCEntity", &Dtool_Py_BSPLoader_get_c_entity_498, METH_O, (const char *)Dtool_Py_BSPLoader_get_c_entity_498_comment},
  {"get_entity_keyvalues", (PyCFunction) &Dtool_Py_BSPLoader_get_entity_keyvalues_499, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Py_BSPLoader_get_entity_keyvalues_499_comment},
  {"getEntityKeyvalues", (PyCFunction) &Dtool_Py_BSPLoader_get_entity_keyvalues_499, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Py_BSPLoader_get_entity_keyvalues_499_comment},
  {"link_cent_to_pyent", (PyCFunction) &Dtool_Py_BSPLoader_link_cent_to_pyent_500, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Py_BSPLoader_link_cent_to_pyent_500_comment},
  {"linkCentToPyent", (PyCFunction) &Dtool_Py_BSPLoader_link_cent_to_pyent_500, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Py_BSPLoader_link_cent_to_pyent_500_comment},
  {"get_py_entity_by_target_name", &Dtool_Py_BSPLoader_get_py_entity_by_target_name_501, METH_O, (const char *)Dtool_Py_BSPLoader_get_py_entity_by_target_name_501_comment},
  {"getPyEntityByTargetName", &Dtool_Py_BSPLoader_get_py_entity_by_target_name_501, METH_O, (const char *)Dtool_Py_BSPLoader_get_py_entity_by_target_name_501_comment},
  {"spawn_entities", &Dtool_Py_BSPLoader_spawn_entities_502, METH_NOARGS, (const char *)Dtool_Py_BSPLoader_spawn_entities_502_comment},
  {"spawnEntities", &Dtool_Py_BSPLoader_spawn_entities_502, METH_NOARGS, (const char *)Dtool_Py_BSPLoader_spawn_entities_502_comment},
  {"remove_py_entity", &Dtool_Py_BSPLoader_remove_py_entity_503, METH_O, (const char *)Dtool_Py_BSPLoader_remove_py_entity_503_comment},
  {"removePyEntity", &Dtool_Py_BSPLoader_remove_py_entity_503, METH_O, (const char *)Dtool_Py_BSPLoader_remove_py_entity_503_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Py_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Py_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Py_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Py_BSPLoader = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Py_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Py_BSPLoader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.Py_BSPLoader",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Py_BSPLoader,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Py_BSPLoader,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Py_BSPLoader,
    &Dtool_SequenceMethods_Py_BSPLoader,
    &Dtool_MappingMethods_Py_BSPLoader,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Py_BSPLoader,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Py_BSPLoader,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Py_BSPLoader,
    PyType_GenericAlloc,
    Dtool_new_Py_BSPLoader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Py_BSPLoader,
  Dtool_UpcastInterface_Py_BSPLoader,
  Dtool_DowncastInterface_Py_BSPLoader,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Py_BSPLoader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BSPLoader(nullptr);
    Dtool_Py_BSPLoader._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BSPLoader);
    Dtool_Py_BSPLoader._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Py_BSPLoader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Py_BSPLoader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Py_BSPLoader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Py_BSPLoader);
  }
}

/**
 * Python method tables for Py_CL_BSPLoader (Py_CL_BSPLoader)
 */
static PyMethodDef Dtool_Methods_Py_CL_BSPLoader[] = {
  {"link_entity_to_class", (PyCFunction) &Dtool_Py_CL_BSPLoader_link_entity_to_class_507, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Py_CL_BSPLoader_link_entity_to_class_507_comment},
  {"linkEntityToClass", (PyCFunction) &Dtool_Py_CL_BSPLoader_link_entity_to_class_507, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Py_CL_BSPLoader_link_entity_to_class_507_comment},
  {"make_pyent", (PyCFunction) &Dtool_Py_CL_BSPLoader_make_pyent_508, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Py_CL_BSPLoader_make_pyent_508_comment},
  {"makePyent", (PyCFunction) &Dtool_Py_CL_BSPLoader_make_pyent_508, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Py_CL_BSPLoader_make_pyent_508_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Py_CL_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Py_CL_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Py_CL_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Py_CL_BSPLoader = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Py_CL_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Py_CL_BSPLoader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.Py_CL_BSPLoader",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Py_CL_BSPLoader,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Py_CL_BSPLoader,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Py_CL_BSPLoader,
    &Dtool_SequenceMethods_Py_CL_BSPLoader,
    &Dtool_MappingMethods_Py_CL_BSPLoader,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Py_CL_BSPLoader,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Py_CL_BSPLoader,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Py_CL_BSPLoader,
    PyType_GenericAlloc,
    Dtool_new_Py_CL_BSPLoader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Py_CL_BSPLoader,
  Dtool_UpcastInterface_Py_CL_BSPLoader,
  Dtool_DowncastInterface_Py_CL_BSPLoader,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Py_CL_BSPLoader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Py_BSPLoader(nullptr);
    Dtool_Py_CL_BSPLoader._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Py_BSPLoader);
    Dtool_Py_CL_BSPLoader._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Py_CL_BSPLoader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Py_CL_BSPLoader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Py_CL_BSPLoader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Py_CL_BSPLoader);
  }
}

/**
 * Python method tables for Py_AI_BSPLoader (Py_AI_BSPLoader)
 */
static PyMethodDef Dtool_Methods_Py_AI_BSPLoader[] = {
  {"add_dynamic_entity", &Dtool_Py_AI_BSPLoader_add_dynamic_entity_512, METH_O, (const char *)Dtool_Py_AI_BSPLoader_add_dynamic_entity_512_comment},
  {"addDynamicEntity", &Dtool_Py_AI_BSPLoader_add_dynamic_entity_512, METH_O, (const char *)Dtool_Py_AI_BSPLoader_add_dynamic_entity_512_comment},
  {"remove_dynamic_entity", &Dtool_Py_AI_BSPLoader_remove_dynamic_entity_513, METH_O, (const char *)Dtool_Py_AI_BSPLoader_remove_dynamic_entity_513_comment},
  {"removeDynamicEntity", &Dtool_Py_AI_BSPLoader_remove_dynamic_entity_513, METH_O, (const char *)Dtool_Py_AI_BSPLoader_remove_dynamic_entity_513_comment},
  {"mark_entity_preserved", (PyCFunction) &Dtool_Py_AI_BSPLoader_mark_entity_preserved_514, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Py_AI_BSPLoader_mark_entity_preserved_514_comment},
  {"markEntityPreserved", (PyCFunction) &Dtool_Py_AI_BSPLoader_mark_entity_preserved_514, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Py_AI_BSPLoader_mark_entity_preserved_514_comment},
  {"set_server_entity_dispatcher", &Dtool_Py_AI_BSPLoader_set_server_entity_dispatcher_515, METH_O, (const char *)Dtool_Py_AI_BSPLoader_set_server_entity_dispatcher_515_comment},
  {"setServerEntityDispatcher", &Dtool_Py_AI_BSPLoader_set_server_entity_dispatcher_515, METH_O, (const char *)Dtool_Py_AI_BSPLoader_set_server_entity_dispatcher_515_comment},
  {"link_server_entity_to_class", (PyCFunction) &Dtool_Py_AI_BSPLoader_link_server_entity_to_class_516, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Py_AI_BSPLoader_link_server_entity_to_class_516_comment},
  {"linkServerEntityToClass", (PyCFunction) &Dtool_Py_AI_BSPLoader_link_server_entity_to_class_516, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Py_AI_BSPLoader_link_server_entity_to_class_516_comment},
  {"set_transition_landmark", (PyCFunction) &Dtool_Py_AI_BSPLoader_set_transition_landmark_517, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Py_AI_BSPLoader_set_transition_landmark_517_comment},
  {"setTransitionLandmark", (PyCFunction) &Dtool_Py_AI_BSPLoader_set_transition_landmark_517, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Py_AI_BSPLoader_set_transition_landmark_517_comment},
  {"clear_transition_landmark", &Dtool_Py_AI_BSPLoader_clear_transition_landmark_518, METH_NOARGS, (const char *)Dtool_Py_AI_BSPLoader_clear_transition_landmark_518_comment},
  {"clearTransitionLandmark", &Dtool_Py_AI_BSPLoader_clear_transition_landmark_518, METH_NOARGS, (const char *)Dtool_Py_AI_BSPLoader_clear_transition_landmark_518_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Py_AI_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Py_AI_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Py_AI_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Py_AI_BSPLoader = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Py_AI_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Py_AI_BSPLoader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.Py_AI_BSPLoader",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Py_AI_BSPLoader,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Py_AI_BSPLoader,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Py_AI_BSPLoader,
    &Dtool_SequenceMethods_Py_AI_BSPLoader,
    &Dtool_MappingMethods_Py_AI_BSPLoader,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Py_AI_BSPLoader,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Py_AI_BSPLoader,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Py_AI_BSPLoader,
    PyType_GenericAlloc,
    Dtool_new_Py_AI_BSPLoader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Py_AI_BSPLoader,
  Dtool_UpcastInterface_Py_AI_BSPLoader,
  Dtool_DowncastInterface_Py_AI_BSPLoader,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Py_AI_BSPLoader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Py_BSPLoader(nullptr);
    Dtool_Py_AI_BSPLoader._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Py_BSPLoader);
    Dtool_Py_AI_BSPLoader._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Py_AI_BSPLoader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Py_AI_BSPLoader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Py_AI_BSPLoader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Py_AI_BSPLoader);
  }
}

/**
 * Python method tables for CInterpolationContext (CInterpolationContext)
 */
static PyMethodDef Dtool_Methods_CInterpolationContext[] = {
  {"EnableExtrapolation", &Dtool_CInterpolationContext_EnableExtrapolation_524, METH_O | METH_STATIC, (const char *)Dtool_CInterpolationContext_EnableExtrapolation_524_comment},
  {"IsThereAContext", &Dtool_CInterpolationContext_IsThereAContext_525, METH_NOARGS | METH_STATIC, (const char *)Dtool_CInterpolationContext_IsThereAContext_525_comment},
  {"IsExtrapolationAllowed", &Dtool_CInterpolationContext_IsExtrapolationAllowed_526, METH_NOARGS | METH_STATIC, (const char *)Dtool_CInterpolationContext_IsExtrapolationAllowed_526_comment},
  {"SetLastTimeStamp", &Dtool_CInterpolationContext_SetLastTimeStamp_527, METH_O | METH_STATIC, (const char *)Dtool_CInterpolationContext_SetLastTimeStamp_527_comment},
  {"GetLastTimeStamp", &Dtool_CInterpolationContext_GetLastTimeStamp_528, METH_NOARGS | METH_STATIC, (const char *)Dtool_CInterpolationContext_GetLastTimeStamp_528_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CInterpolationContext = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_CInterpolationContext = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CInterpolationContext",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CInterpolationContext,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CInterpolationContext,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// Before calling Interpolate(), you can use this use this to setup the context\n"
    "// if you want to enable extrapolation.",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CInterpolationContext,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CInterpolationContext,
    PyType_GenericAlloc,
    Dtool_new_CInterpolationContext,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CInterpolationContext,
  Dtool_UpcastInterface_CInterpolationContext,
  Dtool_DowncastInterface_CInterpolationContext,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CInterpolationContext(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CInterpolationContext._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CInterpolationContext._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CInterpolationContext) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CInterpolationContext)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CInterpolationContext);
  }
}

/**
 * Python method tables for IInterpolatedVar (IInterpolatedVar)
 */
static PyMethodDef Dtool_Methods_IInterpolatedVar[] = {
  {"SetInterpolationAmount", &Dtool_IInterpolatedVar_SetInterpolationAmount_531, METH_O, (const char *)Dtool_IInterpolatedVar_SetInterpolationAmount_531_comment},
  {"NoteLastNetworkedValue", &Dtool_IInterpolatedVar_NoteLastNetworkedValue_532, METH_NOARGS, (const char *)Dtool_IInterpolatedVar_NoteLastNetworkedValue_532_comment},
  {"NoteChanged", (PyCFunction) &Dtool_IInterpolatedVar_NoteChanged_533, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_IInterpolatedVar_NoteChanged_533_comment},
  {"Reset", &Dtool_IInterpolatedVar_Reset_534, METH_NOARGS, (const char *)Dtool_IInterpolatedVar_Reset_534_comment},
  {"Interpolate", &Dtool_IInterpolatedVar_Interpolate_535, METH_O, (const char *)Dtool_IInterpolatedVar_Interpolate_535_comment},
  {"GetType", &Dtool_IInterpolatedVar_GetType_536, METH_NOARGS, (const char *)Dtool_IInterpolatedVar_GetType_536_comment},
  {"RestoreToLastNetworked", &Dtool_IInterpolatedVar_RestoreToLastNetworked_537, METH_NOARGS, (const char *)Dtool_IInterpolatedVar_RestoreToLastNetworked_537_comment},
  {"Copy", &Dtool_IInterpolatedVar_Copy_538, METH_O, (const char *)Dtool_IInterpolatedVar_Copy_538_comment},
  {"GetDebugName", &Dtool_IInterpolatedVar_GetDebugName_539, METH_NOARGS, (const char *)Dtool_IInterpolatedVar_GetDebugName_539_comment},
  {"SetDebugName", &Dtool_IInterpolatedVar_SetDebugName_540, METH_O, (const char *)Dtool_IInterpolatedVar_SetDebugName_540_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_IInterpolatedVar = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_IInterpolatedVar = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.IInterpolatedVar",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_IInterpolatedVar,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_IInterpolatedVar,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_IInterpolatedVar,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_IInterpolatedVar,
    PyType_GenericAlloc,
    Dtool_new_IInterpolatedVar,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_IInterpolatedVar,
  Dtool_UpcastInterface_IInterpolatedVar,
  Dtool_DowncastInterface_IInterpolatedVar,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_IInterpolatedVar(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_IInterpolatedVar._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_IInterpolatedVar._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_IInterpolatedVar) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(IInterpolatedVar)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_IInterpolatedVar);
  }
}

/**
 * Python method tables for CInterpolatedVar_LVector2f (CInterpolatedVar_LVector2f)
 */
static PyMethodDef Dtool_Methods_CInterpolatedVar_LVector2f[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CInterpolatedVar_LVector2f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CInterpolatedVar_LVector2f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CInterpolatedVar_LVector2f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CInterpolatedVar_LVector2f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CInterpolatedVar_LVector2f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CInterpolatedVar_LVector2f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CInterpolatedVar_LVector2f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CInterpolatedVar_LVector2f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CInterpolatedVar_LVector2f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CInterpolatedVar_LVector2f,
    &Dtool_SequenceMethods_CInterpolatedVar_LVector2f,
    &Dtool_MappingMethods_CInterpolatedVar_LVector2f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CInterpolatedVar_LVector2f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CInterpolatedVar_LVector2f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CInterpolatedVar_LVector2f,
    PyType_GenericAlloc,
    Dtool_new_CInterpolatedVar_LVector2f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CInterpolatedVar_LVector2f,
  Dtool_UpcastInterface_CInterpolatedVar_LVector2f,
  Dtool_DowncastInterface_CInterpolatedVar_LVector2f,
  nullptr,
  (CoerceFunction)Dtool_Coerce_CInterpolatedVar_LVector2f,
};

static void Dtool_PyModuleClassInit_CInterpolatedVar_LVector2f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector2f_false(nullptr);
    Dtool_CInterpolatedVar_LVector2f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterpolatedVarArrayBase_LVector2f_false);
    Dtool_CInterpolatedVar_LVector2f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CInterpolatedVar_LVector2f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CInterpolatedVar_LVector2f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CInterpolatedVar_LVector2f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CInterpolatedVar_LVector2f);
  }
}

/**
 * Python method tables for CInterpolatedVarArrayBase_LVector2f_false (CInterpolatedVarArrayBase_LVector2f_false)
 */
static PyMethodDef Dtool_Methods_CInterpolatedVarArrayBase_LVector2f_false[] = {
  {"Setup", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector2f_false_Setup_544, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_Setup_544_comment},
  {"NoteChanged", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector2f_false_NoteChanged_545, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_NoteChanged_545_comment},
  {"Interpolate", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector2f_false_Interpolate_546, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_Interpolate_546_comment},
  {"DebugInterpolate", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector2f_false_DebugInterpolate_547, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_DebugInterpolate_547_comment},
  {"GetDerivative", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetDerivative_548, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetDerivative_548_comment},
  {"GetDerivative_SmoothVelocity", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetDerivative_SmoothVelocity_549, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetDerivative_SmoothVelocity_549_comment},
  {"GetDerivativeSmoothVelocity", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetDerivative_SmoothVelocity_549, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetDerivative_SmoothVelocity_549_comment},
  {"ClearHistory", &Dtool_CInterpolatedVarArrayBase_LVector2f_false_ClearHistory_550, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_ClearHistory_550_comment},
  {"AddToHead", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector2f_false_AddToHead_551, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_AddToHead_551_comment},
  {"GetPrev", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetPrev_552, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetPrev_552_comment},
  {"GetCurrent", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetCurrent_553, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetCurrent_553_comment},
  {"GetInterval", &Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetInterval_554, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetInterval_554_comment},
  {"IsValidIndex", &Dtool_CInterpolatedVarArrayBase_LVector2f_false_IsValidIndex_555, METH_O, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_IsValidIndex_555_comment},
  {"GetHead", &Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetHead_557, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetHead_557_comment},
  {"GetNext", &Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetNext_558, METH_O, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetNext_558_comment},
  {"SetHistoryValuesForItem", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetHistoryValuesForItem_559, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetHistoryValuesForItem_559_comment},
  {"SetLooping", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetLooping_560, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetLooping_560_comment},
  {"SetMaxCount", &Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetMaxCount_561, METH_O, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_SetMaxCount_561_comment},
  {"GetMaxCount", &Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetMaxCount_562, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetMaxCount_562_comment},
  {"GetOldestEntry", &Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetOldestEntry_563, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector2f_false_GetOldestEntry_563_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CInterpolatedVarArrayBase_LVector2f_false = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CInterpolatedVarArrayBase_LVector2f_false = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CInterpolatedVarArrayBase_LVector2f_false = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CInterpolatedVarArrayBase_LVector2f_false = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CInterpolatedVarArrayBase_LVector2f_false = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CInterpolatedVarArrayBase_LVector2f_false = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CInterpolatedVarArrayBase_LVector2f_false",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CInterpolatedVarArrayBase_LVector2f_false,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CInterpolatedVarArrayBase_LVector2f_false,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CInterpolatedVarArrayBase_LVector2f_false,
    &Dtool_SequenceMethods_CInterpolatedVarArrayBase_LVector2f_false,
    &Dtool_MappingMethods_CInterpolatedVarArrayBase_LVector2f_false,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CInterpolatedVarArrayBase_LVector2f_false,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CInterpolatedVarArrayBase_LVector2f_false,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CInterpolatedVarArrayBase_LVector2f_false,
    PyType_GenericAlloc,
    Dtool_new_CInterpolatedVarArrayBase_LVector2f_false,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector2f_false,
  Dtool_UpcastInterface_CInterpolatedVarArrayBase_LVector2f_false,
  Dtool_DowncastInterface_CInterpolatedVarArrayBase_LVector2f_false,
  nullptr,
  (CoerceFunction)Dtool_Coerce_CInterpolatedVarArrayBase_LVector2f_false,
};

static void Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector2f_false(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_IInterpolatedVar(nullptr);
    Dtool_CInterpolatedVarArrayBase_LVector2f_false._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_IInterpolatedVar);
    Dtool_CInterpolatedVarArrayBase_LVector2f_false._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CInterpolatedVarArrayBase_LVector2f_false._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CInterpolatedVarArrayBase_LVector2f_false) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CInterpolatedVarArrayBase_LVector2f_false)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CInterpolatedVarArrayBase_LVector2f_false);
  }
}

/**
 * Python method tables for CInterpolatedVar_LVector3f (CInterpolatedVar_LVector3f)
 */
static PyMethodDef Dtool_Methods_CInterpolatedVar_LVector3f[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CInterpolatedVar_LVector3f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CInterpolatedVar_LVector3f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CInterpolatedVar_LVector3f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CInterpolatedVar_LVector3f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CInterpolatedVar_LVector3f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CInterpolatedVar_LVector3f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CInterpolatedVar_LVector3f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CInterpolatedVar_LVector3f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CInterpolatedVar_LVector3f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CInterpolatedVar_LVector3f,
    &Dtool_SequenceMethods_CInterpolatedVar_LVector3f,
    &Dtool_MappingMethods_CInterpolatedVar_LVector3f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CInterpolatedVar_LVector3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CInterpolatedVar_LVector3f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CInterpolatedVar_LVector3f,
    PyType_GenericAlloc,
    Dtool_new_CInterpolatedVar_LVector3f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CInterpolatedVar_LVector3f,
  Dtool_UpcastInterface_CInterpolatedVar_LVector3f,
  Dtool_DowncastInterface_CInterpolatedVar_LVector3f,
  nullptr,
  (CoerceFunction)Dtool_Coerce_CInterpolatedVar_LVector3f,
};

static void Dtool_PyModuleClassInit_CInterpolatedVar_LVector3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector3f_false(nullptr);
    Dtool_CInterpolatedVar_LVector3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterpolatedVarArrayBase_LVector3f_false);
    Dtool_CInterpolatedVar_LVector3f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CInterpolatedVar_LVector3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CInterpolatedVar_LVector3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CInterpolatedVar_LVector3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CInterpolatedVar_LVector3f);
  }
}

/**
 * Python method tables for CInterpolatedVarArrayBase_LVector3f_false (CInterpolatedVarArrayBase_LVector3f_false)
 */
static PyMethodDef Dtool_Methods_CInterpolatedVarArrayBase_LVector3f_false[] = {
  {"Setup", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector3f_false_Setup_571, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_Setup_571_comment},
  {"NoteChanged", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector3f_false_NoteChanged_572, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_NoteChanged_572_comment},
  {"Interpolate", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector3f_false_Interpolate_573, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_Interpolate_573_comment},
  {"DebugInterpolate", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector3f_false_DebugInterpolate_574, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_DebugInterpolate_574_comment},
  {"GetDerivative", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetDerivative_575, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetDerivative_575_comment},
  {"GetDerivative_SmoothVelocity", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetDerivative_SmoothVelocity_576, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetDerivative_SmoothVelocity_576_comment},
  {"GetDerivativeSmoothVelocity", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetDerivative_SmoothVelocity_576, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetDerivative_SmoothVelocity_576_comment},
  {"ClearHistory", &Dtool_CInterpolatedVarArrayBase_LVector3f_false_ClearHistory_577, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_ClearHistory_577_comment},
  {"AddToHead", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector3f_false_AddToHead_578, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_AddToHead_578_comment},
  {"GetPrev", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetPrev_579, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetPrev_579_comment},
  {"GetCurrent", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetCurrent_580, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetCurrent_580_comment},
  {"GetInterval", &Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetInterval_581, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetInterval_581_comment},
  {"IsValidIndex", &Dtool_CInterpolatedVarArrayBase_LVector3f_false_IsValidIndex_582, METH_O, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_IsValidIndex_582_comment},
  {"GetHead", &Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetHead_584, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetHead_584_comment},
  {"GetNext", &Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetNext_585, METH_O, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetNext_585_comment},
  {"SetHistoryValuesForItem", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetHistoryValuesForItem_586, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetHistoryValuesForItem_586_comment},
  {"SetLooping", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetLooping_587, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetLooping_587_comment},
  {"SetMaxCount", &Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetMaxCount_588, METH_O, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_SetMaxCount_588_comment},
  {"GetMaxCount", &Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetMaxCount_589, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetMaxCount_589_comment},
  {"GetOldestEntry", &Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetOldestEntry_590, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector3f_false_GetOldestEntry_590_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CInterpolatedVarArrayBase_LVector3f_false = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CInterpolatedVarArrayBase_LVector3f_false = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CInterpolatedVarArrayBase_LVector3f_false = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CInterpolatedVarArrayBase_LVector3f_false = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CInterpolatedVarArrayBase_LVector3f_false = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CInterpolatedVarArrayBase_LVector3f_false = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CInterpolatedVarArrayBase_LVector3f_false",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CInterpolatedVarArrayBase_LVector3f_false,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CInterpolatedVarArrayBase_LVector3f_false,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CInterpolatedVarArrayBase_LVector3f_false,
    &Dtool_SequenceMethods_CInterpolatedVarArrayBase_LVector3f_false,
    &Dtool_MappingMethods_CInterpolatedVarArrayBase_LVector3f_false,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CInterpolatedVarArrayBase_LVector3f_false,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CInterpolatedVarArrayBase_LVector3f_false,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CInterpolatedVarArrayBase_LVector3f_false,
    PyType_GenericAlloc,
    Dtool_new_CInterpolatedVarArrayBase_LVector3f_false,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector3f_false,
  Dtool_UpcastInterface_CInterpolatedVarArrayBase_LVector3f_false,
  Dtool_DowncastInterface_CInterpolatedVarArrayBase_LVector3f_false,
  nullptr,
  (CoerceFunction)Dtool_Coerce_CInterpolatedVarArrayBase_LVector3f_false,
};

static void Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector3f_false(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_IInterpolatedVar(nullptr);
    Dtool_CInterpolatedVarArrayBase_LVector3f_false._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_IInterpolatedVar);
    Dtool_CInterpolatedVarArrayBase_LVector3f_false._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CInterpolatedVarArrayBase_LVector3f_false._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CInterpolatedVarArrayBase_LVector3f_false) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CInterpolatedVarArrayBase_LVector3f_false)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CInterpolatedVarArrayBase_LVector3f_false);
  }
}

/**
 * Python method tables for CInterpolatedVar_LVector4f (CInterpolatedVar_LVector4f)
 */
static PyMethodDef Dtool_Methods_CInterpolatedVar_LVector4f[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CInterpolatedVar_LVector4f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CInterpolatedVar_LVector4f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CInterpolatedVar_LVector4f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CInterpolatedVar_LVector4f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CInterpolatedVar_LVector4f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CInterpolatedVar_LVector4f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CInterpolatedVar_LVector4f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CInterpolatedVar_LVector4f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CInterpolatedVar_LVector4f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CInterpolatedVar_LVector4f,
    &Dtool_SequenceMethods_CInterpolatedVar_LVector4f,
    &Dtool_MappingMethods_CInterpolatedVar_LVector4f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CInterpolatedVar_LVector4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CInterpolatedVar_LVector4f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CInterpolatedVar_LVector4f,
    PyType_GenericAlloc,
    Dtool_new_CInterpolatedVar_LVector4f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CInterpolatedVar_LVector4f,
  Dtool_UpcastInterface_CInterpolatedVar_LVector4f,
  Dtool_DowncastInterface_CInterpolatedVar_LVector4f,
  nullptr,
  (CoerceFunction)Dtool_Coerce_CInterpolatedVar_LVector4f,
};

static void Dtool_PyModuleClassInit_CInterpolatedVar_LVector4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector4f_false(nullptr);
    Dtool_CInterpolatedVar_LVector4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterpolatedVarArrayBase_LVector4f_false);
    Dtool_CInterpolatedVar_LVector4f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CInterpolatedVar_LVector4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CInterpolatedVar_LVector4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CInterpolatedVar_LVector4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CInterpolatedVar_LVector4f);
  }
}

/**
 * Python method tables for CInterpolatedVarArrayBase_LVector4f_false (CInterpolatedVarArrayBase_LVector4f_false)
 */
static PyMethodDef Dtool_Methods_CInterpolatedVarArrayBase_LVector4f_false[] = {
  {"Setup", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector4f_false_Setup_598, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_Setup_598_comment},
  {"NoteChanged", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector4f_false_NoteChanged_599, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_NoteChanged_599_comment},
  {"Interpolate", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector4f_false_Interpolate_600, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_Interpolate_600_comment},
  {"DebugInterpolate", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector4f_false_DebugInterpolate_601, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_DebugInterpolate_601_comment},
  {"GetDerivative", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetDerivative_602, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetDerivative_602_comment},
  {"GetDerivative_SmoothVelocity", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetDerivative_SmoothVelocity_603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetDerivative_SmoothVelocity_603_comment},
  {"GetDerivativeSmoothVelocity", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetDerivative_SmoothVelocity_603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetDerivative_SmoothVelocity_603_comment},
  {"ClearHistory", &Dtool_CInterpolatedVarArrayBase_LVector4f_false_ClearHistory_604, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_ClearHistory_604_comment},
  {"AddToHead", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector4f_false_AddToHead_605, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_AddToHead_605_comment},
  {"GetPrev", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetPrev_606, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetPrev_606_comment},
  {"GetCurrent", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetCurrent_607, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetCurrent_607_comment},
  {"GetInterval", &Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetInterval_608, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetInterval_608_comment},
  {"IsValidIndex", &Dtool_CInterpolatedVarArrayBase_LVector4f_false_IsValidIndex_609, METH_O, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_IsValidIndex_609_comment},
  {"GetHead", &Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetHead_611, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetHead_611_comment},
  {"GetNext", &Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetNext_612, METH_O, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetNext_612_comment},
  {"SetHistoryValuesForItem", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetHistoryValuesForItem_613, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetHistoryValuesForItem_613_comment},
  {"SetLooping", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetLooping_614, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetLooping_614_comment},
  {"SetMaxCount", &Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetMaxCount_615, METH_O, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_SetMaxCount_615_comment},
  {"GetMaxCount", &Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetMaxCount_616, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetMaxCount_616_comment},
  {"GetOldestEntry", &Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetOldestEntry_617, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_LVector4f_false_GetOldestEntry_617_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CInterpolatedVarArrayBase_LVector4f_false = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CInterpolatedVarArrayBase_LVector4f_false = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CInterpolatedVarArrayBase_LVector4f_false = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CInterpolatedVarArrayBase_LVector4f_false = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CInterpolatedVarArrayBase_LVector4f_false = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CInterpolatedVarArrayBase_LVector4f_false = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CInterpolatedVarArrayBase_LVector4f_false",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CInterpolatedVarArrayBase_LVector4f_false,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CInterpolatedVarArrayBase_LVector4f_false,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CInterpolatedVarArrayBase_LVector4f_false,
    &Dtool_SequenceMethods_CInterpolatedVarArrayBase_LVector4f_false,
    &Dtool_MappingMethods_CInterpolatedVarArrayBase_LVector4f_false,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CInterpolatedVarArrayBase_LVector4f_false,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CInterpolatedVarArrayBase_LVector4f_false,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CInterpolatedVarArrayBase_LVector4f_false,
    PyType_GenericAlloc,
    Dtool_new_CInterpolatedVarArrayBase_LVector4f_false,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector4f_false,
  Dtool_UpcastInterface_CInterpolatedVarArrayBase_LVector4f_false,
  Dtool_DowncastInterface_CInterpolatedVarArrayBase_LVector4f_false,
  nullptr,
  (CoerceFunction)Dtool_Coerce_CInterpolatedVarArrayBase_LVector4f_false,
};

static void Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector4f_false(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_IInterpolatedVar(nullptr);
    Dtool_CInterpolatedVarArrayBase_LVector4f_false._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_IInterpolatedVar);
    Dtool_CInterpolatedVarArrayBase_LVector4f_false._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CInterpolatedVarArrayBase_LVector4f_false._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CInterpolatedVarArrayBase_LVector4f_false) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CInterpolatedVarArrayBase_LVector4f_false)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CInterpolatedVarArrayBase_LVector4f_false);
  }
}

/**
 * Python method tables for CInterpolatedVar_float (CInterpolatedVar_float)
 */
static PyMethodDef Dtool_Methods_CInterpolatedVar_float[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CInterpolatedVar_float = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CInterpolatedVar_float = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CInterpolatedVar_float = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CInterpolatedVar_float = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CInterpolatedVar_float = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CInterpolatedVar_float = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CInterpolatedVar_float",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CInterpolatedVar_float,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CInterpolatedVar_float,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CInterpolatedVar_float,
    &Dtool_SequenceMethods_CInterpolatedVar_float,
    &Dtool_MappingMethods_CInterpolatedVar_float,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CInterpolatedVar_float,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CInterpolatedVar_float,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CInterpolatedVar_float,
    PyType_GenericAlloc,
    Dtool_new_CInterpolatedVar_float,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CInterpolatedVar_float,
  Dtool_UpcastInterface_CInterpolatedVar_float,
  Dtool_DowncastInterface_CInterpolatedVar_float,
  nullptr,
  (CoerceFunction)Dtool_Coerce_CInterpolatedVar_float,
};

static void Dtool_PyModuleClassInit_CInterpolatedVar_float(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_float_false(nullptr);
    Dtool_CInterpolatedVar_float._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterpolatedVarArrayBase_float_false);
    Dtool_CInterpolatedVar_float._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CInterpolatedVar_float._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CInterpolatedVar_float) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CInterpolatedVar_float)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CInterpolatedVar_float);
  }
}

/**
 * Python method tables for CInterpolatedVarArrayBase_float_false (CInterpolatedVarArrayBase_float_false)
 */
static PyMethodDef Dtool_Methods_CInterpolatedVarArrayBase_float_false[] = {
  {"NoteChanged", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_float_false_NoteChanged_626, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_float_false_NoteChanged_626_comment},
  {"Interpolate", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_float_false_Interpolate_627, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_float_false_Interpolate_627_comment},
  {"ClearHistory", &Dtool_CInterpolatedVarArrayBase_float_false_ClearHistory_631, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_float_false_ClearHistory_631_comment},
  {"GetPrev", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_float_false_GetPrev_633, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_float_false_GetPrev_633_comment},
  {"GetCurrent", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_float_false_GetCurrent_634, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_float_false_GetCurrent_634_comment},
  {"GetInterval", &Dtool_CInterpolatedVarArrayBase_float_false_GetInterval_635, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_float_false_GetInterval_635_comment},
  {"IsValidIndex", &Dtool_CInterpolatedVarArrayBase_float_false_IsValidIndex_636, METH_O, (const char *)Dtool_CInterpolatedVarArrayBase_float_false_IsValidIndex_636_comment},
  {"GetHead", &Dtool_CInterpolatedVarArrayBase_float_false_GetHead_638, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_float_false_GetHead_638_comment},
  {"GetNext", &Dtool_CInterpolatedVarArrayBase_float_false_GetNext_639, METH_O, (const char *)Dtool_CInterpolatedVarArrayBase_float_false_GetNext_639_comment},
  {"SetLooping", (PyCFunction) &Dtool_CInterpolatedVarArrayBase_float_false_SetLooping_641, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterpolatedVarArrayBase_float_false_SetLooping_641_comment},
  {"SetMaxCount", &Dtool_CInterpolatedVarArrayBase_float_false_SetMaxCount_642, METH_O, (const char *)Dtool_CInterpolatedVarArrayBase_float_false_SetMaxCount_642_comment},
  {"GetMaxCount", &Dtool_CInterpolatedVarArrayBase_float_false_GetMaxCount_643, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_float_false_GetMaxCount_643_comment},
  {"GetOldestEntry", &Dtool_CInterpolatedVarArrayBase_float_false_GetOldestEntry_644, METH_NOARGS, (const char *)Dtool_CInterpolatedVarArrayBase_float_false_GetOldestEntry_644_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CInterpolatedVarArrayBase_float_false = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CInterpolatedVarArrayBase_float_false = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CInterpolatedVarArrayBase_float_false = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CInterpolatedVarArrayBase_float_false = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CInterpolatedVarArrayBase_float_false = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CInterpolatedVarArrayBase_float_false = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "libpandabsp.CInterpolatedVarArrayBase_float_false",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CInterpolatedVarArrayBase_float_false,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CInterpolatedVarArrayBase_float_false,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CInterpolatedVarArrayBase_float_false,
    &Dtool_SequenceMethods_CInterpolatedVarArrayBase_float_false,
    &Dtool_MappingMethods_CInterpolatedVarArrayBase_float_false,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CInterpolatedVarArrayBase_float_false,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CInterpolatedVarArrayBase_float_false,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CInterpolatedVarArrayBase_float_false,
    PyType_GenericAlloc,
    Dtool_new_CInterpolatedVarArrayBase_float_false,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_float_false,
  Dtool_UpcastInterface_CInterpolatedVarArrayBase_float_false,
  Dtool_DowncastInterface_CInterpolatedVarArrayBase_float_false,
  nullptr,
  (CoerceFunction)Dtool_Coerce_CInterpolatedVarArrayBase_float_false,
};

static void Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_float_false(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_IInterpolatedVar(nullptr);
    Dtool_CInterpolatedVarArrayBase_float_false._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_IInterpolatedVar);
    Dtool_CInterpolatedVarArrayBase_float_false._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CInterpolatedVarArrayBase_float_false._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CInterpolatedVarArrayBase_float_false) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CInterpolatedVarArrayBase_float_false)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CInterpolatedVarArrayBase_float_false);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libpandabsp_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    BSPMaterial::init_type();
    TypeHandle handle = BSPMaterial::get_class_type();
    Dtool_BSPMaterial._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPMaterial);
  }
  {
    BSPMaterialAttrib::init_type();
    TypeHandle handle = BSPMaterialAttrib::get_class_type();
    Dtool_BSPMaterialAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPMaterialAttrib);
  }
  {
    RayTraceGeometry::init_type();
    TypeHandle handle = RayTraceGeometry::get_class_type();
    Dtool_RayTraceGeometry._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_RayTraceGeometry);
  }
  {
    RayTraceTriangleMesh::init_type();
    TypeHandle handle = RayTraceTriangleMesh::get_class_type();
    Dtool_RayTraceTriangleMesh._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_RayTraceTriangleMesh);
  }
  {
    BSPFaceAttrib::init_type();
    TypeHandle handle = BSPFaceAttrib::get_class_type();
    Dtool_BSPFaceAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPFaceAttrib);
  }
  {
    BoundingKDOP::init_type();
    TypeHandle handle = BoundingKDOP::get_class_type();
    Dtool_BoundingKDOP._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BoundingKDOP);
  }
  {
    CBaseEntity::init_type();
    TypeHandle handle = CBaseEntity::get_class_type();
    Dtool_CBaseEntity._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CBaseEntity);
  }
  {
    CPointEntity::init_type();
    TypeHandle handle = CPointEntity::get_class_type();
    Dtool_CPointEntity._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CPointEntity);
  }
  {
    CBoundsEntity::init_type();
    TypeHandle handle = CBoundsEntity::get_class_type();
    Dtool_CBoundsEntity._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CBoundsEntity);
  }
  {
    CBrushEntity::init_type();
    TypeHandle handle = CBrushEntity::get_class_type();
    Dtool_CBrushEntity._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CBrushEntity);
  }
  {
    ShaderSpec::init_type();
    TypeHandle handle = ShaderSpec::get_class_type();
    Dtool_ShaderSpec._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ShaderSpec);
  }
  {
    BSPShaderGenerator::init_type();
    TypeHandle handle = BSPShaderGenerator::get_class_type();
    Dtool_BSPShaderGenerator._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPShaderGenerator);
  }
  {
    BSPCullTraverser::init_type();
    TypeHandle handle = BSPCullTraverser::get_class_type();
    Dtool_BSPCullTraverser._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPCullTraverser);
  }
  {
    BSPRender::init_type();
    TypeHandle handle = BSPRender::get_class_type();
    Dtool_BSPRender._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPRender);
  }
  {
    BSPRoot::init_type();
    TypeHandle handle = BSPRoot::get_class_type();
    Dtool_BSPRoot._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPRoot);
  }
  {
    BSPProp::init_type();
    TypeHandle handle = BSPProp::get_class_type();
    Dtool_BSPProp._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPProp);
  }
  {
    BSPModel::init_type();
    TypeHandle handle = BSPModel::get_class_type();
    Dtool_BSPModel._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPModel);
  }
  {
    AmbientBoostEffect::init_type();
    TypeHandle handle = AmbientBoostEffect::get_class_type();
    Dtool_AmbientBoostEffect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AmbientBoostEffect);
  }
  {
    GlowNode::init_type();
    TypeHandle handle = GlowNode::get_class_type();
    Dtool_GlowNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GlowNode);
  }
  {
    PostProcessEffect::init_type();
    TypeHandle handle = PostProcessEffect::get_class_type();
    Dtool_PostProcessEffect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PostProcessEffect);
  }
  {
    PostProcessPass::init_type();
    TypeHandle handle = PostProcessPass::get_class_type();
    Dtool_PostProcessPass._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PostProcessPass);
  }
  {
    HDRPass::init_type();
    TypeHandle handle = HDRPass::get_class_type();
    Dtool_HDRPass._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_HDRPass);
  }
  {
    BloomEffect::init_type();
    TypeHandle handle = BloomEffect::get_class_type();
    Dtool_BloomEffect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BloomEffect);
  }
  {
    LightingOriginEffect::init_type();
    TypeHandle handle = LightingOriginEffect::get_class_type();
    Dtool_LightingOriginEffect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LightingOriginEffect);
  }
  {
    FXAA_Effect::init_type();
    TypeHandle handle = FXAA_Effect::get_class_type();
    Dtool_FXAA_Effect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_FXAA_Effect);
  }
  {
    BloomAttrib::init_type();
    TypeHandle handle = BloomAttrib::get_class_type();
    Dtool_BloomAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BloomAttrib);
  }
}

void Dtool_libpandabsp_BuildInstants(PyObject *module) {
  (void) module;
  // enum ShaderQuality
  PyModule_AddObject(module, "SHADERQUALITY_LOW", Dtool_WrapValue(::SHADERQUALITY_LOW));
  PyModule_AddObject(module, "SHADERQUALITYLOW", Dtool_WrapValue(::SHADERQUALITY_LOW));
  PyModule_AddObject(module, "SHADERQUALITY_MEDIUM", Dtool_WrapValue(::SHADERQUALITY_MEDIUM));
  PyModule_AddObject(module, "SHADERQUALITYMEDIUM", Dtool_WrapValue(::SHADERQUALITY_MEDIUM));
  PyModule_AddObject(module, "SHADERQUALITY_HIGH", Dtool_WrapValue(::SHADERQUALITY_HIGH));
  PyModule_AddObject(module, "SHADERQUALITYHIGH", Dtool_WrapValue(::SHADERQUALITY_HIGH));
  // enum CameraBits
  PyModule_AddObject(module, "CAMERA_MAIN", Dtool_WrapValue(::CAMERA_MAIN));
  PyModule_AddObject(module, "CAMERAMAIN", Dtool_WrapValue(::CAMERA_MAIN));
  PyModule_AddObject(module, "CAMERA_SHADOW", Dtool_WrapValue(::CAMERA_SHADOW));
  PyModule_AddObject(module, "CAMERASHADOW", Dtool_WrapValue(::CAMERA_SHADOW));
  PyModule_AddObject(module, "CAMERA_REFLECTION", Dtool_WrapValue(::CAMERA_REFLECTION));
  PyModule_AddObject(module, "CAMERAREFLECTION", Dtool_WrapValue(::CAMERA_REFLECTION));
  PyModule_AddObject(module, "CAMERA_REFRACTION", Dtool_WrapValue(::CAMERA_REFRACTION));
  PyModule_AddObject(module, "CAMERAREFRACTION", Dtool_WrapValue(::CAMERA_REFRACTION));
  PyModule_AddObject(module, "CAMERA_VIEWMODEL", Dtool_WrapValue(::CAMERA_VIEWMODEL));
  PyModule_AddObject(module, "CAMERAVIEWMODEL", Dtool_WrapValue(::CAMERA_VIEWMODEL));
  PyModule_AddObject(module, "CAMERA_COMPUTE", Dtool_WrapValue(::CAMERA_COMPUTE));
  PyModule_AddObject(module, "CAMERACOMPUTE", Dtool_WrapValue(::CAMERA_COMPUTE));
  // enum AuxBits
  PyModule_AddObject(module, "AUXBITS_NORMAL", Dtool_WrapValue(::AUXBITS_NORMAL));
  PyModule_AddObject(module, "AUXBITSNORMAL", Dtool_WrapValue(::AUXBITS_NORMAL));
  PyModule_AddObject(module, "AUXBITS_ARME", Dtool_WrapValue(::AUXBITS_ARME));
  PyModule_AddObject(module, "AUXBITSARME", Dtool_WrapValue(::AUXBITS_ARME));
  // enum PassTextureBits
  PyModule_AddObject(module, "bits_PASSTEXTURE_COLOR", Dtool_WrapValue(::bits_PASSTEXTURE_COLOR));
  PyModule_AddObject(module, "BitsPASSTEXTURECOLOR", Dtool_WrapValue(::bits_PASSTEXTURE_COLOR));
  PyModule_AddObject(module, "bits_PASSTEXTURE_DEPTH", Dtool_WrapValue(::bits_PASSTEXTURE_DEPTH));
  PyModule_AddObject(module, "BitsPASSTEXTUREDEPTH", Dtool_WrapValue(::bits_PASSTEXTURE_DEPTH));
  PyModule_AddObject(module, "bits_PASSTEXTURE_AUX0", Dtool_WrapValue(::bits_PASSTEXTURE_AUX0));
  PyModule_AddObject(module, "BitsPASSTEXTUREAUX0", Dtool_WrapValue(::bits_PASSTEXTURE_AUX0));
  PyModule_AddObject(module, "bits_PASSTEXTURE_AUX1", Dtool_WrapValue(::bits_PASSTEXTURE_AUX1));
  PyModule_AddObject(module, "BitsPASSTEXTUREAUX1", Dtool_WrapValue(::bits_PASSTEXTURE_AUX1));
  PyModule_AddObject(module, "bits_PASSTEXTURE_AUX2", Dtool_WrapValue(::bits_PASSTEXTURE_AUX2));
  PyModule_AddObject(module, "BitsPASSTEXTUREAUX2", Dtool_WrapValue(::bits_PASSTEXTURE_AUX2));
  PyModule_AddObject(module, "bits_PASSTEXTURE_AUX3", Dtool_WrapValue(::bits_PASSTEXTURE_AUX3));
  PyModule_AddObject(module, "BitsPASSTEXTUREAUX3", Dtool_WrapValue(::bits_PASSTEXTURE_AUX3));
  // enum MovementState
  PyModule_AddObject(module, "MOVEMENTSTATE_GROUND", Dtool_WrapValue(::MOVEMENTSTATE_GROUND));
  PyModule_AddObject(module, "MOVEMENTSTATEGROUND", Dtool_WrapValue(::MOVEMENTSTATE_GROUND));
  PyModule_AddObject(module, "MOVEMENTSTATE_JUMPING", Dtool_WrapValue(::MOVEMENTSTATE_JUMPING));
  PyModule_AddObject(module, "MOVEMENTSTATEJUMPING", Dtool_WrapValue(::MOVEMENTSTATE_JUMPING));
  PyModule_AddObject(module, "MOVEMENTSTATE_FALLING", Dtool_WrapValue(::MOVEMENTSTATE_FALLING));
  PyModule_AddObject(module, "MOVEMENTSTATEFALLING", Dtool_WrapValue(::MOVEMENTSTATE_FALLING));
  PyModule_AddObject(module, "MOVEMENTSTATE_SWIMMING", Dtool_WrapValue(::MOVEMENTSTATE_SWIMMING));
  PyModule_AddObject(module, "MOVEMENTSTATESWIMMING", Dtool_WrapValue(::MOVEMENTSTATE_SWIMMING));
  // enum InterpLatchFlags
  PyModule_AddObject(module, "LATCH_ANIMATION_VAR", Dtool_WrapValue(::LATCH_ANIMATION_VAR));
  PyModule_AddObject(module, "LATCHANIMATIONVAR", Dtool_WrapValue(::LATCH_ANIMATION_VAR));
  PyModule_AddObject(module, "LATCH_SIMULATION_VAR", Dtool_WrapValue(::LATCH_SIMULATION_VAR));
  PyModule_AddObject(module, "LATCHSIMULATIONVAR", Dtool_WrapValue(::LATCH_SIMULATION_VAR));
  PyModule_AddObject(module, "EXCLUDE_AUTO_LATCH", Dtool_WrapValue(::EXCLUDE_AUTO_LATCH));
  PyModule_AddObject(module, "EXCLUDEAUTOLATCH", Dtool_WrapValue(::EXCLUDE_AUTO_LATCH));
  PyModule_AddObject(module, "EXCLUDE_AUTO_INTERPOLATE", Dtool_WrapValue(::EXCLUDE_AUTO_INTERPOLATE));
  PyModule_AddObject(module, "EXCLUDEAUTOINTERPOLATE", Dtool_WrapValue(::EXCLUDE_AUTO_INTERPOLATE));
  PyModule_AddObject(module, "INTERPOLATE_LINEAR_ONLY", Dtool_WrapValue(::INTERPOLATE_LINEAR_ONLY));
  PyModule_AddObject(module, "INTERPOLATELINEARONLY", Dtool_WrapValue(::INTERPOLATE_LINEAR_ONLY));
  PyModule_AddObject(module, "INTERPOLATE_OMIT_UPDATE_LAST_NETWORKED", Dtool_WrapValue(::INTERPOLATE_OMIT_UPDATE_LAST_NETWORKED));
  PyModule_AddObject(module, "INTERPOLATEOMITUPDATELASTNETWORKED", Dtool_WrapValue(::INTERPOLATE_OMIT_UPDATE_LAST_NETWORKED));
  // TextureStages
  Dtool_PyModuleClassInit_TextureStages(module);
  PyModule_AddObject(module, "TextureStages", (PyObject *)&Dtool_TextureStages);
  // BSPMaterial
  Dtool_PyModuleClassInit_BSPMaterial(module);
  PyModule_AddObject(module, "BSPMaterial", (PyObject *)&Dtool_BSPMaterial);
  // BSPMaterialAttrib
  Dtool_PyModuleClassInit_BSPMaterialAttrib(module);
  PyModule_AddObject(module, "BSPMaterialAttrib", (PyObject *)&Dtool_BSPMaterialAttrib);
  // PackResult
  Dtool_PyModuleClassInit_PackResult(module);
  PyModule_AddObject(module, "PackResult", (PyObject *)&Dtool_PackResult);
  // TextureLocation
  Dtool_PyModuleClassInit_TextureLocation(module);
  PyModule_AddObject(module, "TextureLocation", (PyObject *)&Dtool_TextureLocation);
  // TexturePacker
  Dtool_PyModuleClassInit_TexturePacker(module);
  PyModule_AddObject(module, "TexturePacker", (PyObject *)&Dtool_TexturePacker);
  // RayTrace
  Dtool_PyModuleClassInit_RayTrace(module);
  PyModule_AddObject(module, "RayTrace", (PyObject *)&Dtool_RayTrace);
  // RayTraceHitResult
  Dtool_PyModuleClassInit_RayTraceHitResult(module);
  PyModule_AddObject(module, "RayTraceHitResult", (PyObject *)&Dtool_RayTraceHitResult);
  // RayTraceScene
  Dtool_PyModuleClassInit_RayTraceScene(module);
  PyModule_AddObject(module, "RayTraceScene", (PyObject *)&Dtool_RayTraceScene);
  // RayTraceGeometry
  Dtool_PyModuleClassInit_RayTraceGeometry(module);
  PyModule_AddObject(module, "RayTraceGeometry", (PyObject *)&Dtool_RayTraceGeometry);
  // RayTraceTriangleMesh
  Dtool_PyModuleClassInit_RayTraceTriangleMesh(module);
  PyModule_AddObject(module, "RayTraceTriangleMesh", (PyObject *)&Dtool_RayTraceTriangleMesh);
  // BSPFaceAttrib
  Dtool_PyModuleClassInit_BSPFaceAttrib(module);
  PyModule_AddObject(module, "BSPFaceAttrib", (PyObject *)&Dtool_BSPFaceAttrib);
  // BSPLoader
  Dtool_PyModuleClassInit_BSPLoader(module);
  PyModule_AddObject(module, "BSPLoader", (PyObject *)&Dtool_BSPLoader);
  // BoundingKDOP
  Dtool_PyModuleClassInit_BoundingKDOP(module);
  PyModule_AddObject(module, "BoundingKDOP", (PyObject *)&Dtool_BoundingKDOP);
  // CBaseEntity
  Dtool_PyModuleClassInit_CBaseEntity(module);
  PyModule_AddObject(module, "CBaseEntity", (PyObject *)&Dtool_CBaseEntity);
  // CPointEntity
  Dtool_PyModuleClassInit_CPointEntity(module);
  PyModule_AddObject(module, "CPointEntity", (PyObject *)&Dtool_CPointEntity);
  // CBoundsEntity
  Dtool_PyModuleClassInit_CBoundsEntity(module);
  PyModule_AddObject(module, "CBoundsEntity", (PyObject *)&Dtool_CBoundsEntity);
  // CBrushEntity
  Dtool_PyModuleClassInit_CBrushEntity(module);
  PyModule_AddObject(module, "CBrushEntity", (PyObject *)&Dtool_CBrushEntity);
  // ShaderPermutations
  Dtool_PyModuleClassInit_ShaderPermutations(module);
  PyModule_AddObject(module, "ShaderPermutations", (PyObject *)&Dtool_ShaderPermutations);
  // ShaderSpec
  Dtool_PyModuleClassInit_ShaderSpec(module);
  PyModule_AddObject(module, "ShaderSpec", (PyObject *)&Dtool_ShaderSpec);
  // PlanarReflections
  Dtool_PyModuleClassInit_PlanarReflections(module);
  PyModule_AddObject(module, "PlanarReflections", (PyObject *)&Dtool_PlanarReflections);
  // BSPShaderGenerator
  Dtool_PyModuleClassInit_BSPShaderGenerator(module);
  PyModule_AddObject(module, "BSPShaderGenerator", (PyObject *)&Dtool_BSPShaderGenerator);
  // BSPCullTraverser
  Dtool_PyModuleClassInit_BSPCullTraverser(module);
  PyModule_AddObject(module, "BSPCullTraverser", (PyObject *)&Dtool_BSPCullTraverser);
  // BSPRender
  Dtool_PyModuleClassInit_BSPRender(module);
  PyModule_AddObject(module, "BSPRender", (PyObject *)&Dtool_BSPRender);
  // BSPRoot
  Dtool_PyModuleClassInit_BSPRoot(module);
  PyModule_AddObject(module, "BSPRoot", (PyObject *)&Dtool_BSPRoot);
  // BSPProp
  Dtool_PyModuleClassInit_BSPProp(module);
  PyModule_AddObject(module, "BSPProp", (PyObject *)&Dtool_BSPProp);
  // BSPModel
  Dtool_PyModuleClassInit_BSPModel(module);
  PyModule_AddObject(module, "BSPModel", (PyObject *)&Dtool_BSPModel);
  // VertexLitGenericSpec
  Dtool_PyModuleClassInit_VertexLitGenericSpec(module);
  PyModule_AddObject(module, "VertexLitGenericSpec", (PyObject *)&Dtool_VertexLitGenericSpec);
  // LightmappedGenericSpec
  Dtool_PyModuleClassInit_LightmappedGenericSpec(module);
  PyModule_AddObject(module, "LightmappedGenericSpec", (PyObject *)&Dtool_LightmappedGenericSpec);
  // UnlitGenericSpec
  Dtool_PyModuleClassInit_UnlitGenericSpec(module);
  PyModule_AddObject(module, "UnlitGenericSpec", (PyObject *)&Dtool_UnlitGenericSpec);
  // UnlitNoMatSpec
  Dtool_PyModuleClassInit_UnlitNoMatSpec(module);
  PyModule_AddObject(module, "UnlitNoMatSpec", (PyObject *)&Dtool_UnlitNoMatSpec);
  // CSMRenderSpec
  Dtool_PyModuleClassInit_CSMRenderSpec(module);
  PyModule_AddObject(module, "CSMRenderSpec", (PyObject *)&Dtool_CSMRenderSpec);
  // SkyBoxSpec
  Dtool_PyModuleClassInit_SkyBoxSpec(module);
  PyModule_AddObject(module, "SkyBoxSpec", (PyObject *)&Dtool_SkyBoxSpec);
  // AmbientBoostEffect
  Dtool_PyModuleClassInit_AmbientBoostEffect(module);
  PyModule_AddObject(module, "AmbientBoostEffect", (PyObject *)&Dtool_AmbientBoostEffect);
  // Audio3DManager
  Dtool_PyModuleClassInit_Audio3DManager(module);
  PyModule_AddObject(module, "Audio3DManager", (PyObject *)&Dtool_Audio3DManager);
  // CIOLib
  Dtool_PyModuleClassInit_CIOLib(module);
  PyModule_AddObject(module, "CIOLib", (PyObject *)&Dtool_CIOLib);
  // DecalModulateSpec
  Dtool_PyModuleClassInit_DecalModulateSpec(module);
  PyModule_AddObject(module, "DecalModulateSpec", (PyObject *)&Dtool_DecalModulateSpec);
  // GlowNode
  Dtool_PyModuleClassInit_GlowNode(module);
  PyModule_AddObject(module, "GlowNode", (PyObject *)&Dtool_GlowNode);
  // PostProcessEffect
  Dtool_PyModuleClassInit_PostProcessEffect(module);
  PyModule_AddObject(module, "PostProcessEffect", (PyObject *)&Dtool_PostProcessEffect);
  // PostProcessPass
  Dtool_PyModuleClassInit_PostProcessPass(module);
  PyModule_AddObject(module, "PostProcessPass", (PyObject *)&Dtool_PostProcessPass);
  // PostProcessScenePass
  Dtool_PyModuleClassInit_PostProcessScenePass(module);
  PyModule_AddObject(module, "PostProcessScenePass", (PyObject *)&Dtool_PostProcessScenePass);
  // PostProcess
  Dtool_PyModuleClassInit_PostProcess(module);
  PyModule_AddObject(module, "PostProcess", (PyObject *)&Dtool_PostProcess);
  // HDRPass
  Dtool_PyModuleClassInit_HDRPass(module);
  PyModule_AddObject(module, "HDRPass", (PyObject *)&Dtool_HDRPass);
  // HDREffect
  Dtool_PyModuleClassInit_HDREffect(module);
  PyModule_AddObject(module, "HDREffect", (PyObject *)&Dtool_HDREffect);
  // BloomEffect
  Dtool_PyModuleClassInit_BloomEffect(module);
  PyModule_AddObject(module, "BloomEffect", (PyObject *)&Dtool_BloomEffect);
  // LightingOriginEffect
  Dtool_PyModuleClassInit_LightingOriginEffect(module);
  PyModule_AddObject(module, "LightingOriginEffect", (PyObject *)&Dtool_LightingOriginEffect);
  // FXAA_Effect
  Dtool_PyModuleClassInit_FXAA_Effect(module);
  PyModule_AddObject(module, "FXAA_Effect", (PyObject *)&Dtool_FXAA_Effect);
  Py_INCREF(Dtool_Ptr_FXAA_Effect);
  PyModule_AddObject(module, "FXAAEffect", (PyObject *)&Dtool_FXAA_Effect);
  // BloomAttrib
  Dtool_PyModuleClassInit_BloomAttrib(module);
  PyModule_AddObject(module, "BloomAttrib", (PyObject *)&Dtool_BloomAttrib);
  // PhysicsCharacterController
  Dtool_PyModuleClassInit_PhysicsCharacterController(module);
  PyModule_AddObject(module, "PhysicsCharacterController", (PyObject *)&Dtool_PhysicsCharacterController);
  // Py_BSPLoader
  Dtool_PyModuleClassInit_Py_BSPLoader(module);
  PyModule_AddObject(module, "Py_BSPLoader", (PyObject *)&Dtool_Py_BSPLoader);
  Py_INCREF(Dtool_Ptr_Py_BSPLoader);
  PyModule_AddObject(module, "PyBSPLoader", (PyObject *)&Dtool_Py_BSPLoader);
  // Py_CL_BSPLoader
  Dtool_PyModuleClassInit_Py_CL_BSPLoader(module);
  PyModule_AddObject(module, "Py_CL_BSPLoader", (PyObject *)&Dtool_Py_CL_BSPLoader);
  Py_INCREF(Dtool_Ptr_Py_CL_BSPLoader);
  PyModule_AddObject(module, "PyCLBSPLoader", (PyObject *)&Dtool_Py_CL_BSPLoader);
  // Py_AI_BSPLoader
  Dtool_PyModuleClassInit_Py_AI_BSPLoader(module);
  PyModule_AddObject(module, "Py_AI_BSPLoader", (PyObject *)&Dtool_Py_AI_BSPLoader);
  Py_INCREF(Dtool_Ptr_Py_AI_BSPLoader);
  PyModule_AddObject(module, "PyAIBSPLoader", (PyObject *)&Dtool_Py_AI_BSPLoader);
  // CInterpolationContext
  Dtool_PyModuleClassInit_CInterpolationContext(module);
  PyModule_AddObject(module, "CInterpolationContext", (PyObject *)&Dtool_CInterpolationContext);
  // IInterpolatedVar
  Dtool_PyModuleClassInit_IInterpolatedVar(module);
  PyModule_AddObject(module, "IInterpolatedVar", (PyObject *)&Dtool_IInterpolatedVar);
  // CInterpolatedVar< LVector2f >
  Dtool_PyModuleClassInit_CInterpolatedVar_LVector2f(module);
  PyModule_AddObject(module, "CInterpolatedVar_LVector2f", (PyObject *)&Dtool_CInterpolatedVar_LVector2f);
  Py_INCREF(Dtool_Ptr_CInterpolatedVar_LVector2f);
  PyModule_AddObject(module, "CInterpolatedVarLVector2f", (PyObject *)&Dtool_CInterpolatedVar_LVector2f);
  // CInterpolatedVarArrayBase< LVector2f, false >
  Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector2f_false(module);
  PyModule_AddObject(module, "CInterpolatedVarArrayBase_LVector2f_false", (PyObject *)&Dtool_CInterpolatedVarArrayBase_LVector2f_false);
  Py_INCREF(Dtool_Ptr_CInterpolatedVarArrayBase_LVector2f_false);
  PyModule_AddObject(module, "CInterpolatedVarArrayBaseLVector2fFalse", (PyObject *)&Dtool_CInterpolatedVarArrayBase_LVector2f_false);
  // typedef CInterpolatedVar< LVector2f > CInterpolatedVec2
  Dtool_PyModuleClassInit_CInterpolatedVar_LVector2f(module);
  Py_INCREF((PyObject *)&Dtool_CInterpolatedVar_LVector2f);
  PyModule_AddObject(module, "CInterpolatedVec2", (PyObject *)&Dtool_CInterpolatedVar_LVector2f);
  // CInterpolatedVar< LVector3f >
  Dtool_PyModuleClassInit_CInterpolatedVar_LVector3f(module);
  PyModule_AddObject(module, "CInterpolatedVar_LVector3f", (PyObject *)&Dtool_CInterpolatedVar_LVector3f);
  Py_INCREF(Dtool_Ptr_CInterpolatedVar_LVector3f);
  PyModule_AddObject(module, "CInterpolatedVarLVector3f", (PyObject *)&Dtool_CInterpolatedVar_LVector3f);
  // CInterpolatedVarArrayBase< LVector3f, false >
  Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector3f_false(module);
  PyModule_AddObject(module, "CInterpolatedVarArrayBase_LVector3f_false", (PyObject *)&Dtool_CInterpolatedVarArrayBase_LVector3f_false);
  Py_INCREF(Dtool_Ptr_CInterpolatedVarArrayBase_LVector3f_false);
  PyModule_AddObject(module, "CInterpolatedVarArrayBaseLVector3fFalse", (PyObject *)&Dtool_CInterpolatedVarArrayBase_LVector3f_false);
  // typedef CInterpolatedVar< LVector3f > CInterpolatedVec3
  Dtool_PyModuleClassInit_CInterpolatedVar_LVector3f(module);
  Py_INCREF((PyObject *)&Dtool_CInterpolatedVar_LVector3f);
  PyModule_AddObject(module, "CInterpolatedVec3", (PyObject *)&Dtool_CInterpolatedVar_LVector3f);
  // CInterpolatedVar< LVector4f >
  Dtool_PyModuleClassInit_CInterpolatedVar_LVector4f(module);
  PyModule_AddObject(module, "CInterpolatedVar_LVector4f", (PyObject *)&Dtool_CInterpolatedVar_LVector4f);
  Py_INCREF(Dtool_Ptr_CInterpolatedVar_LVector4f);
  PyModule_AddObject(module, "CInterpolatedVarLVector4f", (PyObject *)&Dtool_CInterpolatedVar_LVector4f);
  // CInterpolatedVarArrayBase< LVector4f, false >
  Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_LVector4f_false(module);
  PyModule_AddObject(module, "CInterpolatedVarArrayBase_LVector4f_false", (PyObject *)&Dtool_CInterpolatedVarArrayBase_LVector4f_false);
  Py_INCREF(Dtool_Ptr_CInterpolatedVarArrayBase_LVector4f_false);
  PyModule_AddObject(module, "CInterpolatedVarArrayBaseLVector4fFalse", (PyObject *)&Dtool_CInterpolatedVarArrayBase_LVector4f_false);
  // typedef CInterpolatedVar< LVector4f > CInterpolatedVec4
  Dtool_PyModuleClassInit_CInterpolatedVar_LVector4f(module);
  Py_INCREF((PyObject *)&Dtool_CInterpolatedVar_LVector4f);
  PyModule_AddObject(module, "CInterpolatedVec4", (PyObject *)&Dtool_CInterpolatedVar_LVector4f);
  // CInterpolatedVar< float >
  Dtool_PyModuleClassInit_CInterpolatedVar_float(module);
  PyModule_AddObject(module, "CInterpolatedVar_float", (PyObject *)&Dtool_CInterpolatedVar_float);
  Py_INCREF(Dtool_Ptr_CInterpolatedVar_float);
  PyModule_AddObject(module, "CInterpolatedVarFloat", (PyObject *)&Dtool_CInterpolatedVar_float);
  // CInterpolatedVarArrayBase< float, false >
  Dtool_PyModuleClassInit_CInterpolatedVarArrayBase_float_false(module);
  PyModule_AddObject(module, "CInterpolatedVarArrayBase_float_false", (PyObject *)&Dtool_CInterpolatedVarArrayBase_float_false);
  Py_INCREF(Dtool_Ptr_CInterpolatedVarArrayBase_float_false);
  PyModule_AddObject(module, "CInterpolatedVarArrayBaseFloatFalse", (PyObject *)&Dtool_CInterpolatedVarArrayBase_float_false);
  // typedef CInterpolatedVar< float > CInterpolatedFloat
  Dtool_PyModuleClassInit_CInterpolatedVar_float(module);
  Py_INCREF((PyObject *)&Dtool_CInterpolatedVar_float);
  PyModule_AddObject(module, "CInterpolatedFloat", (PyObject *)&Dtool_CInterpolatedVar_float);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libpandabsp_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libpandabsp_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1610341184,  /* file_identifier */
  "libpandabsp",  /* library_name */
  "7Oyg",  /* library_hash_name */
  "libpandabsp",  /* module_name */
  "libpandabsp.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  1437  /* next_index */
};

Configure(_in_configure_libpandabsp);
ConfigureFn(_in_configure_libpandabsp) {
  interrogate_request_module(&_in_module_def);
}

